const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./blosc-E49GQuAK.js","./chunk-INHXZS53-D3tQiqtZ.js","./lz4-BIGKWw27.js","./zstd-IvP746pw.js"])))=>i.map(i=>d[i]);
var uc=Object.defineProperty;var _n=t=>{throw TypeError(t)};var mc=(t,e,i)=>e in t?uc(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i;var L=(t,e,i)=>mc(t,typeof e!="symbol"?e+"":e,i),dr=(t,e,i)=>e.has(t)||_n("Cannot "+i);var te=(t,e,i)=>(dr(t,e,"read from private field"),i?i.call(t):e.get(t)),Se=(t,e,i)=>e.has(t)?_n("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),xe=(t,e,i,s)=>(dr(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),ur=(t,e,i)=>(dr(t,e,"access private method"),i);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const n of r)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function i(r){const n={};return r.integrity&&(n.integrity=r.integrity),r.referrerPolicy&&(n.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?n.credentials="include":r.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(r){if(r.ep)return;r.ep=!0;const n=i(r);fetch(r.href,n)}})();var gc=1e-6,Ne=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});function pc(){var t=new Ne(9);return Ne!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function Yt(t,e,i,s,r,n,a,o,l){var c=new Ne(9);return c[0]=t,c[1]=e,c[2]=i,c[3]=s,c[4]=r,c[5]=n,c[6]=a,c[7]=o,c[8]=l,c}function Do(t,e,i){var s=e[0],r=e[1],n=e[2],a=e[3],o=e[4],l=e[5],c=e[6],h=e[7],d=e[8],f=i[0],u=i[1],m=i[2],g=i[3],p=i[4],A=i[5],w=i[6],x=i[7],y=i[8];return t[0]=f*s+u*a+m*c,t[1]=f*r+u*o+m*h,t[2]=f*n+u*l+m*d,t[3]=g*s+p*a+A*c,t[4]=g*r+p*o+A*h,t[5]=g*n+p*l+A*d,t[6]=w*s+x*a+y*c,t[7]=w*r+x*o+y*h,t[8]=w*n+x*l+y*d,t}function se(){var t=new Ne(16);return Ne!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function be(t){var e=new Ne(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Ac(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function nt(t,e,i,s,r,n,a,o,l,c,h,d,f,u,m,g){var p=new Ne(16);return p[0]=t,p[1]=e,p[2]=i,p[3]=s,p[4]=r,p[5]=n,p[6]=a,p[7]=o,p[8]=l,p[9]=c,p[10]=h,p[11]=d,p[12]=f,p[13]=u,p[14]=m,p[15]=g,p}function To(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function rt(t,e){if(t===e){var i=e[1],s=e[2],r=e[3],n=e[6],a=e[7],o=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=i,t[6]=e[9],t[7]=e[13],t[8]=s,t[9]=n,t[11]=e[14],t[12]=r,t[13]=a,t[14]=o}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function Je(t,e){var i=e[0],s=e[1],r=e[2],n=e[3],a=e[4],o=e[5],l=e[6],c=e[7],h=e[8],d=e[9],f=e[10],u=e[11],m=e[12],g=e[13],p=e[14],A=e[15],w=i*o-s*a,x=i*l-r*a,y=i*c-n*a,v=s*l-r*o,D=s*c-n*o,b=r*c-n*l,C=h*g-d*m,I=h*p-f*m,M=h*A-u*m,T=d*p-f*g,S=d*A-u*g,E=f*A-u*p,B=w*E-x*S+y*T+v*M-D*I+b*C;return B?(B=1/B,t[0]=(o*E-l*S+c*T)*B,t[1]=(r*S-s*E-n*T)*B,t[2]=(g*b-p*D+A*v)*B,t[3]=(f*D-d*b-u*v)*B,t[4]=(l*M-a*E-c*I)*B,t[5]=(i*E-r*M+n*I)*B,t[6]=(p*y-m*b-A*x)*B,t[7]=(h*b-f*y+u*x)*B,t[8]=(a*S-o*M+c*C)*B,t[9]=(s*M-i*S-n*C)*B,t[10]=(m*D-g*y+A*w)*B,t[11]=(d*y-h*D-u*w)*B,t[12]=(o*I-a*T-l*C)*B,t[13]=(i*T-s*I+r*C)*B,t[14]=(g*x-m*v-p*w)*B,t[15]=(h*v-d*x+f*w)*B,t):null}function Rt(t,e,i){var s=e[0],r=e[1],n=e[2],a=e[3],o=e[4],l=e[5],c=e[6],h=e[7],d=e[8],f=e[9],u=e[10],m=e[11],g=e[12],p=e[13],A=e[14],w=e[15],x=i[0],y=i[1],v=i[2],D=i[3];return t[0]=x*s+y*o+v*d+D*g,t[1]=x*r+y*l+v*f+D*p,t[2]=x*n+y*c+v*u+D*A,t[3]=x*a+y*h+v*m+D*w,x=i[4],y=i[5],v=i[6],D=i[7],t[4]=x*s+y*o+v*d+D*g,t[5]=x*r+y*l+v*f+D*p,t[6]=x*n+y*c+v*u+D*A,t[7]=x*a+y*h+v*m+D*w,x=i[8],y=i[9],v=i[10],D=i[11],t[8]=x*s+y*o+v*d+D*g,t[9]=x*r+y*l+v*f+D*p,t[10]=x*n+y*c+v*u+D*A,t[11]=x*a+y*h+v*m+D*w,x=i[12],y=i[13],v=i[14],D=i[15],t[12]=x*s+y*o+v*d+D*g,t[13]=x*r+y*l+v*f+D*p,t[14]=x*n+y*c+v*u+D*A,t[15]=x*a+y*h+v*m+D*w,t}function ai(t,e,i){var s=i[0],r=i[1],n=i[2],a,o,l,c,h,d,f,u,m,g,p,A;return e===t?(t[12]=e[0]*s+e[4]*r+e[8]*n+e[12],t[13]=e[1]*s+e[5]*r+e[9]*n+e[13],t[14]=e[2]*s+e[6]*r+e[10]*n+e[14],t[15]=e[3]*s+e[7]*r+e[11]*n+e[15]):(a=e[0],o=e[1],l=e[2],c=e[3],h=e[4],d=e[5],f=e[6],u=e[7],m=e[8],g=e[9],p=e[10],A=e[11],t[0]=a,t[1]=o,t[2]=l,t[3]=c,t[4]=h,t[5]=d,t[6]=f,t[7]=u,t[8]=m,t[9]=g,t[10]=p,t[11]=A,t[12]=a*s+h*r+m*n+e[12],t[13]=o*s+d*r+g*n+e[13],t[14]=l*s+f*r+p*n+e[14],t[15]=c*s+u*r+A*n+e[15]),t}function $n(t,e,i){var s=i[0],r=i[1],n=i[2];return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*n,t[9]=e[9]*n,t[10]=e[10]*n,t[11]=e[11]*n,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function cs(t,e,i){var s=Math.sin(i),r=Math.cos(i),n=e[4],a=e[5],o=e[6],l=e[7],c=e[8],h=e[9],d=e[10],f=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=n*r+c*s,t[5]=a*r+h*s,t[6]=o*r+d*s,t[7]=l*r+f*s,t[8]=c*r-n*s,t[9]=h*r-a*s,t[10]=d*r-o*s,t[11]=f*r-l*s,t}function hs(t,e,i){var s=Math.sin(i),r=Math.cos(i),n=e[0],a=e[1],o=e[2],l=e[3],c=e[4],h=e[5],d=e[6],f=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=n*r+c*s,t[1]=a*r+h*s,t[2]=o*r+d*s,t[3]=l*r+f*s,t[4]=c*r-n*s,t[5]=h*r-a*s,t[6]=d*r-o*s,t[7]=f*r-l*s,t}function wc(t,e,i){var s=i[0],r=i[1],n=i[2],a=Math.hypot(s,r,n),o,l,c;return a<gc?null:(a=1/a,s*=a,r*=a,n*=a,o=Math.sin(e),l=Math.cos(e),c=1-l,t[0]=s*s*c+l,t[1]=r*s*c+n*o,t[2]=n*s*c-r*o,t[3]=0,t[4]=s*r*c-n*o,t[5]=r*r*c+l,t[6]=n*r*c+s*o,t[7]=0,t[8]=s*n*c+r*o,t[9]=r*n*c-s*o,t[10]=n*n*c+l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function xc(t,e,i,s,r,n,a){var o=1/(e-i),l=1/(s-r),c=1/(n-a);return t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(e+i)*o,t[13]=(r+s)*l,t[14]=(a+n)*c,t[15]=1,t}var fs=xc;function yc(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t[3]=e[3]*i,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*i,t[9]=e[9]*i,t[10]=e[10]*i,t[11]=e[11]*i,t[12]=e[12]*i,t[13]=e[13]*i,t[14]=e[14]*i,t[15]=e[15]*i,t}var Mo=Rt;function fe(){var t=new Ne(3);return Ne!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function Vi(t){var e=new Ne(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function Lt(t){var e=t[0],i=t[1],s=t[2];return Math.hypot(e,i,s)}function H(t,e,i){var s=new Ne(3);return s[0]=t,s[1]=e,s[2]=i,s}function ea(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function Ht(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t[2]=e[2]+i[2],t}function de(t,e,i){return t[0]=e[0]-i[0],t[1]=e[1]-i[1],t[2]=e[2]-i[2],t}function un(t,e,i){return t[0]=Math.min(e[0],i[0]),t[1]=Math.min(e[1],i[1]),t[2]=Math.min(e[2],i[2]),t}function mn(t,e,i){return t[0]=Math.max(e[0],i[0]),t[1]=Math.max(e[1],i[1]),t[2]=Math.max(e[2],i[2]),t}function vc(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t}function bc(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t}function ft(t,e){var i=e[0],s=e[1],r=e[2],n=i*i+s*s+r*r;return n>0&&(n=1/Math.sqrt(n)),t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t}function Cc(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function bs(t,e,i){var s=e[0],r=e[1],n=e[2],a=i[0],o=i[1],l=i[2];return t[0]=r*l-n*o,t[1]=n*a-s*l,t[2]=s*o-r*a,t}function Sc(t,e,i,s){var r=e[0],n=e[1],a=e[2];return t[0]=r+s*(i[0]-r),t[1]=n+s*(i[1]-n),t[2]=a+s*(i[2]-a),t}function mr(t,e){var i=t[0],s=t[1],r=t[2],n=e[0],a=e[1],o=e[2],l=Math.sqrt(i*i+s*s+r*r),c=Math.sqrt(n*n+a*a+o*o),h=l*c,d=h&&Cc(t,e)/h;return Math.acos(Math.min(Math.max(d,-1),1))}var ta=de,Li=Lt;(function(){var t=fe();return function(e,i,s,r,n,a){var o,l;for(i||(i=3),s||(s=0),r?l=Math.min(r*i+s,e.length):l=e.length,o=s;o<l;o+=i)t[0]=e[o],t[1]=e[o+1],t[2]=e[o+2],n(t,t,a),e[o]=t[0],e[o+1]=t[1],e[o+2]=t[2];return e}})();function Ct(){var t=new Ne(4);return Ne!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function Tt(t){var e=new Ne(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function ue(t,e,i,s){var r=new Ne(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r}function ia(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t[2]=e[2]+i[2],t[3]=e[3]+i[3],t}function Ec(t,e,i){return t[0]=e[0]-i[0],t[1]=e[1]-i[1],t[2]=e[2]-i[2],t[3]=e[3]-i[3],t}function Dc(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t[3]=e[3]*i,t}function Ve(t,e,i){var s=e[0],r=e[1],n=e[2],a=e[3];return t[0]=i[0]*s+i[4]*r+i[8]*n+i[12]*a,t[1]=i[1]*s+i[5]*r+i[9]*n+i[13]*a,t[2]=i[2]*s+i[6]*r+i[10]*n+i[14]*a,t[3]=i[3]*s+i[7]*r+i[11]*n+i[15]*a,t}var Tc=Ec;(function(){var t=Ct();return function(e,i,s,r,n,a){var o,l;for(i||(i=4),s||(s=0),r?l=Math.min(r*i+s,e.length):l=e.length,o=s;o<l;o+=i)t[0]=e[o],t[1]=e[o+1],t[2]=e[o+2],t[3]=e[o+3],n(t,t,a),e[o]=t[0],e[o+1]=t[1],e[o+2]=t[2],e[o+3]=t[3];return e}})();function Mc(){var t=new Ne(2);return Ne!=Float32Array&&(t[0]=0,t[1]=0),t}function sa(t,e){var i=new Ne(2);return i[0]=t,i[1]=e,i}function Ic(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t}function ra(t){var e=t[0],i=t[1];return Math.hypot(e,i)}function Fc(t,e){var i=e[0],s=e[1],r=i*i+s*s;return r>0&&(r=1/Math.sqrt(r)),t[0]=e[0]*r,t[1]=e[1]*r,t}(function(){var t=Mc();return function(e,i,s,r,n,a){var o,l;for(i||(i=2),s||(s=0),r?l=Math.min(r*i+s,e.length):l=e.length,o=s;o<l;o+=i)t[0]=e[o],t[1]=e[o+1],n(t,t,a),e[o]=t[0],e[o+1]=t[1];return e}})();var Wt=256,Cs=[],ds;for(;Wt--;)Cs[Wt]=(Wt+256).toString(16).substring(1);function zr(){var t=0,e,i="";if(!ds||Wt+16>256){for(ds=Array(t=256);t--;)ds[t]=256*Math.random()|0;t=Wt=0}for(;t<16;t++)e=ds[Wt+t],t==6?i+=Cs[e&15|64]:t==8?i+=Cs[e&63|128]:i+=Cs[e],t&1&&t>1&&t<11&&(i+="-");return Wt++,i}function Bc(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var Uc=function(e,i){var s=e.length;if(e===i)return!0;if(s!==i.length)return!1;for(var r=0;r<s;r++)if(e[r]!==i[r])return!1;return!0};const Pc=Bc(Uc),Io=-1,_s=0,Ri=1,Os=2,gn=3,pn=4,An=5,wn=6,Fo=7,Bo=8,na=typeof self=="object"?self:globalThis,Vc=(t,e)=>{const i=(r,n)=>(t.set(n,r),r),s=r=>{if(t.has(r))return t.get(r);const[n,a]=e[r];switch(n){case _s:case Io:return i(a,r);case Ri:{const o=i([],r);for(const l of a)o.push(s(l));return o}case Os:{const o=i({},r);for(const[l,c]of a)o[s(l)]=s(c);return o}case gn:return i(new Date(a),r);case pn:{const{source:o,flags:l}=a;return i(new RegExp(o,l),r)}case An:{const o=i(new Map,r);for(const[l,c]of a)o.set(s(l),s(c));return o}case wn:{const o=i(new Set,r);for(const l of a)o.add(s(l));return o}case Fo:{const{name:o,message:l}=a;return i(new na[o](l),r)}case Bo:return i(BigInt(a),r);case"BigInt":return i(Object(BigInt(a)),r);case"ArrayBuffer":return i(new Uint8Array(a).buffer,a);case"DataView":{const{buffer:o}=new Uint8Array(a);return i(new DataView(o),a)}}return i(new na[n](a),r)};return s},Rc=t=>Vc(new Map,t)(0),ei="",{toString:Nc}={},{keys:kc}=Object,wi=t=>{const e=typeof t;if(e!=="object"||!t)return[_s,e];const i=Nc.call(t).slice(8,-1);switch(i){case"Array":return[Ri,ei];case"Object":return[Os,ei];case"Date":return[gn,ei];case"RegExp":return[pn,ei];case"Map":return[An,ei];case"Set":return[wn,ei];case"DataView":return[Ri,i]}return i.includes("Array")?[Ri,i]:i.includes("Error")?[Fo,i]:[Os,i]},us=([t,e])=>t===_s&&(e==="function"||e==="symbol"),Lc=(t,e,i,s)=>{const r=(a,o)=>{const l=s.push(a)-1;return i.set(o,l),l},n=a=>{if(i.has(a))return i.get(a);let[o,l]=wi(a);switch(o){case _s:{let h=a;switch(l){case"bigint":o=Bo,h=a.toString();break;case"function":case"symbol":if(t)throw new TypeError("unable to serialize "+l);h=null;break;case"undefined":return r([Io],a)}return r([o,h],a)}case Ri:{if(l){let f=a;return l==="DataView"?f=new Uint8Array(a.buffer):l==="ArrayBuffer"&&(f=new Uint8Array(a)),r([l,[...f]],a)}const h=[],d=r([o,h],a);for(const f of a)h.push(n(f));return d}case Os:{if(l)switch(l){case"BigInt":return r([l,a.toString()],a);case"Boolean":case"Number":case"String":return r([l,a.valueOf()],a)}if(e&&"toJSON"in a)return n(a.toJSON());const h=[],d=r([o,h],a);for(const f of kc(a))(t||!us(wi(a[f])))&&h.push([n(f),n(a[f])]);return d}case gn:return r([o,a.toISOString()],a);case pn:{const{source:h,flags:d}=a;return r([o,{source:h,flags:d}],a)}case An:{const h=[],d=r([o,h],a);for(const[f,u]of a)(t||!(us(wi(f))||us(wi(u))))&&h.push([n(f),n(u)]);return d}case wn:{const h=[],d=r([o,h],a);for(const f of a)(t||!us(wi(f)))&&h.push(n(f));return d}}const{message:c}=a;return r([o,{name:l,message:c}],a)};return n},Oc=(t,{json:e,lossy:i}={})=>{const s=[];return Lc(!(e||i),!!e,new Map,s)(t),s};var Re=Uint8Array,hi=Uint16Array,zc=Int32Array,Uo=new Re([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Po=new Re([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gc=new Re([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Vo=function(t,e){for(var i=new hi(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];for(var r=new zc(i[30]),s=1;s<30;++s)for(var n=i[s];n<i[s+1];++n)r[n]=n-i[s]<<5|s;return{b:i,r}},Ro=Vo(Uo,2),No=Ro.b,Yc=Ro.r;No[28]=258,Yc[258]=28;var Wc=Vo(Po,0),Kc=Wc.b,Gr=new hi(32768);for(var ge=0;ge<32768;++ge){var Mt=(ge&43690)>>1|(ge&21845)<<1;Mt=(Mt&52428)>>2|(Mt&13107)<<2,Mt=(Mt&61680)>>4|(Mt&3855)<<4,Gr[ge]=((Mt&65280)>>8|(Mt&255)<<8)>>1}var Ni=function(t,e,i){for(var s=t.length,r=0,n=new hi(e);r<s;++r)t[r]&&++n[t[r]-1];var a=new hi(e);for(r=1;r<e;++r)a[r]=a[r-1]+n[r-1]<<1;var o;if(i){o=new hi(1<<e);var l=15-e;for(r=0;r<s;++r)if(t[r])for(var c=r<<4|t[r],h=e-t[r],d=a[t[r]-1]++<<h,f=d|(1<<h)-1;d<=f;++d)o[Gr[d]>>l]=c}else for(o=new hi(s),r=0;r<s;++r)t[r]&&(o[r]=Gr[a[t[r]-1]++]>>15-t[r]);return o},is=new Re(288);for(var ge=0;ge<144;++ge)is[ge]=8;for(var ge=144;ge<256;++ge)is[ge]=9;for(var ge=256;ge<280;++ge)is[ge]=7;for(var ge=280;ge<288;++ge)is[ge]=8;var ko=new Re(32);for(var ge=0;ge<32;++ge)ko[ge]=5;var jc=Ni(is,9,1),Hc=Ni(ko,5,1),gr=function(t){for(var e=t[0],i=1;i<t.length;++i)t[i]>e&&(e=t[i]);return e},ut=function(t,e,i){var s=e/8|0;return(t[s]|t[s+1]<<8)>>(e&7)&i},pr=function(t,e){var i=e/8|0;return(t[i]|t[i+1]<<8|t[i+2]<<16)>>(e&7)},Lo=function(t){return(t+7)/8|0},Ss=function(t,e,i){return(e==null||e<0)&&(e=0),(i==null||i>t.length)&&(i=t.length),new Re(t.subarray(e,i))},qc=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],qe=function(t,e,i){var s=new Error(e||qc[t]);if(s.code=t,Error.captureStackTrace&&Error.captureStackTrace(s,qe),!i)throw s;return s},$s=function(t,e,i,s){var r=t.length,n=0;if(!r||e.f&&!e.l)return i||new Re(0);var a=!i,o=a||e.i!=2,l=e.i;a&&(i=new Re(r*3));var c=function(Le){var ve=i.length;if(Le>ve){var Ai=new Re(Math.max(ve*2,Le));Ai.set(i),i=Ai}},h=e.f||0,d=e.p||0,f=e.b||0,u=e.l,m=e.d,g=e.m,p=e.n,A=r*8;do{if(!u){h=ut(t,d,1);var w=ut(t,d+1,3);if(d+=3,w)if(w==1)u=jc,m=Hc,g=9,p=5;else if(w==2){var D=ut(t,d,31)+257,b=ut(t,d+10,15)+4,C=D+ut(t,d+5,31)+1;d+=14;for(var I=new Re(C),M=new Re(19),T=0;T<b;++T)M[Gc[T]]=ut(t,d+T*3,7);d+=b*3;for(var S=gr(M),E=(1<<S)-1,B=Ni(M,S,1),T=0;T<C;){var P=B[ut(t,d,E)];d+=P&15;var x=P>>4;if(x<16)I[T++]=x;else{var V=0,R=0;for(x==16?(R=3+ut(t,d,3),d+=2,V=I[T-1]):x==17?(R=3+ut(t,d,7),d+=3):x==18&&(R=11+ut(t,d,127),d+=7);R--;)I[T++]=V}}var k=I.subarray(0,D),z=I.subarray(D);g=gr(k),p=gr(z),u=Ni(k,g,1),m=Ni(z,p,1)}else qe(1);else{var x=Lo(d)+4,y=t[x-4]|t[x-3]<<8,v=x+y;if(v>r){l&&qe(0);break}o&&c(f+y),i.set(t.subarray(x,v),f),e.b=f+=y,e.p=d=v*8,e.f=h;continue}if(d>A){l&&qe(0);break}}o&&c(f+131072);for(var W=(1<<g)-1,j=(1<<p)-1,Q=d;;Q=d){var V=u[pr(t,d)&W],pe=V>>4;if(d+=V&15,d>A){l&&qe(0);break}if(V||qe(2),pe<256)i[f++]=pe;else if(pe==256){Q=d,u=null;break}else{var Ce=pe-254;if(pe>264){var T=pe-257,Me=Uo[T];Ce=ut(t,d,(1<<Me)-1)+No[T],d+=Me}var Qe=m[pr(t,d)&j],tt=Qe>>4;Qe||qe(3),d+=Qe&15;var z=Kc[tt];if(tt>3){var Me=Po[tt];z+=pr(t,d)&(1<<Me)-1,d+=Me}if(d>A){l&&qe(0);break}o&&c(f+131072);var at=f+Ce;if(f<z){var dt=n-z,ke=Math.min(z,at);for(dt+f<0&&qe(3);f<ke;++f)i[f]=s[dt+f]}for(;f<at;++f)i[f]=i[f-z]}}e.l=u,e.p=Q,e.b=f,e.f=h,u&&(h=1,e.m=g,e.d=m,e.n=p)}while(!h);return f!=i.length&&a?Ss(i,0,f):i.subarray(0,f)},Qc=new Re(0),Oo=function(t){(t[0]!=31||t[1]!=139||t[2]!=8)&&qe(6,"invalid gzip data");var e=t[3],i=10;e&4&&(i+=(t[10]|t[11]<<8)+2);for(var s=(e>>3&1)+(e>>4&1);s>0;s-=!t[i++]);return i+(e&2)},Xc=function(t){var e=t.length;return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0},Zc=function(t,e){return((t[0]&15)!=8||t[0]>>4>7||(t[0]<<8|t[1])%31)&&qe(6,"invalid zlib data"),(t[1]>>5&1)==1&&qe(6,"invalid zlib data: "+(t[1]&32?"need":"unexpected")+" dictionary"),(t[1]>>3&4)+2},Ar=function(){function t(e,i){typeof e=="function"&&(i=e,e={}),this.ondata=i;var s=e&&e.dictionary&&e.dictionary.subarray(-32768);this.s={i:0,b:s?s.length:0},this.o=new Re(32768),this.p=new Re(0),s&&this.o.set(s)}return t.prototype.e=function(e){if(this.ondata||qe(5),this.d&&qe(4),!this.p.length)this.p=e;else if(e.length){var i=new Re(this.p.length+e.length);i.set(this.p),i.set(e,this.p.length),this.p=i}},t.prototype.c=function(e){this.s.i=+(this.d=e||!1);var i=this.s.b,s=$s(this.p,this.s,this.o);this.ondata(Ss(s,i,this.s.b),this.d),this.o=Ss(s,this.s.b-32768),this.s.b=this.o.length,this.p=Ss(this.p,this.s.p/8|0),this.s.p&=7},t.prototype.push=function(e,i){this.e(e),this.c(i)},t}();function Jc(t,e){return $s(t,{i:2},e,e)}var _c=function(){function t(e,i){this.v=1,this.r=0,Ar.call(this,e,i)}return t.prototype.push=function(e,i){if(Ar.prototype.e.call(this,e),this.r+=e.length,this.v){var s=this.p.subarray(this.v-1),r=s.length>3?Oo(s):4;if(r>s.length){if(!i)return}else this.v>1&&this.onmember&&this.onmember(this.r-s.length);this.p=s.subarray(r),this.v=0}Ar.prototype.c.call(this,i),this.s.f&&!this.s.l&&!i&&(this.v=Lo(this.s.p)+9,this.s={i:0},this.o=new Re(0),this.push(new Re(0),i))},t}();function $c(t,e){var i=Oo(t);return i+8>t.length&&qe(6,"invalid gzip data"),$s(t.subarray(i,-8),{i:2},new Re(Xc(t)),e)}function eh(t,e){return $s(t.subarray(Zc(t),-4),{i:2},e,e)}function th(t,e){return t[0]==31&&t[1]==139&&t[2]==8?$c(t,e):(t[0]&15)!=8||t[0]>>4>7||(t[0]<<8|t[1])%31?Jc(t,e):eh(t,e)}var ih=typeof TextDecoder<"u"&&new TextDecoder,sh=0;try{ih.decode(Qc,{stream:!0}),sh=1}catch{}class zo{constructor(e,i,s,r){L(this,"esize");L(this,"ecode");L(this,"edata");L(this,"littleEndian");if(e%16!=0)throw new Error("This does not appear to be a NIFTI extension");this.esize=e,this.ecode=i,this.edata=s,this.littleEndian=r}toArrayBuffer(){let e=new Uint8Array(this.esize),i=new Uint8Array(this.edata);e.set(i,8);let s=new DataView(e.buffer);return s.setInt32(0,this.esize,this.littleEndian),s.setInt32(4,this.ecode,this.littleEndian),e.buffer}}const je=class je{static getStringAt(e,i,s){var r="",n,a;for(n=i;n<s;n+=1)a=e.getUint8(n),a!==0&&(r+=String.fromCharCode(a));return r}static getIntAt(e,i,s){return e.getInt32(i,s)}static getFloatAt(e,i,s){return e.getFloat32(i,s)}static getDoubleAt(e,i,s){return e.getFloat64(i,s)}static getInt64At(e,i,s){const r=e.getUint32(i,s),n=e.getInt32(i+4,s);let a;return s?a=n*2**32+r:a=r*2**32+n,n<0&&(a+=-1*2**32*2**32),a}static getUint64At(e,i,s){const r=e.getUint32(i+(s?0:4),s),n=e.getUint32(i+(s?4:0),s);return s?n*2**32+r:r*2**32+n}static getExtensionsAt(e,i,s,r){let n=[],a=i;for(;a<r;){let o=s,l=je.getIntAt(e,a,s);if(!l)break;if(l+a>r&&(o=!o,l=je.getIntAt(e,a,o),l+a>r))throw new Error("This does not appear to be a valid NIFTI extension");if(l%16!=0)throw new Error("This does not appear to be a NIFTI extension");let c=je.getIntAt(e,a+4,o),h=e.buffer.slice(a+8,a+l),d=new zo(l,c,h,o);n.push(d),a+=l}return n}static toArrayBuffer(e){var i,s,r;for(i=new ArrayBuffer(e.length),s=new Uint8Array(i),r=0;r<e.length;r+=1)s[r]=e[r];return i}static isString(e){return typeof e=="string"||e instanceof String}static formatNumber(e,i=void 0){let s;return je.isString(e)?s=Number(e):s=e,i?s=s.toPrecision(5):s=s.toPrecision(7),parseFloat(s)}static makeCRCTable(){let e,i=[];for(var s=0;s<256;s++){e=s;for(var r=0;r<8;r++)e=e&1?3988292384^e>>>1:e>>>1;i[s]=e}return i}static crc32(e){je.crcTable||(je.crcTable=je.makeCRCTable());const i=je.crcTable;let s=-1;for(var r=0;r<e.byteLength;r++)s=s>>>8^i[(s^e.getUint8(r))&255];return(s^-1)>>>0}};L(je,"crcTable",null),L(je,"GUNZIP_MAGIC_COOKIE1",31),L(je,"GUNZIP_MAGIC_COOKIE2",139),L(je,"getByteAt",function(e,i){return e.getUint8(i)}),L(je,"getShortAt",function(e,i,s){return e.getInt16(i,s)});let K=je;const q=class q{constructor(){L(this,"littleEndian",!1);L(this,"dim_info",0);L(this,"dims",[]);L(this,"intent_p1",0);L(this,"intent_p2",0);L(this,"intent_p3",0);L(this,"intent_code",0);L(this,"datatypeCode",0);L(this,"numBitsPerVoxel",0);L(this,"slice_start",0);L(this,"slice_end",0);L(this,"slice_code",0);L(this,"pixDims",[]);L(this,"vox_offset",0);L(this,"scl_slope",1);L(this,"scl_inter",0);L(this,"xyzt_units",0);L(this,"cal_max",0);L(this,"cal_min",0);L(this,"slice_duration",0);L(this,"toffset",0);L(this,"description","");L(this,"aux_file","");L(this,"intent_name","");L(this,"qform_code",0);L(this,"sform_code",0);L(this,"quatern_a",0);L(this,"quatern_b",0);L(this,"quatern_c",0);L(this,"quatern_d",0);L(this,"qoffset_x",0);L(this,"qoffset_y",0);L(this,"qoffset_z",0);L(this,"affine",[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]);L(this,"qfac",1);L(this,"quatern_R");L(this,"magic","0");L(this,"isHDR",!1);L(this,"extensionFlag",[0,0,0,0]);L(this,"extensionSize",0);L(this,"extensionCode",0);L(this,"extensions",[]);L(this,"getDatatypeCodeString",function(e){return e===q.TYPE_UINT8?"1-Byte Unsigned Integer":e===q.TYPE_INT16?"2-Byte Signed Integer":e===q.TYPE_INT32?"4-Byte Signed Integer":e===q.TYPE_FLOAT32?"4-Byte Float":e===q.TYPE_FLOAT64?"8-Byte Float":e===q.TYPE_RGB24?"RGB":e===q.TYPE_INT8?"1-Byte Signed Integer":e===q.TYPE_UINT16?"2-Byte Unsigned Integer":e===q.TYPE_UINT32?"4-Byte Unsigned Integer":e===q.TYPE_INT64?"8-Byte Signed Integer":e===q.TYPE_UINT64?"8-Byte Unsigned Integer":"Unknown"});L(this,"getTransformCodeString",function(e){return e===q.XFORM_SCANNER_ANAT?"Scanner":e===q.XFORM_ALIGNED_ANAT?"Aligned":e===q.XFORM_TALAIRACH?"Talairach":e===q.XFORM_MNI_152?"MNI":"Unknown"});L(this,"getUnitsCodeString",function(e){return e===q.UNITS_METER?"Meters":e===q.UNITS_MM?"Millimeters":e===q.UNITS_MICRON?"Microns":e===q.UNITS_SEC?"Seconds":e===q.UNITS_MSEC?"Milliseconds":e===q.UNITS_USEC?"Microseconds":e===q.UNITS_HZ?"Hz":e===q.UNITS_PPM?"PPM":e===q.UNITS_RADS?"Rads":"Unknown"});L(this,"nifti_mat33_mul",function(e,i){var s=[[0,0,0],[0,0,0],[0,0,0]],r,n;for(r=0;r<3;r+=1)for(n=0;n<3;n+=1)s[r][n]=e[r][0]*i[0][n]+e[r][1]*i[1][n]+e[r][2]*i[2][n];return s});L(this,"nifti_mat33_determ",function(e){var i,s,r,n,a,o,l,c,h;return i=e[0][0],s=e[0][1],r=e[0][2],n=e[1][0],a=e[1][1],o=e[1][2],l=e[2][0],c=e[2][1],h=e[2][2],i*a*h-i*c*o-n*s*h+n*c*r+l*s*o-l*a*r})}readHeader(e){var i=new DataView(e),s=K.getIntAt(i,0,this.littleEndian),r,n,a,o;if(s!==q.MAGIC_COOKIE&&(this.littleEndian=!0,s=K.getIntAt(i,0,this.littleEndian)),s!==q.MAGIC_COOKIE)throw new Error("This does not appear to be a NIFTI file!");for(this.dim_info=K.getByteAt(i,39),r=0;r<8;r+=1)o=40+r*2,this.dims[r]=K.getShortAt(i,o,this.littleEndian);for(this.intent_p1=K.getFloatAt(i,56,this.littleEndian),this.intent_p2=K.getFloatAt(i,60,this.littleEndian),this.intent_p3=K.getFloatAt(i,64,this.littleEndian),this.intent_code=K.getShortAt(i,68,this.littleEndian),this.datatypeCode=K.getShortAt(i,70,this.littleEndian),this.numBitsPerVoxel=K.getShortAt(i,72,this.littleEndian),this.slice_start=K.getShortAt(i,74,this.littleEndian),r=0;r<8;r+=1)o=76+r*4,this.pixDims[r]=K.getFloatAt(i,o,this.littleEndian);if(this.vox_offset=K.getFloatAt(i,108,this.littleEndian),this.scl_slope=K.getFloatAt(i,112,this.littleEndian),this.scl_inter=K.getFloatAt(i,116,this.littleEndian),this.slice_end=K.getShortAt(i,120,this.littleEndian),this.slice_code=K.getByteAt(i,122),this.xyzt_units=K.getByteAt(i,123),this.cal_max=K.getFloatAt(i,124,this.littleEndian),this.cal_min=K.getFloatAt(i,128,this.littleEndian),this.slice_duration=K.getFloatAt(i,132,this.littleEndian),this.toffset=K.getFloatAt(i,136,this.littleEndian),this.description=K.getStringAt(i,148,228),this.aux_file=K.getStringAt(i,228,252),this.qform_code=K.getShortAt(i,252,this.littleEndian),this.sform_code=K.getShortAt(i,254,this.littleEndian),this.quatern_b=K.getFloatAt(i,256,this.littleEndian),this.quatern_c=K.getFloatAt(i,260,this.littleEndian),this.quatern_d=K.getFloatAt(i,264,this.littleEndian),this.quatern_a=Math.sqrt(1-(Math.pow(this.quatern_b,2)+Math.pow(this.quatern_c,2)+Math.pow(this.quatern_d,2))),this.qoffset_x=K.getFloatAt(i,268,this.littleEndian),this.qoffset_y=K.getFloatAt(i,272,this.littleEndian),this.qoffset_z=K.getFloatAt(i,276,this.littleEndian),this.qform_code<1&&this.sform_code<1&&(this.affine[0][0]=this.pixDims[1],this.affine[1][1]=this.pixDims[2],this.affine[2][2]=this.pixDims[3]),this.qform_code>0&&this.sform_code<this.qform_code){const l=this.quatern_a,c=this.quatern_b,h=this.quatern_c,d=this.quatern_d;for(this.qfac=this.pixDims[0]===0?1:this.pixDims[0],this.quatern_R=[[l*l+c*c-h*h-d*d,2*c*h-2*l*d,2*c*d+2*l*h],[2*c*h+2*l*d,l*l+h*h-c*c-d*d,2*h*d-2*l*c],[2*c*d-2*l*h,2*h*d+2*l*c,l*l+d*d-h*h-c*c]],n=0;n<3;n+=1)for(a=0;a<3;a+=1)this.affine[n][a]=this.quatern_R[n][a]*this.pixDims[a+1],a===2&&(this.affine[n][a]*=this.qfac);this.affine[0][3]=this.qoffset_x,this.affine[1][3]=this.qoffset_y,this.affine[2][3]=this.qoffset_z}else if(this.sform_code>0)for(n=0;n<3;n+=1)for(a=0;a<4;a+=1)o=280+(n*4+a)*4,this.affine[n][a]=K.getFloatAt(i,o,this.littleEndian);if(this.affine[3][0]=0,this.affine[3][1]=0,this.affine[3][2]=0,this.affine[3][3]=1,this.intent_name=K.getStringAt(i,328,344),this.magic=K.getStringAt(i,344,348),this.isHDR=this.magic===String.fromCharCode.apply(null,q.MAGIC_NUMBER2),i.byteLength>q.MAGIC_COOKIE){this.extensionFlag[0]=K.getByteAt(i,348),this.extensionFlag[1]=K.getByteAt(i,349),this.extensionFlag[2]=K.getByteAt(i,350),this.extensionFlag[3]=K.getByteAt(i,351);let l=!0;!this.isHDR&&this.vox_offset<=352&&(l=!1),i.byteLength<=368&&(l=!1),l&&this.extensionFlag[0]&&(this.extensions=K.getExtensionsAt(i,this.getExtensionLocation(),this.littleEndian,this.vox_offset),this.extensionSize=this.extensions[0].esize,this.extensionCode=this.extensions[0].ecode)}}toFormattedString(){var e=K.formatNumber,i="";return i+="Dim Info = "+this.dim_info+`
`,i+="Image Dimensions (1-8): "+this.dims[0]+", "+this.dims[1]+", "+this.dims[2]+", "+this.dims[3]+", "+this.dims[4]+", "+this.dims[5]+", "+this.dims[6]+", "+this.dims[7]+`
`,i+="Intent Parameters (1-3): "+this.intent_p1+", "+this.intent_p2+", "+this.intent_p3+`
`,i+="Intent Code = "+this.intent_code+`
`,i+="Datatype = "+this.datatypeCode+" ("+this.getDatatypeCodeString(this.datatypeCode)+`)
`,i+="Bits Per Voxel = "+this.numBitsPerVoxel+`
`,i+="Slice Start = "+this.slice_start+`
`,i+="Voxel Dimensions (1-8): "+e(this.pixDims[0])+", "+e(this.pixDims[1])+", "+e(this.pixDims[2])+", "+e(this.pixDims[3])+", "+e(this.pixDims[4])+", "+e(this.pixDims[5])+", "+e(this.pixDims[6])+", "+e(this.pixDims[7])+`
`,i+="Image Offset = "+this.vox_offset+`
`,i+="Data Scale:  Slope = "+e(this.scl_slope)+"  Intercept = "+e(this.scl_inter)+`
`,i+="Slice End = "+this.slice_end+`
`,i+="Slice Code = "+this.slice_code+`
`,i+="Units Code = "+this.xyzt_units+" ("+this.getUnitsCodeString(q.SPATIAL_UNITS_MASK&this.xyzt_units)+", "+this.getUnitsCodeString(q.TEMPORAL_UNITS_MASK&this.xyzt_units)+`)
`,i+="Display Range:  Max = "+e(this.cal_max)+"  Min = "+e(this.cal_min)+`
`,i+="Slice Duration = "+this.slice_duration+`
`,i+="Time Axis Shift = "+this.toffset+`
`,i+='Description: "'+this.description+`"
`,i+='Auxiliary File: "'+this.aux_file+`"
`,i+="Q-Form Code = "+this.qform_code+" ("+this.getTransformCodeString(this.qform_code)+`)
`,i+="S-Form Code = "+this.sform_code+" ("+this.getTransformCodeString(this.sform_code)+`)
`,i+="Quaternion Parameters:  b = "+e(this.quatern_b)+"  c = "+e(this.quatern_c)+"  d = "+e(this.quatern_d)+`
`,i+="Quaternion Offsets:  x = "+this.qoffset_x+"  y = "+this.qoffset_y+"  z = "+this.qoffset_z+`
`,i+="S-Form Parameters X: "+e(this.affine[0][0])+", "+e(this.affine[0][1])+", "+e(this.affine[0][2])+", "+e(this.affine[0][3])+`
`,i+="S-Form Parameters Y: "+e(this.affine[1][0])+", "+e(this.affine[1][1])+", "+e(this.affine[1][2])+", "+e(this.affine[1][3])+`
`,i+="S-Form Parameters Z: "+e(this.affine[2][0])+", "+e(this.affine[2][1])+", "+e(this.affine[2][2])+", "+e(this.affine[2][3])+`
`,i+='Intent Name: "'+this.intent_name+`"
`,this.extensionFlag[0]&&(i+="Extension: Size = "+this.extensionSize+"  Code = "+this.extensionCode+`
`),i}getQformMat(){return this.convertNiftiQFormToNiftiSForm(this.quatern_b,this.quatern_c,this.quatern_d,this.qoffset_x,this.qoffset_y,this.qoffset_z,this.pixDims[1],this.pixDims[2],this.pixDims[3],this.pixDims[0])}convertNiftiQFormToNiftiSForm(e,i,s,r,n,a,o,l,c,h){var d=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],f,u=e,m=i,g=s,p,A,w;return d[3][0]=d[3][1]=d[3][2]=0,d[3][3]=1,f=1-(u*u+m*m+g*g),f<1e-7?(f=1/Math.sqrt(u*u+m*m+g*g),u*=f,m*=f,g*=f,f=0):f=Math.sqrt(f),p=o>0?o:1,A=l>0?l:1,w=c>0?c:1,h<0&&(w=-w),d[0][0]=(f*f+u*u-m*m-g*g)*p,d[0][1]=2*(u*m-f*g)*A,d[0][2]=2*(u*g+f*m)*w,d[1][0]=2*(u*m+f*g)*p,d[1][1]=(f*f+m*m-u*u-g*g)*A,d[1][2]=2*(m*g-f*u)*w,d[2][0]=2*(u*g-f*m)*p,d[2][1]=2*(m*g+f*u)*A,d[2][2]=(f*f+g*g-m*m-u*u)*w,d[0][3]=r,d[1][3]=n,d[2][3]=a,d}convertNiftiSFormToNEMA(e){var i,s,r,n,a,o,l,c,h,d,f,u,m,g,p,A,w,x,y,v,D,b,C,I,M,T,S,E,B,P,V,R,k,z;if(p=0,S=[[0,0,0],[0,0,0],[0,0,0]],E=[[0,0,0],[0,0,0],[0,0,0]],i=e[0][0],s=e[0][1],r=e[0][2],n=e[1][0],a=e[1][1],o=e[1][2],l=e[2][0],c=e[2][1],h=e[2][2],d=Math.sqrt(i*i+n*n+l*l),d===0||(i/=d,n/=d,l/=d,d=Math.sqrt(s*s+a*a+c*c),d===0))return null;if(s/=d,a/=d,c/=d,d=i*s+n*a+l*c,Math.abs(d)>1e-4){if(s-=d*i,a-=d*n,c-=d*l,d=Math.sqrt(s*s+a*a+c*c),d===0)return null;s/=d,a/=d,c/=d}if(d=Math.sqrt(r*r+o*o+h*h),d===0?(r=n*c-l*a,o=l*s-c*i,h=i*a-n*s):(r/=d,o/=d,h/=d),d=i*r+n*o+l*h,Math.abs(d)>1e-4){if(r-=d*i,o-=d*n,h-=d*l,d=Math.sqrt(r*r+o*o+h*h),d===0)return null;r/=d,o/=d,h/=d}if(d=s*r+a*o+c*h,Math.abs(d)>1e-4){if(r-=d*s,o-=d*a,h-=d*c,d=Math.sqrt(r*r+o*o+h*h),d===0)return null;r/=d,o/=d,h/=d}if(S[0][0]=i,S[0][1]=s,S[0][2]=r,S[1][0]=n,S[1][1]=a,S[1][2]=o,S[2][0]=l,S[2][1]=c,S[2][2]=h,f=this.nifti_mat33_determ(S),f===0)return null;for(T=-666,y=b=C=I=1,v=2,D=3,m=1;m<=3;m+=1)for(g=1;g<=3;g+=1)if(m!==g){for(p=1;p<=3;p+=1)if(!(m===p||g===p))for(E[0][0]=E[0][1]=E[0][2]=E[1][0]=E[1][1]=E[1][2]=E[2][0]=E[2][1]=E[2][2]=0,A=-1;A<=1;A+=2)for(w=-1;w<=1;w+=2)for(x=-1;x<=1;x+=2)E[0][m-1]=A,E[1][g-1]=w,E[2][p-1]=x,u=this.nifti_mat33_determ(E),u*f>0&&(M=this.nifti_mat33_mul(E,S),d=M[0][0]+M[1][1]+M[2][2],d>T&&(T=d,y=m,v=g,D=p,b=A,C=w,I=x))}switch(B=P=V=R=k=z="",y*b){case 1:B="X",R="+";break;case-1:B="X",R="-";break;case 2:B="Y",R="+";break;case-2:B="Y",R="-";break;case 3:B="Z",R="+";break;case-3:B="Z",R="-";break}switch(v*C){case 1:P="X",k="+";break;case-1:P="X",k="-";break;case 2:P="Y",k="+";break;case-2:P="Y",k="-";break;case 3:P="Z",k="+";break;case-3:P="Z",k="-";break}switch(D*I){case 1:V="X",z="+";break;case-1:V="X",z="-";break;case 2:V="Y",z="+";break;case-2:V="Y",z="-";break;case 3:V="Z",z="+";break;case-3:V="Z",z="-";break}return B+P+V+R+k+z}getExtensionLocation(){return q.MAGIC_COOKIE+4}getExtensionSize(e){return K.getIntAt(e,this.getExtensionLocation(),this.littleEndian)}getExtensionCode(e){return K.getIntAt(e,this.getExtensionLocation()+4,this.littleEndian)}addExtension(e,i=-1){i==-1?this.extensions.push(e):this.extensions.splice(i,0,e),this.vox_offset+=e.esize}removeExtension(e){let i=this.extensions[e];i&&(this.vox_offset-=i.esize),this.extensions.splice(e,1)}toArrayBuffer(e=!1){let r=352;if(e)for(let l of this.extensions)r+=l.esize;let n=new Uint8Array(r),a=new DataView(n.buffer);a.setInt32(0,348,this.littleEndian),a.setUint8(39,this.dim_info);for(let l=0;l<8;l++)a.setUint16(40+2*l,this.dims[l],this.littleEndian);a.setFloat32(56,this.intent_p1,this.littleEndian),a.setFloat32(60,this.intent_p2,this.littleEndian),a.setFloat32(64,this.intent_p3,this.littleEndian),a.setInt16(68,this.intent_code,this.littleEndian),a.setInt16(70,this.datatypeCode,this.littleEndian),a.setInt16(72,this.numBitsPerVoxel,this.littleEndian),a.setInt16(74,this.slice_start,this.littleEndian);for(let l=0;l<8;l++)a.setFloat32(76+4*l,this.pixDims[l],this.littleEndian);a.setFloat32(108,this.vox_offset,this.littleEndian),a.setFloat32(112,this.scl_slope,this.littleEndian),a.setFloat32(116,this.scl_inter,this.littleEndian),a.setInt16(120,this.slice_end,this.littleEndian),a.setUint8(122,this.slice_code),a.setUint8(123,this.xyzt_units),a.setFloat32(124,this.cal_max,this.littleEndian),a.setFloat32(128,this.cal_min,this.littleEndian),a.setFloat32(132,this.slice_duration,this.littleEndian),a.setFloat32(136,this.toffset,this.littleEndian),n.set(new TextEncoder().encode(this.description),148),n.set(new TextEncoder().encode(this.aux_file),228),a.setInt16(252,this.qform_code,this.littleEndian),a.setInt16(254,this.sform_code,this.littleEndian),a.setFloat32(256,this.quatern_b,this.littleEndian),a.setFloat32(260,this.quatern_c,this.littleEndian),a.setFloat32(264,this.quatern_d,this.littleEndian),a.setFloat32(268,this.qoffset_x,this.littleEndian),a.setFloat32(272,this.qoffset_y,this.littleEndian),a.setFloat32(276,this.qoffset_z,this.littleEndian);const o=this.affine.flat();for(let l=0;l<12;l++)a.setFloat32(280+4*l,o[l],this.littleEndian);if(n.set(new TextEncoder().encode(this.intent_name),328),n.set(new TextEncoder().encode(this.magic),344),e){n.set(Uint8Array.from([1,0,0,0]),348);let l=this.getExtensionLocation();for(const c of this.extensions)a.setInt32(l,c.esize,c.littleEndian),a.setInt32(l+4,c.ecode,c.littleEndian),n.set(new Uint8Array(c.edata),l+8),l+=c.esize}else n.set(new Uint8Array(4).fill(0),348);return n.buffer}};L(q,"TYPE_NONE",0),L(q,"TYPE_BINARY",1),L(q,"TYPE_UINT8",2),L(q,"TYPE_INT16",4),L(q,"TYPE_INT32",8),L(q,"TYPE_FLOAT32",16),L(q,"TYPE_COMPLEX64",32),L(q,"TYPE_FLOAT64",64),L(q,"TYPE_RGB24",128),L(q,"TYPE_INT8",256),L(q,"TYPE_UINT16",512),L(q,"TYPE_UINT32",768),L(q,"TYPE_INT64",1024),L(q,"TYPE_UINT64",1280),L(q,"TYPE_FLOAT128",1536),L(q,"TYPE_COMPLEX128",1792),L(q,"TYPE_COMPLEX256",2048),L(q,"XFORM_UNKNOWN",0),L(q,"XFORM_SCANNER_ANAT",1),L(q,"XFORM_ALIGNED_ANAT",2),L(q,"XFORM_TALAIRACH",3),L(q,"XFORM_MNI_152",4),L(q,"SPATIAL_UNITS_MASK",7),L(q,"TEMPORAL_UNITS_MASK",56),L(q,"UNITS_UNKNOWN",0),L(q,"UNITS_METER",1),L(q,"UNITS_MM",2),L(q,"UNITS_MICRON",3),L(q,"UNITS_SEC",8),L(q,"UNITS_MSEC",16),L(q,"UNITS_USEC",24),L(q,"UNITS_HZ",32),L(q,"UNITS_PPM",40),L(q,"UNITS_RADS",48),L(q,"MAGIC_COOKIE",348),L(q,"STANDARD_HEADER_SIZE",348),L(q,"MAGIC_NUMBER_LOCATION",344),L(q,"MAGIC_NUMBER",[110,43,49]),L(q,"MAGIC_NUMBER2",[110,105,49]),L(q,"EXTENSION_HEADER_SIZE",8);let ee=q;const xt=class xt{constructor(){L(this,"littleEndian",!1);L(this,"dim_info",0);L(this,"dims",[]);L(this,"intent_p1",0);L(this,"intent_p2",0);L(this,"intent_p3",0);L(this,"intent_code",0);L(this,"datatypeCode",0);L(this,"numBitsPerVoxel",0);L(this,"slice_start",0);L(this,"slice_end",0);L(this,"slice_code",0);L(this,"pixDims",[]);L(this,"vox_offset",0);L(this,"scl_slope",1);L(this,"scl_inter",0);L(this,"xyzt_units",0);L(this,"cal_max",0);L(this,"cal_min",0);L(this,"slice_duration",0);L(this,"toffset",0);L(this,"description","");L(this,"aux_file","");L(this,"intent_name","");L(this,"qform_code",0);L(this,"sform_code",0);L(this,"quatern_b",0);L(this,"quatern_c",0);L(this,"quatern_d",0);L(this,"qoffset_x",0);L(this,"qoffset_y",0);L(this,"qoffset_z",0);L(this,"affine",[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]);L(this,"magic","0");L(this,"extensionFlag",[0,0,0,0]);L(this,"extensions",[]);L(this,"extensionSize",0);L(this,"extensionCode",0);L(this,"getExtensionLocation",function(){return xt.MAGIC_COOKIE+4});L(this,"getExtensionSize",ee.prototype.getExtensionSize);L(this,"getExtensionCode",ee.prototype.getExtensionCode);L(this,"addExtension",ee.prototype.addExtension);L(this,"removeExtension",ee.prototype.removeExtension);L(this,"getDatatypeCodeString",ee.prototype.getDatatypeCodeString);L(this,"getTransformCodeString",ee.prototype.getTransformCodeString);L(this,"getUnitsCodeString",ee.prototype.getUnitsCodeString);L(this,"getQformMat",ee.prototype.getQformMat);L(this,"convertNiftiQFormToNiftiSForm",ee.prototype.convertNiftiQFormToNiftiSForm);L(this,"convertNiftiSFormToNEMA",ee.prototype.convertNiftiSFormToNEMA);L(this,"nifti_mat33_mul",ee.prototype.nifti_mat33_mul);L(this,"nifti_mat33_determ",ee.prototype.nifti_mat33_determ)}readHeader(e){var i=new DataView(e),s=K.getIntAt(i,0,this.littleEndian),r,n,a,o;if(s!==xt.MAGIC_COOKIE&&(this.littleEndian=!0,s=K.getIntAt(i,0,this.littleEndian)),s!==xt.MAGIC_COOKIE)throw new Error("This does not appear to be a NIFTI file!");for(this.magic=K.getStringAt(i,4,12),this.datatypeCode=K.getShortAt(i,12,this.littleEndian),this.numBitsPerVoxel=K.getShortAt(i,14,this.littleEndian),r=0;r<8;r+=1)o=16+r*8,this.dims[r]=K.getInt64At(i,o,this.littleEndian);for(this.intent_p1=K.getDoubleAt(i,80,this.littleEndian),this.intent_p2=K.getDoubleAt(i,88,this.littleEndian),this.intent_p3=K.getDoubleAt(i,96,this.littleEndian),r=0;r<8;r+=1)o=104+r*8,this.pixDims[r]=K.getDoubleAt(i,o,this.littleEndian);for(this.vox_offset=K.getInt64At(i,168,this.littleEndian),this.scl_slope=K.getDoubleAt(i,176,this.littleEndian),this.scl_inter=K.getDoubleAt(i,184,this.littleEndian),this.cal_max=K.getDoubleAt(i,192,this.littleEndian),this.cal_min=K.getDoubleAt(i,200,this.littleEndian),this.slice_duration=K.getDoubleAt(i,208,this.littleEndian),this.toffset=K.getDoubleAt(i,216,this.littleEndian),this.slice_start=K.getInt64At(i,224,this.littleEndian),this.slice_end=K.getInt64At(i,232,this.littleEndian),this.description=K.getStringAt(i,240,320),this.aux_file=K.getStringAt(i,320,344),this.qform_code=K.getIntAt(i,344,this.littleEndian),this.sform_code=K.getIntAt(i,348,this.littleEndian),this.quatern_b=K.getDoubleAt(i,352,this.littleEndian),this.quatern_c=K.getDoubleAt(i,360,this.littleEndian),this.quatern_d=K.getDoubleAt(i,368,this.littleEndian),this.qoffset_x=K.getDoubleAt(i,376,this.littleEndian),this.qoffset_y=K.getDoubleAt(i,384,this.littleEndian),this.qoffset_z=K.getDoubleAt(i,392,this.littleEndian),n=0;n<3;n+=1)for(a=0;a<4;a+=1)o=400+(n*4+a)*8,this.affine[n][a]=K.getDoubleAt(i,o,this.littleEndian);this.affine[3][0]=0,this.affine[3][1]=0,this.affine[3][2]=0,this.affine[3][3]=1,this.slice_code=K.getIntAt(i,496,this.littleEndian),this.xyzt_units=K.getIntAt(i,500,this.littleEndian),this.intent_code=K.getIntAt(i,504,this.littleEndian),this.intent_name=K.getStringAt(i,508,524),this.dim_info=K.getByteAt(i,524),i.byteLength>xt.MAGIC_COOKIE&&(this.extensionFlag[0]=K.getByteAt(i,540),this.extensionFlag[1]=K.getByteAt(i,541),this.extensionFlag[2]=K.getByteAt(i,542),this.extensionFlag[3]=K.getByteAt(i,543),this.extensionFlag[0]&&(this.extensions=K.getExtensionsAt(i,this.getExtensionLocation(),this.littleEndian,this.vox_offset),this.extensionSize=this.extensions[0].esize,this.extensionCode=this.extensions[0].ecode))}toFormattedString(){var e=K.formatNumber,i="";return i+="Datatype = "+ +this.datatypeCode+" ("+this.getDatatypeCodeString(this.datatypeCode)+`)
`,i+="Bits Per Voxel =  = "+this.numBitsPerVoxel+`
`,i+="Image Dimensions (1-8): "+this.dims[0]+", "+this.dims[1]+", "+this.dims[2]+", "+this.dims[3]+", "+this.dims[4]+", "+this.dims[5]+", "+this.dims[6]+", "+this.dims[7]+`
`,i+="Intent Parameters (1-3): "+this.intent_p1+", "+this.intent_p2+", "+this.intent_p3+`
`,i+="Voxel Dimensions (1-8): "+e(this.pixDims[0])+", "+e(this.pixDims[1])+", "+e(this.pixDims[2])+", "+e(this.pixDims[3])+", "+e(this.pixDims[4])+", "+e(this.pixDims[5])+", "+e(this.pixDims[6])+", "+e(this.pixDims[7])+`
`,i+="Image Offset = "+this.vox_offset+`
`,i+="Data Scale:  Slope = "+e(this.scl_slope)+"  Intercept = "+e(this.scl_inter)+`
`,i+="Display Range:  Max = "+e(this.cal_max)+"  Min = "+e(this.cal_min)+`
`,i+="Slice Duration = "+this.slice_duration+`
`,i+="Time Axis Shift = "+this.toffset+`
`,i+="Slice Start = "+this.slice_start+`
`,i+="Slice End = "+this.slice_end+`
`,i+='Description: "'+this.description+`"
`,i+='Auxiliary File: "'+this.aux_file+`"
`,i+="Q-Form Code = "+this.qform_code+" ("+this.getTransformCodeString(this.qform_code)+`)
`,i+="S-Form Code = "+this.sform_code+" ("+this.getTransformCodeString(this.sform_code)+`)
`,i+="Quaternion Parameters:  b = "+e(this.quatern_b)+"  c = "+e(this.quatern_c)+"  d = "+e(this.quatern_d)+`
`,i+="Quaternion Offsets:  x = "+this.qoffset_x+"  y = "+this.qoffset_y+"  z = "+this.qoffset_z+`
`,i+="S-Form Parameters X: "+e(this.affine[0][0])+", "+e(this.affine[0][1])+", "+e(this.affine[0][2])+", "+e(this.affine[0][3])+`
`,i+="S-Form Parameters Y: "+e(this.affine[1][0])+", "+e(this.affine[1][1])+", "+e(this.affine[1][2])+", "+e(this.affine[1][3])+`
`,i+="S-Form Parameters Z: "+e(this.affine[2][0])+", "+e(this.affine[2][1])+", "+e(this.affine[2][2])+", "+e(this.affine[2][3])+`
`,i+="Slice Code = "+this.slice_code+`
`,i+="Units Code = "+this.xyzt_units+" ("+this.getUnitsCodeString(ee.SPATIAL_UNITS_MASK&this.xyzt_units)+", "+this.getUnitsCodeString(ee.TEMPORAL_UNITS_MASK&this.xyzt_units)+`)
`,i+="Intent Code = "+this.intent_code+`
`,i+='Intent Name: "'+this.intent_name+`"
`,i+="Dim Info = "+this.dim_info+`
`,i}toArrayBuffer(e=!1){let r=544;if(e)for(let l of this.extensions)r+=l.esize;let n=new Uint8Array(r),a=new DataView(n.buffer);a.setInt32(0,540,this.littleEndian),n.set(new TextEncoder().encode(this.magic),4),a.setInt16(12,this.datatypeCode,this.littleEndian),a.setInt16(14,this.numBitsPerVoxel,this.littleEndian);for(let l=0;l<8;l++)a.setBigInt64(16+8*l,BigInt(this.dims[l]),this.littleEndian);a.setFloat64(80,this.intent_p1,this.littleEndian),a.setFloat64(88,this.intent_p2,this.littleEndian),a.setFloat64(96,this.intent_p3,this.littleEndian);for(let l=0;l<8;l++)a.setFloat64(104+8*l,this.pixDims[l],this.littleEndian);a.setBigInt64(168,BigInt(this.vox_offset),this.littleEndian),a.setFloat64(176,this.scl_slope,this.littleEndian),a.setFloat64(184,this.scl_inter,this.littleEndian),a.setFloat64(192,this.cal_max,this.littleEndian),a.setFloat64(200,this.cal_min,this.littleEndian),a.setFloat64(208,this.slice_duration,this.littleEndian),a.setFloat64(216,this.toffset,this.littleEndian),a.setBigInt64(224,BigInt(this.slice_start),this.littleEndian),a.setBigInt64(232,BigInt(this.slice_end),this.littleEndian),n.set(new TextEncoder().encode(this.description),240),n.set(new TextEncoder().encode(this.aux_file),320),a.setInt32(344,this.qform_code,this.littleEndian),a.setInt32(348,this.sform_code,this.littleEndian),a.setFloat64(352,this.quatern_b,this.littleEndian),a.setFloat64(360,this.quatern_c,this.littleEndian),a.setFloat64(368,this.quatern_d,this.littleEndian),a.setFloat64(376,this.qoffset_x,this.littleEndian),a.setFloat64(384,this.qoffset_y,this.littleEndian),a.setFloat64(392,this.qoffset_z,this.littleEndian);const o=this.affine.flat();for(let l=0;l<12;l++)a.setFloat64(400+8*l,o[l],this.littleEndian);if(a.setInt32(496,this.slice_code,this.littleEndian),a.setInt32(500,this.xyzt_units,this.littleEndian),a.setInt32(504,this.intent_code,this.littleEndian),n.set(new TextEncoder().encode(this.intent_name),508),a.setUint8(524,this.dim_info),e){n.set(Uint8Array.from([1,0,0,0]),540);let l=this.getExtensionLocation();for(const c of this.extensions)a.setInt32(l,c.esize,c.littleEndian),a.setInt32(l+4,c.ecode,c.littleEndian),n.set(new Uint8Array(c.edata),l+8),l+=c.esize}else n.set(new Uint8Array(4).fill(0),540);return n.buffer}};L(xt,"MAGIC_COOKIE",540),L(xt,"MAGIC_NUMBER_LOCATION",4),L(xt,"MAGIC_NUMBER",[110,43,50,0,13,10,26,10]),L(xt,"MAGIC_NUMBER2",[110,105,50,0,13,10,26,10]);let Ze=xt;function rh(t,e=!1){var i,s,r,n;return t.byteLength<ee.STANDARD_HEADER_SIZE?!1:(i=new DataView(t),i&&(s=i.getUint8(ee.MAGIC_NUMBER_LOCATION)),r=i.getUint8(ee.MAGIC_NUMBER_LOCATION+1),n=i.getUint8(ee.MAGIC_NUMBER_LOCATION+2),e&&s===ee.MAGIC_NUMBER2[0]&&r===ee.MAGIC_NUMBER2[1]&&n===ee.MAGIC_NUMBER2[2]?!0:s===ee.MAGIC_NUMBER[0]&&r===ee.MAGIC_NUMBER[1]&&n===ee.MAGIC_NUMBER[2])}function nh(t,e=!1){var i,s,r,n;return t.byteLength<ee.STANDARD_HEADER_SIZE?!1:(i=new DataView(t),s=i.getUint8(Ze.MAGIC_NUMBER_LOCATION),r=i.getUint8(Ze.MAGIC_NUMBER_LOCATION+1),n=i.getUint8(Ze.MAGIC_NUMBER_LOCATION+2),e&&s===Ze.MAGIC_NUMBER2[0]&&r===Ze.MAGIC_NUMBER2[1]&&n===Ze.MAGIC_NUMBER2[2]?!0:s===Ze.MAGIC_NUMBER[0]&&r===Ze.MAGIC_NUMBER[1]&&n===Ze.MAGIC_NUMBER[2])}function xn(t){var e,i,s;return!!(t&&(e=new DataView(t),i=e.getUint8(0),s=e.getUint8(1),i===K.GUNZIP_MAGIC_COOKIE1||s===K.GUNZIP_MAGIC_COOKIE2))}function ah(t){return th(new Uint8Array(t)).buffer}async function oh(t){const e=new Uint8Array(t),i=e[0]===31&&e[1]===139&&e[2]===8?"gzip":e[0]===120&&(e[1]===1||e[1]===94||e[1]===156||e[1]===218)?"deflate":"deflate-raw",s=new DecompressionStream(i),r=s.writable.getWriter();r.write(e).catch(console.error);const n=r.close().catch(console.error),o=await new Response(s.readable).arrayBuffer();return await n,o}async function aa(t,e=1/0){const i=u=>u[0]===31&&u[1]===139&&u[2]===8?"gzip":u[0]===120&&[1,94,156,218].includes(u[1])?"deflate":"deflate-raw",s=new Uint8Array(t),r=i(s),n=new DecompressionStream(r),a=new TransformStream({transform(u,m){m.enqueue(u)},flush(u){u.terminate()}}),{readable:o,writable:l}=n,c=l.getWriter(),h=o.pipeThrough(a).getReader();c.write(s).catch(u=>{u instanceof Error&&u.name==="AbortError"||console.error("Error during write:",u)});const d=[];let f=0;try{for(;f<e;){const{done:u,value:m}=await h.read();if(u)break;const g=e-f,p=m.subarray(0,Math.min(m.length,g));if(d.push(p),f+=p.length,f>=e){await Promise.all([h.cancel().catch(()=>{}),c.abort().catch(()=>{})]);break}}}catch(u){u instanceof Error&&u.name==="AbortError"||console.error("Error during decompression:",u)}finally{await Promise.allSettled([h.cancel().catch(()=>{}),c.close().catch(()=>{})])}return d.length===1?d[0].buffer:d.reduce((u,m)=>{const g=new Uint8Array(u.byteLength+m.byteLength);return g.set(new Uint8Array(u),0),g.set(m,u.byteLength),g.buffer},new ArrayBuffer(0))}function lh(t,e=!1){let i=null;if(xn(t)&&(t=ah(t)),rh(t,e)?i=new ee:nh(t,e)&&(i=new Ze),i)i.readHeader(t);else throw new Error("That file does not appear to be NIFTI!");return i}async function Ti(t,e=!1){if(!xn(t))return lh(t,e);let i=null,s=await aa(t,540),r=!0,n=!0;var a=new DataView(s);const o=a.getInt32(0,!0),l=a.getInt32(0,!1);if(o!==348)if(l===348)r=!1;else if(o===540)n=!1;else if(l===540)n=!1,r=!1;else throw new Error("That file does not appear to be NIFTI!");let c=Math.round(a.getFloat32(108,r));return Ze&&(c=K.getUint64At(a,168,r)),c>s.byteLength&&(s=await aa(t,c)),n?i=new ee:i=new Ze,i.readHeader(s),i}function ch(t,e){var i=t.vox_offset,s=1,r=1;t.dims[4]&&(s=t.dims[4]),t.dims[5]&&(r=t.dims[5]);var n=t.dims[1]*t.dims[2]*t.dims[3]*s*r*(t.numBitsPerVoxel/8);return e.slice(i,i+n)}class ss extends Error{constructor(e,i={}){super(`Node not found: ${e}`,i),this.name="NodeNotFoundError"}}class yn extends Error{constructor(e){super(`Missing key: ${e}`),this.name="KeyError"}}var st;class Go{constructor(e,i,s){Se(this,st);typeof e=="number"?xe(this,st,new Uint8Array(e)):e instanceof ArrayBuffer?xe(this,st,new Uint8Array(e,i,s)):xe(this,st,new Uint8Array(Array.from(e,r=>r?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return te(this,st).byteOffset}get byteLength(){return te(this,st).byteLength}get buffer(){return te(this,st).buffer}get length(){return te(this,st).length}get(e){let i=te(this,st)[e];return typeof i=="number"?i!==0:i}set(e,i){te(this,st)[e]=i?1:0}fill(e){te(this,st).fill(e?1:0)}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this.get(e)}}st=new WeakMap;var di;class vn{constructor(e,i,s,r){L(this,"_data");L(this,"chars");Se(this,di);if(this.chars=e,xe(this,di,new TextEncoder),typeof i=="number")this._data=new Uint8Array(i*e);else if(i instanceof ArrayBuffer)r&&(r=r*e),this._data=new Uint8Array(i,s,r);else{let n=Array.from(i);this._data=new Uint8Array(n.length*e);for(let a=0;a<n.length;a++)this.set(a,n[a])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(e){const i=new Uint8Array(this.buffer,this.byteOffset+this.chars*e,this.chars);return new TextDecoder().decode(i).replace(/\x00/g,"")}set(e,i){const s=new Uint8Array(this.buffer,this.byteOffset+this.chars*e,this.chars);s.fill(0),s.set(te(this,di).encode(i))}fill(e){const i=te(this,di).encode(e);for(let s=0;s<this.length;s++)this._data.set(i,s*this.chars)}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this.get(e)}}di=new WeakMap;var Ye;const Hn=class Hn{constructor(e,i,s,r){Se(this,Ye);L(this,"chars");if(this.chars=e,typeof i=="number")xe(this,Ye,new Int32Array(i*e));else if(i instanceof ArrayBuffer)r&&(r*=e),xe(this,Ye,new Int32Array(i,s,r));else{const n=i,a=new Hn(e,1);xe(this,Ye,new Int32Array(function*(){for(let o of n)a.set(0,o),yield*te(a,Ye)}()))}}get BYTES_PER_ELEMENT(){return te(this,Ye).BYTES_PER_ELEMENT*this.chars}get byteLength(){return te(this,Ye).byteLength}get byteOffset(){return te(this,Ye).byteOffset}get buffer(){return te(this,Ye).buffer}get length(){return te(this,Ye).length/this.chars}get(e){const i=this.chars*e;let s="";for(let r=0;r<this.chars;r++)s+=String.fromCodePoint(te(this,Ye)[i+r]);return s.replace(/\u0000/g,"")}set(e,i){const s=this.chars*e,r=te(this,Ye).subarray(s,s+this.chars);r.fill(0);for(let n=0;n<this.chars;n++)r[n]=i.codePointAt(n)??0}fill(e){this.set(0,e);let i=te(this,Ye).subarray(0,this.chars);for(let s=1;s<this.length;s++)te(this,Ye).set(i,s*this.chars)}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this.get(e)}};Ye=new WeakMap;let Oi=Hn;const hh="modulepreload",fh=function(t,e){return new URL(t,e).href},oa={},wr=function(e,i,s){let r=Promise.resolve();if(i&&i.length>0){const a=document.getElementsByTagName("link"),o=document.querySelector("meta[property=csp-nonce]"),l=(o==null?void 0:o.nonce)||(o==null?void 0:o.getAttribute("nonce"));r=Promise.allSettled(i.map(c=>{if(c=fh(c,s),c in oa)return;oa[c]=!0;const h=c.endsWith(".css"),d=h?'[rel="stylesheet"]':"";if(!!s)for(let m=a.length-1;m>=0;m--){const g=a[m];if(g.href===c&&(!h||g.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${c}"]${d}`))return;const u=document.createElement("link");if(u.rel=h?"stylesheet":hh,h||(u.as="script"),u.crossOrigin="",u.href=c,l&&u.setAttribute("nonce",l),document.head.appendChild(u),h)return new Promise((m,g)=>{u.addEventListener("load",m),u.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${c}`)))})}))}function n(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return r.then(a=>{for(const o of a||[])o.status==="rejected"&&n(o.reason);return e().catch(n)})};function rs(t){const e=new TextDecoder().decode(t);return JSON.parse(e)}function la(t,e){const i=e/2,s=e-1;let r=0;for(let n=0;n<t.length;n+=e)for(let a=0;a<i;a+=1)r=t[n+a],t[n+a]=t[n+s-a],t[n+s-a]=r}function Yo(t){if(t==="v2:object")return globalThis.Array;let e=t.match(/v2:([US])(\d+)/);if(e){let[,s,r]=e;return(s==="U"?Oi:vn).bind(null,Number(r))}let i={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float16:globalThis.Float16Array,float32:Float32Array,float64:Float64Array,bool:Go}[t];return Fe(i,`Unknown or unsupported data_type: ${t}`),i}function Xt(t,e){const i=t.length;typeof e=="string"&&(e=e==="C"?Array.from({length:i},(n,a)=>a):Array.from({length:i},(n,a)=>i-1-a)),Fe(i===e.length,"Order length must match the number of dimensions.");let s=1,r=new Array(i);for(let n=e.length-1;n>=0;n--)r[e[n]]=s,s*=t[e[n]];return r}function dh({name:t,configuration:e}){if(t==="default"){const i=(e==null?void 0:e.separator)??"/";return s=>["c",...s].join(i)}if(t==="v2"){const i=(e==null?void 0:e.separator)??".";return s=>s.join(i)||"0"}throw new Error(`Unknown chunk key encoding: ${t}`)}function uh(t){if(t==="|O")return{data_type:"v2:object"};let e=t.match(/^([<|>])(.*)$/);Fe(e,`Invalid dtype: ${t}`);let[,i,s]=e,r={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f2:"float16",f4:"float32",f8:"float64"}[s]??(s.startsWith("S")||s.startsWith("U")?`v2:${s}`:void 0);return Fe(r,`Unsupported or unknown dtype: ${t}`),i==="|"?{data_type:r}:{data_type:r,endian:i==="<"?"little":"big"}}function mh(t,e={}){let i=[],s=uh(t.dtype);t.order==="F"&&i.push({name:"transpose",configuration:{order:"F"}}),"endian"in s&&s.endian==="big"&&i.push({name:"bytes",configuration:{endian:"big"}});for(let{id:r,...n}of t.filters??[])i.push({name:r,configuration:n});if(t.compressor){let{id:r,...n}=t.compressor;i.push({name:r,configuration:n})}return{zarr_format:3,node_type:"array",shape:t.shape,data_type:s.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:t.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:t.dimension_separator??"."}},codecs:i,fill_value:t.fill_value,attributes:e}}function gh(t,e={}){return{zarr_format:3,node_type:"group",attributes:e}}function ph(t,e){if(e!=="number"&&e!=="bigint"&&e!=="boolean"&&e!=="object"&&e!=="string")return t===e;let i=t==="bool";if(e==="boolean")return i;let s=t.startsWith("v2:U")||t.startsWith("v2:S");if(e==="string")return s;let r=t==="int64"||t==="uint64";if(e==="bigint")return r;let n=t==="v2:object";return e==="object"?n:!s&&!r&&!i&&!n}function Ah(t){return(t==null?void 0:t.name)==="sharding_indexed"}function Wo(t){return(t.data_type==="uint64"||t.data_type==="int64")&&t.fill_value!=null?BigInt(t.fill_value):t.fill_value}function Ko(t,...e){if(!e.some(i=>t instanceof i))throw t}function Fe(t,e=""){if(!t)throw new Error(e)}async function jo(t,{format:e,signal:i}){const s=t instanceof Response?t:new Response(t);Fe(s.body,"Response does not contain body.");try{return await new Response(s.body.pipeThrough(new DecompressionStream(e),{signal:i})).arrayBuffer()}catch{throw i==null||i.throwIfAborted(),new Error(`Failed to decode ${e}`)}}class bn{constructor(e,i){L(this,"kind","array_to_array");Fe(e.keepbits>=0,"keepbits must be zero or positive")}static fromConfig(e,i){return new bn(e,i)}encode(e){throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.")}decode(e){return e}}const ca=wh();function wh(){const t=new Uint32Array([305419896]);return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)[0]!==18}function ha(t){return"BYTES_PER_ELEMENT"in t?t.BYTES_PER_ELEMENT:4}var Ki,Nt,ji,Hi,ui;const qn=class qn{constructor(e,i){L(this,"kind","array_to_bytes");Se(this,Ki);Se(this,Nt);Se(this,ji);Se(this,Hi);Se(this,ui);xe(this,ui,e==null?void 0:e.endian),xe(this,Nt,Yo(i.data_type)),xe(this,Hi,i.shape),xe(this,Ki,Xt(i.shape,"C"));const s=new(te(this,Nt))(0);xe(this,ji,s.BYTES_PER_ELEMENT)}static fromConfig(e,i){return new qn(e,i)}encode(e){let i=new Uint8Array(e.data.buffer);return ca&&te(this,ui)==="big"&&la(i,ha(te(this,Nt))),i}decode(e){return ca&&te(this,ui)==="big"&&la(e,ha(te(this,Nt))),{data:new(te(this,Nt))(e.buffer,e.byteOffset,e.byteLength/te(this,ji)),shape:te(this,Hi),stride:te(this,Ki)}}};Ki=new WeakMap,Nt=new WeakMap,ji=new WeakMap,Hi=new WeakMap,ui=new WeakMap;let zs=qn;class Cn{constructor(){L(this,"kind","bytes_to_bytes")}static fromConfig(){return new Cn}encode(e){throw new Error("Not implemented")}decode(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength-4)}}class Sn{constructor(){L(this,"kind","bytes_to_bytes")}static fromConfig(e){return new Sn}encode(e){throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.")}async decode(e){const i=await jo(e,{format:"gzip"});return new Uint8Array(i)}}function xh(t,e){return Fe(!Number.isNaN(e),"JsonCodec allow_nan is false but NaN was encountered during encoding."),Fe(e!==Number.POSITIVE_INFINITY,"JsonCodec allow_nan is false but Infinity was encountered during encoding."),Fe(e!==Number.NEGATIVE_INFINITY,"JsonCodec allow_nan is false but -Infinity was encountered during encoding."),e}function yh(t,e){return e instanceof Object&&!Array.isArray(e)?Object.keys(e).sort().reduce((i,s)=>(i[s]=e[s],i),{}):e}var qi,Qi;const Qn=class Qn{constructor(e={}){L(this,"configuration");L(this,"kind","array_to_bytes");Se(this,qi);Se(this,Qi);this.configuration=e;const{encoding:i="utf-8",skipkeys:s=!1,ensure_ascii:r=!0,check_circular:n=!0,allow_nan:a=!0,sort_keys:o=!0,indent:l,strict:c=!0}=e;let h=e.separators;h||(l?h=[", ",": "]:h=[",",":"]),xe(this,qi,{encoding:i,skipkeys:s,ensure_ascii:r,check_circular:n,allow_nan:a,indent:l,separators:h,sort_keys:o}),xe(this,Qi,{strict:c})}static fromConfig(e){return new Qn(e)}encode(e){const{indent:i,encoding:s,ensure_ascii:r,check_circular:n,allow_nan:a,sort_keys:o}=te(this,qi);Fe(s==="utf-8","JsonCodec does not yet support non-utf-8 encoding.");const l=[];Fe(n,"JsonCodec does not yet support skipping the check for circular references during encoding."),a||l.push(xh),o&&l.push(yh);const c=Array.from(e.data);c.push("|O"),c.push(e.shape);let h;l.length&&(h=(f,u)=>{let m=u;for(let g of l)m=g(f,m);return m});let d=JSON.stringify(c,h,i);return r&&(d=d.replace(/[\u007F-\uFFFF]/g,f=>{const u=`0000${f.charCodeAt(0).toString(16)}`;return`\\u${u.substring(u.length-4)}`})),new TextEncoder().encode(d)}decode(e){const{strict:i}=te(this,Qi);Fe(i,"JsonCodec does not yet support non-strict decoding.");const s=rs(e),r=s.pop();s.pop(),Fe(r,"0D not implemented for JsonCodec.");const n=Xt(r,"C");return{data:s,shape:r,stride:n}}};qi=new WeakMap,Qi=new WeakMap;let Yr=Qn;function fa(t){return t instanceof Go||t instanceof vn||t instanceof Oi?new Proxy(t,{get(i,s){return i.get(Number(s))},set(i,s,r){return i.set(Number(s),r),!0}}):t}function vh(t,e){let i;return t.data instanceof vn||t.data instanceof Oi?i=new t.constructor(t.data.length,t.data.chars):i=new t.constructor(t.data.length),{data:i,shape:t.shape,stride:Xt(t.shape,e)}}function bh(t,e){let i=vh(t,e),s=t.shape.length,r=t.data.length,n=Array(s).fill(0),a=fa(t.data),o=fa(i.data);for(let l=0;l<r;l++){let c=0;for(let h=0;h<s;h++)c+=n[h]*i.stride[h];o[c]=a[l],n[0]+=1;for(let h=0;h<s;h++)if(n[h]===t.shape[h]){if(h+1===s)break;n[h]=0,n[h+1]+=1}}return i}function Ch(t){let e=t.shape.length;return Fe(e===t.stride.length,"Shape and stride must have the same length."),t.stride.map((i,s)=>({stride:i,index:s})).sort((i,s)=>s.stride-i.stride).map(i=>i.index)}function Sh(t,e){let i=Ch(t);return Fe(i.length===e.length,"Orders must match"),i.every((s,r)=>s===e[r])}var Xi,mi;const Xn=class Xn{constructor(e,i){L(this,"kind","array_to_array");Se(this,Xi);Se(this,mi);let s=e.order??"C",r=i.shape.length,n=new Array(r),a=new Array(r);if(s==="C")for(let o=0;o<r;++o)n[o]=o,a[o]=o;else if(s==="F")for(let o=0;o<r;++o)n[o]=r-o-1,a[o]=r-o-1;else n=s,n.forEach((o,l)=>{Fe(a[o]===void 0,`Invalid permutation: ${JSON.stringify(s)}`),a[o]=l});xe(this,Xi,n),xe(this,mi,a)}static fromConfig(e,i){return new Xn(e,i)}encode(e){return Sh(e,te(this,mi))?e:bh(e,te(this,mi))}decode(e){return{data:e.data,shape:e.shape,stride:Xt(e.shape,te(this,Xi))}}};Xi=new WeakMap,mi=new WeakMap;let Wr=Xn;var Zi,Ji;const Zn=class Zn{constructor(e){L(this,"kind","array_to_bytes");Se(this,Zi);Se(this,Ji);xe(this,Zi,e),xe(this,Ji,Xt(e,"C"))}static fromConfig(e,i){return new Zn(i.shape)}encode(e){throw new Error("Method not implemented.")}decode(e){let i=new TextDecoder,s=new DataView(e.buffer),r=Array(s.getUint32(0,!0)),n=4;for(let a=0;a<r.length;a++){let o=s.getUint32(n,!0);n+=4,r[a]=i.decode(e.buffer.slice(n,n+o)),n+=o}return{data:r,shape:te(this,Zi),stride:te(this,Ji)}}};Zi=new WeakMap,Ji=new WeakMap;let Kr=Zn;class En{constructor(){L(this,"kind","bytes_to_bytes")}static fromConfig(e){return new En}encode(e){throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.")}async decode(e){const i=await jo(e,{format:"deflate"});return new Uint8Array(i)}}function Eh(){return new Map().set("blosc",()=>wr(()=>import("./blosc-E49GQuAK.js"),__vite__mapDeps([0,1]),import.meta.url).then(t=>t.default)).set("lz4",()=>wr(()=>import("./lz4-BIGKWw27.js"),__vite__mapDeps([2,1]),import.meta.url).then(t=>t.default)).set("zstd",()=>wr(()=>import("./zstd-IvP746pw.js"),__vite__mapDeps([3,1]),import.meta.url).then(t=>t.default)).set("gzip",()=>Sn).set("zlib",()=>En).set("transpose",()=>Wr).set("bytes",()=>zs).set("crc32c",()=>Cn).set("vlen-utf8",()=>Kr).set("json2",()=>Yr).set("bitround",()=>bn)}const Dh=Eh();function jr(t){let e;return{async encode(i){e||(e=await da(t));for(const r of e.array_to_array)i=await r.encode(i);let s=await e.array_to_bytes.encode(i);for(const r of e.bytes_to_bytes)s=await r.encode(s);return s},async decode(i){e||(e=await da(t));for(let r=e.bytes_to_bytes.length-1;r>=0;r--)i=await e.bytes_to_bytes[r].decode(i);let s=await e.array_to_bytes.decode(i);for(let r=e.array_to_array.length-1;r>=0;r--)s=await e.array_to_array[r].decode(s);return s}}}async function da(t){let e=t.codecs.map(async n=>{var o;let a=await((o=Dh.get(n.name))==null?void 0:o());return Fe(a,`Unknown codec: ${n.name}`),{Codec:a,meta:n}}),i=[],s,r=[];for await(let{Codec:n,meta:a}of e){let o=n.fromConfig(a.configuration,t);switch(o.kind){case"array_to_array":i.push(o);break;case"array_to_bytes":s=o;break;default:r.push(o)}}return s||(Fe(Th(t),`Cannot encode ${t.data_type} to bytes without a codec`),s=zs.fromConfig({endian:"little"},t)),{array_to_array:i,array_to_bytes:s,bytes_to_bytes:r}}function Th(t){return t.data_type!=="v2:object"}const ua=18446744073709551615n;function Mh(t,e,i,s){Fe(t.store.getRange,"Store does not support range requests");let r=t.store.getRange.bind(t.store),n=e.map((l,c)=>l/s.chunk_shape[c]),a=jr({data_type:"uint64",shape:[...n,2],codecs:s.index_codecs}),o={};return async l=>{let c=l.map((w,x)=>Math.floor(w/n[x])),h=t.resolve(i(c)).path,d;if(h in o)d=o[h];else{let w=4,x=16*n.reduce((v,D)=>v*D,1),y=await r(h,{suffixLength:x+w});d=o[h]=y?await a.decode(y):null}if(d===null)return;let{data:f,shape:u,stride:m}=d,g=l.map((w,x)=>w%u[x]).reduce((w,x,y)=>w+x*m[y],0),p=f[g],A=f[g+1];if(!(p===ua&&A===ua))return r(h,{offset:Number(p),length:Number(A)})}}class $t{constructor(e,i="/"){L(this,"store");L(this,"path");this.store=e,this.path=i}resolve(e){let i=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new $t(this.store,new URL(e,i).pathname)}}function Ih(t){return new $t(t??new Map)}var _i;class Dn extends $t{constructor(i,s,r){super(i,s);L(this,"kind","group");Se(this,_i);xe(this,_i,r)}get attrs(){return te(this,_i).attributes}}_i=new WeakMap;function ma(t){var i;const e=t.find(s=>s.name==="transpose");return((i=e==null?void 0:e.configuration)==null?void 0:i.order)??"C"}const Mi=Symbol("zarrita.context");function Fh(t){return t[Mi]}function Bh(t,e){let{configuration:i}=e.codecs.find(Ah)??{},s={encode_chunk_key:dh(e.chunk_key_encoding),TypedArray:Yo(e.data_type),fill_value:e.fill_value};if(i){let n=ma(i.codecs);return{...s,kind:"sharded",chunk_shape:i.chunk_shape,codec:jr({data_type:e.data_type,shape:i.chunk_shape,codecs:i.codecs}),get_strides(a){return Xt(a,n)},get_chunk_bytes:Mh(t,e.chunk_grid.configuration.chunk_shape,s.encode_chunk_key,i)}}let r=ma(e.codecs);return{...s,kind:"regular",chunk_shape:e.chunk_grid.configuration.chunk_shape,codec:jr({data_type:e.data_type,shape:e.chunk_grid.configuration.chunk_shape,codecs:e.codecs}),get_strides(n){return Xt(n,r)},async get_chunk_bytes(n,a){let o=s.encode_chunk_key(n),l=t.resolve(o).path;return t.store.get(l,a)}}}var Co,So,jt,Eo;let Gs=(Eo=class extends(So=$t,Co=Mi,So){constructor(i,s,r){super(i,s);L(this,"kind","array");Se(this,jt);L(this,Co);xe(this,jt,{...r,fill_value:Wo(r)}),this[Mi]=Bh(this,r)}get attrs(){return te(this,jt).attributes}get shape(){return te(this,jt).shape}get chunks(){return this[Mi].chunk_shape}get dtype(){return te(this,jt).data_type}async getChunk(i,s){let r=this[Mi],n=await r.get_chunk_bytes(i,s);if(!n){let a=r.chunk_shape.reduce((l,c)=>l*c,1),o=new r.TypedArray(a);return o.fill(r.fill_value),{data:o,shape:r.chunk_shape,stride:r.get_strides(r.chunk_shape)}}return r.codec.decode(n)}is(i){return ph(this.dtype,i)}},jt=new WeakMap,Eo),er=Uh();function Uh(){let t=new WeakMap;function e(i){let s=t.get(i)??{v2:0,v3:0};return t.set(i,s),s}return{increment(i,s){e(i)[s]+=1},version_max(i){let s=e(i);return s.v3>s.v2?"v3":"v2"}}}async function Ph(t){let e=await t.store.get(t.resolve(".zattrs").path);return e?rs(e):{}}async function Vh(t,e={}){let i="store"in t?t:new $t(t),s={};return(e.attrs??!0)&&(s=await Ph(i)),e.kind==="array"?ga(i,s):e.kind==="group"?pa(i,s):ga(i,s).catch(r=>(Ko(r,ss),pa(i,s)))}async function ga(t,e){let{path:i}=t.resolve(".zarray"),s=await t.store.get(i);if(!s)throw new ss("v2 array",{cause:new yn(i)});return er.increment(t.store,"v2"),new Gs(t.store,t.path,mh(rs(s),e))}async function pa(t,e){let{path:i}=t.resolve(".zgroup"),s=await t.store.get(i);if(!s)throw new ss("v2 group",{cause:new yn(i)});return er.increment(t.store,"v2"),new Dn(t.store,t.path,gh(rs(s),e))}async function Rh(t){let{store:e,path:i}=t.resolve("zarr.json"),s=await t.store.get(i);if(!s)throw new ss("v3 array or group",{cause:new yn(i)});let r=rs(s);return r.node_type==="array"&&(r.fill_value=Wo(r)),r.node_type==="array"?new Gs(e,t.path,r):new Dn(e,t.path,r)}async function Nh(t,e={}){let i="store"in t?t:new $t(t),s=await Rh(i);if(er.increment(i.store,"v3"),e.kind===void 0||e.kind==="array"&&s instanceof Gs||e.kind==="group"&&s instanceof Dn)return s;let r=s instanceof Gs?"array":"group";throw new Error(`Expected node of kind ${e.kind}, found ${r}.`)}async function kt(t,e={}){let i="store"in t?t.store:t,s=er.version_max(i),r=s==="v2"?kt.v2:kt.v3,n=s==="v2"?kt.v3:kt.v2;return r(t,e).catch(a=>(Ko(a,ss),n(t,e)))}kt.v2=Vh;kt.v3=Nh;function*kh(t,e,i=1){e===void 0&&(e=t,t=0);for(let s=t;s<e;s+=i)yield s}function*Lh(...t){if(t.length===0)return;const e=t.map(s=>s[Symbol.iterator]()),i=e.map(s=>s.next());if(i.some(s=>s.done))throw new Error("Input contains an empty iterator.");for(let s=0;;){if(i[s].done){if(e[s]=t[s][Symbol.iterator](),i[s]=e[s].next(),++s>=e.length)return}else yield i.map(({value:r})=>r),s=0;i[s]=e[s].next()}}function Oh({start:t,stop:e,step:i},s){if(i===0)throw new Error("slice step cannot be zero");i=i??1;const r=i<0,[n,a]=r?[-1,s-1]:[0,s];return t===null?t=r?a:n:t<0?(t+=s,t<n&&(t=n)):t>a&&(t=a),e===null?e=r?n:a:e<0?(e+=s,e<n&&(e=n)):e>a&&(e=a),[t,e,i]}function ki(t,e,i=null){return e===void 0&&(e=t,t=null),{start:t,stop:e,step:i}}function zh(){const t=[];return{add:e=>t.push(e()),onIdle:()=>Promise.all(t)}}class Tn extends Error{constructor(e){super(e),this.name="IndexError"}}function Gh(t,e){throw new Tn(`too many indicies for array; expected ${e.length}, got ${t.length}`)}function Yh(t){throw new Tn(`index out of bounds for dimension with length ${t}`)}function Wh(){throw new Tn("only slices with step >= 1 are supported")}function Kh(t,e){t.length>e.length&&Gh(t,e)}function jh(t,e){return t=Math.trunc(t),t<0&&(t=e+t),(t>=e||t<0)&&Yh(e),t}class Hh{constructor({dim_sel:e,dim_len:i,dim_chunk_len:s}){L(this,"dim_sel");L(this,"dim_len");L(this,"dim_chunk_len");L(this,"nitems");e=jh(e,i),this.dim_sel=e,this.dim_len=i,this.dim_chunk_len=s,this.nitems=1}*[Symbol.iterator](){const e=Math.floor(this.dim_sel/this.dim_chunk_len),i=e*this.dim_chunk_len,s=this.dim_sel-i;yield{dim_chunk_ix:e,dim_chunk_sel:s}}}class Aa{constructor({dim_sel:e,dim_len:i,dim_chunk_len:s}){L(this,"start");L(this,"stop");L(this,"step");L(this,"dim_len");L(this,"dim_chunk_len");L(this,"nitems");L(this,"nchunks");const[r,n,a]=Oh(e,i);this.start=r,this.stop=n,this.step=a,this.step<1&&Wh(),this.dim_len=i,this.dim_chunk_len=s,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const e=Math.floor(this.start/this.dim_chunk_len),i=Math.ceil(this.stop/this.dim_chunk_len);for(const s of kh(e,i)){const r=s*this.dim_chunk_len,n=Math.min(this.dim_len,(s+1)*this.dim_chunk_len),a=n-r;let o=0,l=0;if(this.start<r){const u=(r-this.start)%this.step;u&&(l+=this.step-u),o=Math.ceil((r-this.start)/this.step)}else l=this.start-r;const c=this.stop>n?a:this.stop-r,h=[l,c,this.step],d=Math.ceil((c-l)/this.step),f=[o,o+d,1];yield{dim_chunk_ix:s,dim_chunk_sel:h,dim_out_sel:f}}}}function qh(t,e){let i=[];return t===null?i=e.map(s=>ki(null)):Array.isArray(t)&&(i=t.map(s=>s??ki(null))),Kh(i,e),i}class Qh{constructor({selection:e,shape:i,chunk_shape:s}){L(this,"dim_indexers");L(this,"shape");this.dim_indexers=qh(e,i).map((r,n)=>new(typeof r=="number"?Hh:Aa)({dim_sel:r,dim_len:i[n],dim_chunk_len:s[n]})),this.shape=this.dim_indexers.filter(r=>r instanceof Aa).map(r=>r.nitems)}*[Symbol.iterator](){for(const e of Lh(...this.dim_indexers)){const i=e.map(r=>r.dim_chunk_ix),s=e.map(r=>"dim_out_sel"in r?{from:r.dim_chunk_sel,to:r.dim_out_sel}:{from:r.dim_chunk_sel,to:null});yield{chunk_coords:i,mapping:s}}}}function Xh(t,e){return"get"in t?t.get(e):t[e]}async function Zh(t,e,i,s){var l;let r=Fh(t),n=new Qh({selection:e,shape:t.shape,chunk_shape:t.chunks}),a=s.prepare(new r.TypedArray(n.shape.reduce((c,h)=>c*h,1)),n.shape,r.get_strides(n.shape)),o=((l=i.create_queue)==null?void 0:l.call(i))??zh();for(const{chunk_coords:c,mapping:h}of n)o.add(async()=>{let{data:d,shape:f,stride:u}=await t.getChunk(c,i.opts),m=s.prepare(d,f,u);s.set_from_chunk(a,m,h)});return await o.onIdle(),n.shape.length===0?Xh(a.data,0):a}function Mn(t,e=0,i){let s=i??t.length-e;return{length:s,subarray(r,n=s){return Mn(t,e+r,n-r)},set(r,n=0){for(let a=0;a<r.length;a++)t[e+n+a]=r.get(a)},get(r){return t[e+r]}}}function xr(t){return globalThis.Array.isArray(t.data)?{data:Mn(t.data),stride:t.stride,bytes_per_element:1}:{data:new Uint8Array(t.data.buffer,t.data.byteOffset,t.data.byteLength),stride:t.stride,bytes_per_element:t.data.BYTES_PER_ELEMENT}}function Jh(t){return"chars"in t?t.constructor.bind(null,t.chars):t.constructor}function _h(t,e){if(globalThis.Array.isArray(t.data))return Mn([e]);let i=Jh(t.data),s=new i([e]);return new Uint8Array(s.buffer,s.byteOffset,s.byteLength)}const $h={prepare(t,e,i){return{data:t,shape:e,stride:i}},set_scalar(t,e,i){let s=xr(t);Hr(s,e,_h(t,i),s.bytes_per_element)},set_from_chunk(t,e,i){let s=xr(t);Es(s,xr(e),s.bytes_per_element,i)}};async function wa(t,e=null,i={}){return Zh(t,e,i,$h)}function Ho(t,e,i){return i<0&&e<t?Math.floor((t-e-1)/-i)+1:t<e?Math.floor((e-t-1)/i)+1:0}function Hr(t,e,i,s){if(e.length===0){t.data.set(i,0);return}const[r,...n]=e,[a,...o]=t.stride;if(typeof r=="number"){const f=t.data.subarray(a*r*s);Hr({data:f,stride:o},n,i,s);return}const[l,c,h]=r,d=Ho(l,c,h);if(n.length===0){for(let f=0;f<d;f++)t.data.set(i,a*(l+h*f)*s);return}for(let f=0;f<d;f++){const u=t.data.subarray(a*(l+h*f)*s);Hr({data:u,stride:o},n,i,s)}}function Es(t,e,i,s){const[r,...n]=s,[a,...o]=t.stride,[l,...c]=e.stride;if(r.from===null){if(n.length===0){t.data.set(e.data.subarray(0,i),r.to*i);return}Es({data:t.data.subarray(a*r.to*i),stride:o},e,i,n);return}if(r.to===null){if(n.length===0){let A=r.from*i;t.data.set(e.data.subarray(A,A+i),0);return}Es(t,{data:e.data.subarray(l*r.from*i),stride:c},i,n);return}const[h,d,f]=r.to,[u,m,g]=r.from,p=Ho(h,d,f);if(n.length===0){if(f===1&&g===1&&a===1&&l===1){let A=u*i,w=p*i;t.data.set(e.data.subarray(A,A+w),h*i);return}for(let A=0;A<p;A++){let w=l*(u+g*A)*i;t.data.set(e.data.subarray(w,w+i),a*(h+f*A)*i)}return}for(let A=0;A<p;A++)Es({data:t.data.subarray(a*(h+A*f)*i),stride:o},{data:e.data.subarray(l*(u+A*g)*i),stride:c},i,n)}function qo(t,e,i,s={}){return e!==void 0&&i!==void 0&&(s={...s,headers:{...s.headers,Range:`bytes=${e}-${e+i-1}`}}),fetch(t,s)}function e0(t,e){return{...t,...e,headers:{...t.headers,...e.headers}}}function xa(t,e){const i=typeof t=="string"?new URL(t):t;i.pathname.endsWith("/")||(i.pathname+="/");const s=new URL(e.slice(1),i);return s.search=i.search,s}async function ya(t){if(t.status!==404){if(t.status===200||t.status===206)return new Uint8Array(await t.arrayBuffer());throw new Error(`Unexpected response status ${t.status} ${t.statusText}`)}}async function t0(t,e,i,s){if(s)return fetch(t,{...i,headers:{...i.headers,Range:`bytes=-${e}`}});let r=await fetch(t,{...i,method:"HEAD"});if(!r.ok)return r;let n=r.headers.get("Content-Length"),a=Number(n);return qo(t,a-e,a,i)}var $i,es,ts,qr;class i0{constructor(e,i={}){Se(this,ts);L(this,"url");Se(this,$i);Se(this,es);this.url=e,xe(this,$i,i.overrides??{}),xe(this,es,i.useSuffixRequest??!1)}async get(e,i={}){let s=xa(this.url,e).href,r=await fetch(s,ur(this,ts,qr).call(this,i));return ya(r)}async getRange(e,i,s={}){let r=xa(this.url,e),n=ur(this,ts,qr).call(this,s),a;return"suffixLength"in i?a=await t0(r,i.suffixLength,n,te(this,es)):a=await qo(r,i.offset,i.length,n),ya(a)}}$i=new WeakMap,es=new WeakMap,ts=new WeakSet,qr=function(e){return e0(te(this,$i),e)};var Qo=Object.defineProperty,Xo=t=>{throw TypeError(t)},s0=(t,e,i)=>e in t?Qo(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,tr=(t,e)=>{for(var i in e)Qo(t,i,{get:e[i],enumerable:!0})},F=(t,e,i)=>s0(t,typeof e!="symbol"?e+"":e,i),Zo=(t,e,i)=>e.has(t)||Xo("Cannot "+i),J=(t,e,i)=>(Zo(t,e,"read from private field"),i?i.call(t):e.get(t)),xi=(t,e,i)=>e.has(t)?Xo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),ti=(t,e,i,s)=>(Zo(t,e,"write to private field"),e.set(t,i),i),va="0.58.0",Jo=class mt{constructor({name:e="niivue",level:i="info"}={}){F(this,"level"),F(this,"name"),this.name=`${e}`,this.level=i}debug(...e){mt.levels[this.level]>mt.levels.debug||console.debug(`${this.name}-debug`,...e)}info(...e){mt.levels[this.level]>mt.levels.info||console.info(`${this.name}-info`,...e)}warn(...e){mt.levels[this.level]>mt.levels.warn||console.warn(`${this.name}-warn`,...e)}error(...e){mt.levels[this.level]>mt.levels.error||console.error(`${this.name}-error`,...e)}fatal(...e){mt.levels[this.level]>mt.levels.fatal||console.error(`${this.name}-fatal`,...e)}setLogLevel(e){this.level=e}setName(e){this.name=e}};F(Jo,"levels",{debug:0,info:1,warn:2,error:3,fatal:4,silent:1/0});var r0=Jo,U=new r0({name:"niivue",level:"info"}),n0=function(t,e,i){const s=t.createShader(t.VERTEX_SHADER);t.shaderSource(s,e),t.compileShader(s);const r=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(r,i),t.compileShader(r);const n=t.createProgram();if(t.attachShader(n,s),t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log("Vertex shader compilation error:",t.getShaderInfoLog(s)),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log("Fragment shader compilation error:",t.getShaderInfoLog(r)),U.error(t.getProgramInfoLog(n)),new Error("Shader failed to link, see console for log");return n},ne=class{constructor(t,e,i){F(this,"program"),F(this,"uniforms",{}),F(this,"isMatcap"),this.program=n0(t,e,i);const s=/uniform[^;]+[ ](\w+);/g,r=/uniform[^;]+[ ](\w+);/,n=e.match(s),a=i.match(s);n&&n.forEach(o=>{const l=o.match(r);this.uniforms[l[1]]=-1}),a&&a.forEach(o=>{const l=o.match(r);this.uniforms[l[1]]=-1});for(const o in this.uniforms)this.uniforms[o]=t.getUniformLocation(this.program,o)}use(t){t.useProgram(this.program)}},yi=`#version 300 es
#line 4
layout(location=0) in vec3 pos;
layout(location=1) in vec3 texCoords;
uniform mat4 mvpMtx;
out vec3 vColor;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vColor = texCoords;
}`,In=`
	vec4 drawColor(float scalar, float drawOpacity) {
		float nlayer = float(textureSize(colormap, 0).y);
		float layer = (nlayer - 0.5) / nlayer;
		vec4 dcolor = texture(colormap, vec2((scalar * 255.0)/256.0 + 0.5/256.0, layer)).rgba;
		dcolor.a *= drawOpacity;
		return dcolor;
}`,ns=`vec3 GetBackPosition(vec3 startPositionTex) {
	vec3 startPosition = startPositionTex * volScale;
	vec3 invR = 1.0 / rayDir;
	vec3 tbot = invR * (vec3(0.0)-startPosition);
	vec3 ttop = invR * (volScale-startPosition);
	vec3 tmax = max(ttop, tbot);
	vec2 t = min(tmax.xx, tmax.yz);
	vec3 endPosition = startPosition + (rayDir * min(t.x, t.y));
	//convert world position back to texture position:
	endPosition = endPosition / volScale;
	return endPosition;
}

vec4 applyClip (vec3 dir, inout vec4 samplePos, inout float len, inout bool isClip) {
	float cdot = dot(dir,clipPlane.xyz);
	isClip = false;
	if  ((clipPlane.a > 1.0) || (cdot == 0.0)) return samplePos;
	bool frontface = (cdot > 0.0);
	float dis = (-clipPlane.a - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	float thick = clipThick;
	if (thick <= 0.0) thick = 2.0;
	float  disBackFace = (-(clipPlane.a-thick) - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	if (((frontface) && (dis >= len)) || ((!frontface) && (dis <= 0.0))) {
		samplePos.a = len + 1.0;
		return samplePos;
	}
	if (frontface) {
		dis = max(0.0, dis);
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		if (dis > 0.0) isClip = true;
		len = min(disBackFace, len);
	}
	if (!frontface) {
		len = min(dis, len);
		disBackFace = max(0.0, disBackFace);
		if (len == dis) isClip = true;
		samplePos = vec4(samplePos.xyz+dir * disBackFace, disBackFace);
	}
	return samplePos;
}

void clipVolume(inout vec3 startPos, inout vec3 backPos, int dim, float frac, bool isLo) {
	vec3 dir = backPos - startPos;
	float len = length(dir);
	dir = normalize(dir);
	// Discard if both startPos and backPos are outside the clipping plane
	if (isLo && startPos[dim] < frac && backPos[dim] < frac) {
		discard;
	}
	if (!isLo && startPos[dim] > frac && backPos[dim] > frac) {
		discard;
	}
	vec4 plane = vec4(0.0, 0.0, 0.0, 0.5 - frac);
	plane[dim] = 1.0;
	float cdot = dot(dir, plane.xyz);
	float dis = (-plane.w - dot(plane.xyz, startPos - vec3(0.5))) / cdot;
	// Adjust startPos or backPos based on the intersection with the plane
	bool isFrontFace = (cdot > 0.0);
	if (!isLo)
		isFrontFace = !isFrontFace;
	if (dis > 0.0) {
		if (isFrontFace) {
				if (dis <= len) {
					startPos = startPos + dir * dis;
				}
		} else {
			if (dis < len) {
				backPos = startPos + dir * dis;
			}
		}
	}
}

void clipVolumeStart (inout vec3 startPos, inout vec3 backPos) {
	// vec3 clipLo = vec3(0.1, 0.2, 0.4);
	// vec3 clipHi = vec3(0.8, 0.7, 0.7);
	for (int i = 0; i < 3; i++) {
		if (clipLo[i] > 0.0)
			clipVolume(startPos, backPos, i, clipLo[i], true);
	}
	for (int i = 0; i < 3; i++) {
		if (clipHi[i] < 1.0)
			clipVolume(startPos, backPos, i, clipHi[i], false);
	}
}

float frac2ndc(vec3 frac) {
//https://stackoverflow.com/questions/7777913/how-to-render-depth-linearly-in-modern-opengl-with-gl-fragcoord-z-in-fragment-sh
	vec4 pos = vec4(frac.xyz, 1.0); //fraction
	vec4 dim = vec4(vec3(textureSize(volume, 0)), 1.0);
	pos = pos * dim;
	vec4 shim = vec4(-0.5, -0.5, -0.5, 0.0);
	pos += shim;
	vec4 mm = transpose(matRAS) * pos;
	float z_ndc = (mvpMtx * vec4(mm.xyz, 1.0)).z;
	return (z_ndc + 1.0) / 2.0;
}`+In,Fn=`void main() {
	if (fColor.x > 2.0) {
		fColor = vec4(1.0, 0.0, 0.0, 0.5);
		return;
	}
	fColor = vec4(0.0,0.0,0.0,0.0);
	vec4 clipPlaneColorX = clipPlaneColor;
	//if (clipPlaneColor.a < 0.0)
	//	clipPlaneColorX.a = - 1.0;
	bool isColorPlaneInVolume = false;
	if (clipPlaneColorX.a < 0.0) {
		isColorPlaneInVolume = true;
		clipPlaneColorX.a = 0.0;
	}
	//fColor = vec4(vColor.rgb, 1.0); return;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	// fColor = vec4(backPosition, 1.0); return;
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	dir = normalize(dir);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	//if ((clipPos.a != samplePos.a) && (len < 3.0)) {
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	float drawOpacityA = renderDrawAmbientOcclusionXY.y;
	if ((samplePos.a >= len) && (((overlays < 1.0) && (drawOpacityA <= 0.0) ) || (backgroundMasksOverlays > 0)))  {
		if (isClip)
			fColor += clipPlaneColorX;
		return;
	}
	fColor = vec4(1.0, 1.0, 1.0, 1.0);
	//gl_FragDepth = frac2ndc(samplePos.xyz); //crude due to fast pass resolution
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * lenNoClip);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
`,ir=`
	if (firstHit.a < len)
		gl_FragDepth = frac2ndc(firstHit.xyz);
	colAcc.a = (colAcc.a / earlyTermination) * backOpacity;
	fColor = colAcc;
	//if (isClip) //CR
	if ((isColorPlaneInVolume) && (clipPos.a != samplePos.a) && (abs(firstHit.a - clipPos.a) < deltaDir.a))
		fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));
		//fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, clipPlaneColorX.a * 0.65);
	float renderDrawAmbientOcclusionX = renderDrawAmbientOcclusionXY.x;
	float drawOpacity = renderDrawAmbientOcclusionXY.y;
	if ((overlays < 1.0) && (drawOpacity <= 0.0))
		return;
	//overlay pass
	len = lenNoClip;
	samplePos = vec4(start.xyz, 0.0); //ray position
	//start: OPTIONAL fast pass: rapid traversal until first hit
	stepSizeFast = sliceSize * 1.0;
	deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (drawOpacity > 0.0)
			val = max(val, texture(drawing, samplePos.xyz).r);
		if (val > 0.001)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	if (samplePos.a >= len) {
		if (isClip && (fColor.a == 0.0))
				fColor += clipPlaneColorX;
			return;
	}
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	float overFarthest = len;
	colAcc = vec4(0.0, 0.0, 0.0, 0.0);

	samplePos += deltaDir * ran; //jitter ray
	vec4 overFirstHit = vec4(0.0,0.0,0.0,2.0 * len);
	if (backgroundMasksOverlays > 0)
		samplePos = firstHit;
	bool firstDraw = true;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(overlay, samplePos.xyz);
		if ((colorSample.a < 0.01) && (drawOpacity > 0.0)) {
			float val = texture(drawing, samplePos.xyz).r;
			vec4 draw = drawColor(val, drawOpacity);
			if ((draw.a > 0.0) && (firstDraw)) {
				firstDraw = false;
				float sum = 0.0;
				const float mn = 1.0 / 256.0;
				const float sampleRadius = 1.1;
				float dx = sliceSize * sampleRadius;
				vec3 center = samplePos.xyz;
				//six neighbors that share a face
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,0.0), dir)).r, mn);
				//float proportion = (sum / mn) / 6.0;
				
				//12 neighbors that share an edge
				dx = sliceSize * sampleRadius * sqrt(2.0) * 0.5;
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,-dx,0.0), dir)).r, mn);

				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,-dx,0.0), dir)).r, mn);
				
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,+dx,0.0), dir)).r, mn);
				float proportion = (sum / mn) / 18.0; //proportion of six neighbors is non-zero
				
				//a high proportion of hits means crevice
				//since the AO term adds shadows that darken most voxels, it will result in dark surfaces
				//the term brighten adds a little illumination to balance this
				// without brighten, only the most extreme ridges will not be darker
				const float brighten = 1.2;
				vec3 ao = draw.rgb * (1.0 - proportion) * brighten;
				draw.rgb = mix (draw.rgb, ao , renderDrawAmbientOcclusionX);
			}
			colorSample = draw;
		}
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (overFirstHit.a > len)
				overFirstHit = samplePos;
			colorSample.a *= renderOverlayBlend;
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			overFarthest = samplePos.a;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
	//if (samplePos.a >= len) {
	if (colAcc.a <= 0.0) {
		if (isClip && (fColor.a == 0.0))
			fColor += clipPlaneColorX;
		return;
	}
	if (overFirstHit.a < firstHit.a)
		gl_FragDepth = frac2ndc(overFirstHit.xyz);
	float overMix = colAcc.a;
	float overlayDepth = 0.3;
	if (fColor.a <= 0.0)
		overMix = 1.0;
	else if (((overFarthest) > backNearest)) {
		float dx = (overFarthest - backNearest)/1.73;
		dx = fColor.a * pow(dx, overlayDepth);
		overMix *= 1.0 - dx;
	}
	fColor.rgb = mix(fColor.rgb, colAcc.rgb, overMix);
	fColor.a = max(fColor.a, colAcc.a);
}`,a0=`#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
`+ns+`
	void main() {
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		fColor = vec4(0.0,0.0,0.0,0.0);
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float dis = len;
	//check if axial plane is closest
	vec4 aClip = vec4(0.0, 0.0, 1.0, (1.0- clipPlane.z) - 0.5);
	float adis = (-aClip.a - dot(aClip.xyz, samplePos.xyz-0.5)) / dot(dir,aClip.xyz);
	if (adis > 0.0)
		dis = min(adis, dis);
	//check of coronal plane is closest
	vec4 cClip = vec4(0.0, 1.0, 0.0, (1.0- clipPlane.y) - 0.5);
	float cdis = (-cClip.a - dot(cClip.xyz, samplePos.xyz-0.5)) / dot(dir,cClip.xyz);
	if (cdis > 0.0)
		dis = min(cdis, dis);
	//check if coronal slice is closest
	vec4 sClip = vec4(1.0, 0.0, 0.0, (1.0- clipPlane.x) - 0.5);
	float sdis = (-sClip.a - dot(sClip.xyz, samplePos.xyz-0.5)) / dot(dir,sClip.xyz);
	if (sdis > 0.0)
		dis = min(sdis, dis);
	if ((dis > 0.0) && (dis < len)) {
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		colAcc = texture(volume, samplePos.xyz);
		colAcc.a = earlyTermination;
		firstHit = samplePos;
		backNearest = min(backNearest, samplePos.a);
	}
	//the following are only used by overlays
	vec4 clipPlaneColorX = clipPlaneColor;
	bool isColorPlaneInVolume = false;
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
`+ir,o0=`#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
`+ns+Fn+`while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
`+ir,Ds=192,_o=`#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 normMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing, gradient;
uniform highp sampler2D colormap;
uniform highp sampler2D matCap;
uniform vec2 renderDrawAmbientOcclusionXY;
uniform float gradientAmount;
uniform float silhouettePower;
uniform float gradientOpacity[${Ds}];
in vec3 vColor;
out vec4 fColor;
`,l0=_o+ns+Fn+`
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	float silhouetteThreshold = 1.0 - silhouettePower;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			grad.rgb = normalize(grad.rgb*2.0 - 1.0);
			//if (grad.a < prevGrad.a)
			//	grad.rgb = prevGrad.rgb;
			//prevGrad = grad;
			vec3 n = mat3(normMtx) * grad.rgb;
			n.y = - n.y;
			vec4 mc = vec4(texture(matCap, n.xy * 0.5 + 0.5).rgb, 1.0) * brighten;
			mc = mix(vec4(1.0), mc, gradientAmount);
			if (samplePos.a > clipClose)
				colorSample.rgb *= mc.rgb;
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			int gradIdx = int(grad.a * 255.0);
			colorSample.a *= gradientOpacity[gradIdx];
			float lightNormDot = dot(grad.rgb, rayDir);
			// n.b. "lightNormDor" is cosTheta, "silhouettePower" is Fresnel effect exponent
 			colorSample.a *= pow(1.0 - abs(lightNormDot), silhouettePower);
 			float viewAlign = abs(lightNormDot); // 0 = perpendicular, 1 = aligned
 			// linearly map silhouettePower (0..1) to a threshold range, e.g., [1.0, 0.0]
 			// Cull voxels that are too aligned with the view direction
 			if (viewAlign > silhouetteThreshold)
 				colorSample.a = 0.0;
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
`+ir,c0=_o+ns+Fn+`
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			colorSample.rgb = abs(normalize(grad.rgb*2.0 - 1.0));
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
`+ir,yr=`#version 300 es
#line 392
layout(location=0) in vec3 pos;
uniform int axCorSag;
uniform mat4 mvpMtx;
uniform mat4 frac2mm;
uniform float slice;
out vec3 texPos;
void main(void) {
	texPos = vec3(pos.x, pos.y, slice);
	if (axCorSag > 1)
		texPos = vec3(slice, pos.x, pos.y);
	else if (axCorSag > 0)
		texPos = vec3(pos.x, slice, pos.y);
	vec4 mm = frac2mm * vec4(texPos, 1.0);
	gl_Position = mvpMtx * mm;
}`,$o=`#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler3D volume, overlay;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;`+In+`void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 ocolor = vec4(0.0);
	float overlayAlpha = overlayAlphaShader;
	if (overlays > 0.0) {
		ocolor = texture(overlay, texPos);
		//dFdx for "boxing" issue 435 has aliasing on some implementations (coarse vs fine)
		//however, this only identifies 50% of the edges due to aliasing effects
		// http://www.aclockworkberry.com/shader-derivative-functions/
		// https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b
		//if ((ocolor.a >= 1.0) && ((dFdx(ocolor.a) != 0.0) || (dFdy(ocolor.a) != 0.0)  ))
		//	ocolor.rbg = vec3(0.0, 0.0, 0.0);
		bool isOutlineBelowNotAboveThreshold = true;
		if (isOutlineBelowNotAboveThreshold) {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a < 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				//6 voxel neighbors that share a face
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 0.0;
				if (axCorSag != 2) {
					a = max(a, texture(overlay, vxR).a);
					a = max(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = max(a, texture(overlay, vxA).a);
					a = max(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = max(a, texture(overlay, vxS).a);
					a = max(a, texture(overlay, vxI).a);
				}
				bool isCheckCorners = true;
				if (isCheckCorners) {
					//12 voxel neighbors that share an edge
					vec3 vxRA = vec3(texPos.x+vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxLA = vec3(texPos.x-vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxRP = vec3(texPos.x+vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxLP = vec3(texPos.x-vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxRS = vec3(texPos.x+vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxLS = vec3(texPos.x-vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxRI = vec3(texPos.x+vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxLI = vec3(texPos.x-vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxAS = vec3(texPos.x, texPos.y+vx.y, texPos.z+vx.z);
					vec3 vxPS = vec3(texPos.x, texPos.y-vx.y, texPos.z+vx.z);
					vec3 vxAI = vec3(texPos.x, texPos.y+vx.y, texPos.z-vx.z);
					vec3 vxPI = vec3(texPos.x, texPos.y-vx.y, texPos.z-vx.z);

					if (axCorSag == 0) { //axial corners
						a = max(a, texture(overlay, vxRA).a);
						a = max(a, texture(overlay, vxLA).a);
						a = max(a, texture(overlay, vxRP).a);
						a = max(a, texture(overlay, vxLP).a);
					}
					if (axCorSag == 1) { //coronal corners
						a = max(a, texture(overlay, vxRS).a);
						a = max(a, texture(overlay, vxLS).a);
						a = max(a, texture(overlay, vxRI).a);
						a = max(a, texture(overlay, vxLI).a);
					}
					if (axCorSag == 2) { //sagittal corners
						a = max(a, texture(overlay, vxAS).a);
						a = max(a, texture(overlay, vxPS).a);
						a = max(a, texture(overlay, vxAI).a);
						a = max(a, texture(overlay, vxPI).a);
					}
				}
				if (a >= 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}

		} else {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a >= 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 1.0;
				if (axCorSag != 2) {
					a = min(a, texture(overlay, vxR).a);
					a = min(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = min(a, texture(overlay, vxA).a);
					a = min(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = min(a, texture(overlay, vxS).a);
					a = min(a, texture(overlay, vxI).a);
				}
				if (a < 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}
		} //outline above threshold
	}

`,h0=`#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler2D volume, overlay;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler2D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;`+In+`void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos.xy);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 dcolor = drawColor(texture(drawing, texPos.xy).r, drawOpacity);
	if (dcolor.a > 0.0) {
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
}`,el=`	ocolor.a *= overlayAlpha;
	vec4 dcolor = drawColor(texture(drawing, texPos).r, drawOpacity);
	if (dcolor.a > 0.0) {
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
	if ((backgroundMasksOverlays > 0) && (background.a == 0.0))
		return;
	float a = color.a + ocolor.a * (1.0 - color.a); // premultiplied alpha
	if (a == 0.0) return;
	color.rgb = mix(color.rgb, ocolor.rgb, ocolor.a / a);
	color.a = a;
}`,f0=$o+el,d0=$o+`	if (ocolor.a > 0.0) {
		//https://gamedev.stackexchange.com/questions/102889/is-it-possible-to-convert-vec4-to-int-in-glsl-using-opengl-es
		uint alpha = uint(ocolor.a * 255.0);
		vec3 xyzFlip = vec3(float((uint(1) & alpha) > uint(0)), float((uint(2) & alpha) > uint(0)), float((uint(4) & alpha) > uint(0)));
		//convert from 0 and 1 to -1 and 1
		xyzFlip = (xyzFlip * 2.0) - 1.0;
		//https://math.stackexchange.com/questions/1905533/find-perpendicular-distance-from-point-to-line-in-3d
		//v1 principle direction of tensor for this voxel
		vec3 v1 = ocolor.rgb;
		//flips encode polarity to convert from 0..1 to -1..1 (27 bits vs 24 bit precision)
		v1 = normalize( v1 * xyzFlip);
		vec3 vxl = fract(texPos * vec3(textureSize(volume, 0))) - 0.5;
		//vxl coordinates now -0.5..+0.5 so 0,0,0 is origin
		vxl.x = -vxl.x;
		float t = dot(vxl,v1);
		vec3 P = t * v1;
		float dx = length(P-vxl);
		ocolor.a = 1.0 - smoothstep(0.2,0.25, dx);
		//if modulation was applied, use that to scale alpha not color:
		ocolor.a *= length(ocolor.rgb);
		ocolor.rgb = normalize(ocolor.rgb);
		//compute distance one half voxel closer to viewer:
		float pan = 0.5;
		if (axCorSag == 0)
			vxl.z -= pan;
		if (axCorSag == 1)
			vxl.y -= pan;
		if (axCorSag == 2)
			vxl.x += pan;
		t = dot(vxl,v1);
		P = t * v1;
		float dx2 = length(P-vxl);
		ocolor.rgb += (dx2-dx-(0.5 * pan)) * 1.0;
	}
`+el,vr=`#version 300 es
#line 480
precision highp int;
precision highp float;
uniform vec4 lineColor;
out vec4 color;
void main() {
	color = lineColor;
}`,u0=`#version 300 es
#line 723
precision highp int;
precision highp float;

uniform vec4 lineColor;
uniform vec4 leftTopWidthHeight;
uniform float thickness; // line thickness in pixels
uniform vec2 canvasWidthHeight;

out vec4 color;

void main() {
    // fragment position in screen coordinates
    vec2 fragCoord = gl_FragCoord.xy;

    // canvas height
    float canvasHeight = canvasWidthHeight.y;

    // 'top' and 'bottom' to match gl_FragCoord.y coordinate system
    float top = canvasHeight - leftTopWidthHeight.y;
    float bottom = top - leftTopWidthHeight.w;

    // left and right edges
    float left = leftTopWidthHeight.x;
    float right = left + leftTopWidthHeight.z;

    bool withinLeft = fragCoord.x >= left && fragCoord.x <= left + thickness;
    bool withinRight = fragCoord.x <= right && fragCoord.x >= right - thickness;
    bool withinTop = fragCoord.y <= top && fragCoord.y >= top - thickness;
    bool withinBottom = fragCoord.y >= bottom && fragCoord.y <= bottom + thickness;

    bool isOutline = withinLeft || withinRight || withinTop || withinBottom;

    if (isOutline) {
        color = lineColor;
    } else {
        discard; 
    }
}`,m0=`#version 300 es
#line 490
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vColor;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vColor = pos.xy;
}`,g0=`#version 300 es
#line 506
precision highp int;
precision highp float;
uniform highp sampler2D colormap;
uniform float layer;
in vec2 vColor;
out vec4 color;
void main() {
	float nlayer = float(textureSize(colormap, 0).y);
	float fmap = (0.5 + layer) / nlayer;
	color = vec4(texture(colormap, vec2(vColor.x, fmap)).rgb, 1.0);
}`,ba=`#version 300 es
#line 520
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
}`,p0=`#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec4 startXYendXY;
void main(void) {
	vec2 posXY = mix(startXYendXY.xy, startXYendXY.zw, pos.x);
	vec2 dir = normalize(startXYendXY.xy - startXYendXY.zw);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0
	gl_Position = vec4((posXY * 2.0) - 1.0, 0.0, 1.0);
}`,A0=`#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec2 startXY;
uniform vec3 endXYZ; // transformed XYZ point
void main(void) {	
	vec2 posXY = mix(startXY.xy, endXYZ.xy, pos.x);
	vec2 startDiff = endXYZ.xy - startXY.xy;
	float startDistance = length(startDiff);
	vec2 diff = endXYZ.xy - posXY;
	float currentDistance = length(diff);
	vec2 dir = normalize(startXY.xy - endXYZ.xy);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0	
	float z = endXYZ.z * ( 1.0 - abs(currentDistance/startDistance)); 
	gl_Position = vec4((posXY * 2.0) - 1.0, z, 1.0);
}`,w0=`#version 300 es
#line 549
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(pos.x, 1.0 - pos.y);
}`,x0=`#version 300 es
#line 565
precision highp int;
precision highp float;
uniform highp sampler2D bmpTexture;
in vec2 vUV;
out vec4 color;
void main() {
	color = texture(bmpTexture, vUV);
}`,y0=`#version 300 es
#line 576
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(uvLeftTopWidthHeight.x + (pos.x * uvLeftTopWidthHeight.z), uvLeftTopWidthHeight.y  + ((1.0 - pos.y) * uvLeftTopWidthHeight.w) );
}`,v0=`#version 300 es
#line 593
precision highp int;
precision highp float;
uniform highp sampler2D fontTexture;
uniform vec4 fontColor;
uniform float screenPxRange;
in vec2 vUV;
out vec4 color;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
void main() {
	vec3 msd = texture(fontTexture, vUV).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange*(sd - 0.5);
	float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	color = vec4(fontColor.rgb , fontColor.a * opacity);
}`,b0=`#version 300 es
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = pos.xy;
}`,C0=`#version 300 es
precision highp int;
precision highp float;
uniform vec4 circleColor;
uniform float fillPercent;
in vec2 vUV;
out vec4 color;
void main() {
	/* Check if the pixel is inside the circle
		 and color it with a gradient. Otherwise, color it 
		 transparent   */
	float distance = length(vUV-vec2(0.5,0.5));
	if ( distance < 0.5 && distance >= (1.0 - fillPercent) / 2.0){
			color = vec4(circleColor.r,circleColor.g,circleColor.b,circleColor.a) ;			
	}else{
			color = vec4(0.0,0.0,0.0,0.0);
	}
}
`,ii=`#version 300 es
#line 613
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4( (vPos.xy-vec2(0.5,0.5)) * 2.0, 0.0, 1.0);
}`,br=`#version 300 es
uniform highp usampler3D intensityVol;
`,Ca=`#version 300 es
uniform highp isampler3D intensityVol;
`,S0=`#version 300 es
uniform highp sampler3D intensityVol;
`,Sa=`#line 636
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform vec4 xyzaFrac;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint idx = uint(texture(intensityVol, vx.xyz).r);
	FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	if (idx == uint(0))
		return;
	//idx = ((idx - uint(1)) % uint(100))+uint(1);
	float textureWidth = float(textureSize(colormap, 0).x);
	float fx = (float(idx)+0.5) / textureWidth;
	float nlayer = float(textureSize(colormap, 0).y);
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(fx, y)).rgba;
	float alpha = FragColor.a;
	FragColor.a *= opacity;
	if (xyzaFrac.a > 0.0) { //outline
		vx = vec4(TexCoord.x+xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
		uint R = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x-xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
		uint L = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y+xyzaFrac.y, coordZ, 1.0) * mtx;
		uint A = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y-xyzaFrac.y, coordZ, 1.0) * mtx;
		uint P = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y, coordZ+xyzaFrac.z, 1.0) * mtx;
		uint S = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y, coordZ-xyzaFrac.z, 1.0) * mtx;
		uint I = uint(texture(intensityVol, vx.xyz).r);
		if ((idx != R) || (idx != L) || (idx != A) || (idx != P) || (idx != S) || (idx != I))
			FragColor.a = alpha * xyzaFrac.a;
	}
}`,Cr=`#line 691
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform float cal_maxNeg;
uniform float cal_minNeg;
uniform bool isAlphaThreshold;
uniform bool isColorbarFromZero;
uniform bool isAdditiveBlend;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform int modulation;
uniform highp sampler3D modulationVol;
uniform float opacity;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	if ((vx.x < 0.0) || (vx.x > 1.0) || (vx.y < 0.0) || (vx.y > 1.0) || (vx.z < 0.0) || (vx.z > 1.0)) {
		//set transparent if out of range
		//https://webglfundamentals.org/webgl/webgl-3d-textures-repeat-clamp.html
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	float f = (scl_slope * float(texture(intensityVol, vx.xyz).r)) + scl_inter;
	float mn = cal_min;
	float mx = cal_max;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mn = 0.0;
	float r = max(0.00001, abs(mx - mn));
	mn = min(mn, mx);
	float txl = mix(0.0, 1.0, (f - mn) / r);
	if (f > mn) { //issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
	}
	//https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space
	float nlayer = float(textureSize(colormap, 0).y);
	//each volume has two color maps:
	// (layer*2) = negative and (layer * 2) + 1 = positive
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(txl, y)).rgba;
	//negative colors
	mn = cal_minNeg;
	mx = cal_maxNeg;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mx = 0.0;
	//if ((!isnan(cal_minNeg)) && ( f < mx)) {
	if ((cal_minNeg < cal_maxNeg) && ( f < mx)) {
		r = max(0.00001, abs(mx - mn));
		mn = min(mn, mx);
		txl = 1.0 - mix(0.0, 1.0, (f - mn) / r);
		//issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
		y = ((2.0 * layer) + 0.5)/nlayer;
		FragColor = texture(colormap, vec2(txl, y));
	}
	if (layer > 0.7)
		FragColor.a = step(0.00001, FragColor.a);
	//if (modulation > 10)
	//	FragColor.a *= texture(modulationVol, vx.xyz).r;
	//	FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (isAlphaThreshold) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = pow(-f / -cal_maxNeg, 2.0);
		else if ((f > 0.0) && (cal_min > 0.0))
			FragColor.a *= pow(f / cal_min, 2.0); //issue435:  A = (V/X)**2
		//FragColor.g = 0.0;
	} else if (isColorbarFromZero) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = 0.0;
		else if ((f > 0.0) && (cal_min > 0.0) && (f < cal_min))
			FragColor.a *= 0.0;

	}
	if (modulation == 1) {
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	} else if (modulation == 2) {
		FragColor.a = texture(modulationVol, vx.xyz).r;
	}
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	if (isAdditiveBlend)
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
	else
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`,E0=`#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	uvec4 aColor = texture(intensityVol, vx.xyz);
	FragColor = vec4(float(aColor.r) / 255.0, float(aColor.g) / 255.0, float(aColor.b) / 255.0, float(aColor.a) / 255.0);
	if (modulation == 1)
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (!hasAlpha) {
		FragColor.a = (FragColor.r * 0.21 + FragColor.g * 0.72 + FragColor.b * 0.07);
		//next line: we could binarize alpha, but see rendering of visible human
		//FragColor.a = step(0.01, FragColor.a);
	}
	if (modulation == 2)
		FragColor.a = texture(modulationVol, vx.xyz).r;
	FragColor.a *= opacity;
}`,D0=`#version 300 es
#line 808
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4((vPos.x - 0.5) * 2.0, (vPos.y - 0.5) * 2.0, 0.0, 1.0);
}`,T0=`#version 300 es
#line 829
	precision highp float;
	precision highp int;
	precision highp isampler3D;
	layout(location = 0) out int label;
	layout(location = 1) out int strength;
	in vec2 TexCoord;
	uniform int finalPass;
	uniform float coordZ;
	uniform lowp sampler3D in3D;
	uniform highp isampler3D backTex; // background
	uniform highp isampler3D labelTex; // label
	uniform highp isampler3D strengthTex; // strength
void main(void) {
	vec3 interpolatedTextureCoordinate = vec3(TexCoord.xy, coordZ);
	ivec3 size = textureSize(backTex, 0);
	ivec3 texelIndex = ivec3(floor(interpolatedTextureCoordinate * vec3(size)));
	int background = texelFetch(backTex, texelIndex, 0).r;
	label = texelFetch(labelTex, texelIndex, 0).r;
	strength = texelFetch(strengthTex, texelIndex, 0).r;
	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				if (i != 0 && j != 0 && k != 0) {
					ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
					int neighborBackground = texelFetch(backTex, neighborIndex, 0).r;
					int neighborStrength = texelFetch(strengthTex, neighborIndex, 0).r;
					int strengthCost = abs(neighborBackground - background);
					int takeoverStrength = neighborStrength - strengthCost;
					if (takeoverStrength > strength) {
						strength = takeoverStrength;
						label = texelFetch(labelTex, neighborIndex, 0).r;
					}
				}
			}
		}
	}
	if (finalPass < 1)
		return;
	int ok = 1;
	ivec4 labelCount = ivec4(0,0,0,0);
	for (int k = -1; k <= 1; k++)
		for (int j = -1; j <= 1; j++)
			for (int i = -1; i <= 1; i++) {
				ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
				int ilabel = texelFetch(labelTex, neighborIndex, 0).r;
				if ((ilabel < 0) || (ilabel > 3))
					ok = 0;
				else
					labelCount[ilabel]++;
			}
	if (ok != 1) {
		return;
	}
	int maxIdx = 0;
	for (int i = 1; i < 4; i++) {
		if (labelCount[i] > labelCount[maxIdx])
			maxIdx = i;
	}
	label = maxIdx;
}`,M0=`#version 300 es
layout(location=0) in vec3 pos;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
}`,I0=`#version 300 es
precision highp int;
precision highp float;
uniform vec4 surfaceColor;
out vec4 color;
void main() {
	color = surfaceColor;
}`,F0=`#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 clr;
out vec4 vClr;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vClr = clr;
}`,B0=`#version 300 es
precision highp int;
precision highp float;
in vec4 vClr;
out vec4 color;
uniform float opacity;
void main() {
	color = vec4(vClr.rgb, opacity);
}`,Sr=`#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
out vec3 vN;
out vec4 vP;
out vec4 vPc;
void main(void) {
	vec3 lightPosition = vec3(0.0, 0.0, -10.0);
	vP = vec4(pos, 1.0);
	vPc = mvpMtx * vec4(pos, 1.0);
	gl_Position = vPc;
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`,U0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
out vec4 color;
vec4 packFloatToVec4i(const float value) {
	const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
	const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
	vec4 res = fract(value * bitSh);
	res -= res.xxyz * bitMsk;
	return res;
}
void main() {
	color = packFloatToVec4i(gl_FragCoord.z);
}`,P0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
float stepmix(float edge0, float edge1, float E, float x){
	float T = clamp(0.5 * (x - edge0 + E) / E, 0.0, 1.0);
	return mix(edge0, edge1, T);
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0);
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.5;
	float shininess = 50.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float df = max(0.0, dot(n, l));
	float sf = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	const float A = 0.1;
	const float B = 0.3;
	const float C = 0.6;
	const float D = 1.0;
	float E = fwidth(df);
	if (df > A - E && df < A + E) df = stepmix(A, B, E, df);
	else if (df > B - E && df < B + E) df = stepmix(B, C, E, df);
	else if (df > C - E && df < C + E) df = stepmix(C, D, E, df);
	else if (df < A) df = 0.0;
	else if (df < B) df = B;
	else if (df < C) df = C;
	else df = D;
	E = fwidth(sf);
	if (sf > 0.5 - E && sf < 0.5 + E)
		sf = smoothstep(0.5 - E, 0.5 + E, sf);
	else
		sf = step(0.5, sf);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(df, 0.0) * vClr.rgb * diffuse;
	color.rgb = a + d + (specular * sf);
	color.a = opacity;
}`,V0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.25;
	float shininess = 10.0;
	float PenWidth = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	float view = abs(dot(n,r)); //with respect to viewer
	if (PenWidth < view) discard;
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color.rgb = a + d + s;
	color.a = opacity;
}`,R0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	const float thresh = 0.4;
	const vec3 viewDir = vec3(0.0, 0.0, -1.0);
	vec3 n = normalize(vN);
	// use abs() for two-sided lighting, max() for one sided
	float cosTheta = abs(dot(n, viewDir));
	// float cosTheta = max(dot(n, viewDir), 0.0);
	// optional fresnel equation - adjust exponent
	// cosTheta = 1.0 - pow(1.0 - cosTheta, 2.0);
	// use step for binary edges, smoothstep for feathered edges
	// vec3 d = step(thresh, cosTheta) * vClr.rgb;
	vec3 d = smoothstep(thresh - 0.05, thresh + 0.05, cosTheta) * vClr.rgb;
	color = vec4(d, opacity);
}`,N0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
  const float edge0 = 0.1;
  const float edge1 = 0.25;
  const vec3 viewDir = vec3(0.0, 0.0, -1.0);
  vec3 n = normalize(vN);
  float cosTheta = abs(dot(n, viewDir));
  float alpha = 1.0 - smoothstep(edge0, edge1, cosTheta);
  if (alpha <= 0.0) {
    discard;
  }
  color = vec4(0.0, 0.0, 0.0, opacity * alpha);
}`,k0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float diffuse = 1.0;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 0.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d = lightNormDot * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(d + s, opacity);
}`,L0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float diffuse = 1.4;
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(normalize(vN), l), 0.0);
	color = vec4(lightNormDot * vClr.rgb * diffuse, opacity);
}`,O0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float specularRGB = 0.7;
	float specularWhite = 0.3;
	float shininess = 10.0;
	float diffuse = 1.0;
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	vec3 n = normalize(vN);
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d3 = lightNormDot * vClr.rgb * diffuse;
	float s = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 s3 = specularRGB * s * vClr.rgb;
	s *= specularWhite;
	color = vec4(d3 + s3 + s, opacity);
}`,z0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
in vec4 vPc;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	// Compute curvature
	vec3 dx = dFdx(n);
	vec3 dy = dFdy(n);
	vec3 xneg = n - dx;
	vec3 xpos = n + dx;
	vec3 yneg = n - dy;
	vec3 ypos = n + dy;
	float depth = length(vPc.xyz);
	float curv = (cross(xneg, xpos).y - cross(yneg, ypos).x) / depth;
	//at this stage 0.5 for flat, with valleys dark and ridges bright
	curv = 1.0 - (curv + 0.5);
	//clamp
	curv =  min(max(curv, 0.0), 1.0);
	// easing function
	curv = pow(curv, 0.5);
	//modulate ambient and diffuse with curvature
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.6;
	float diffuse = 0.6;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 lightPosition = vec3(0.0, 10.0, -2.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient * curv;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`,G0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`,Y0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
uniform sampler2D matCap;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	vec2 uv = n.xy * 0.5 + 0.5;
	uv.y = 1.0 - uv.y;
	vec3 clr = texture(matCap,uv.xy).rgb * vClr.rgb;
	color = vec4(clr, opacity);
}`,W0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float ambient = 0.35;
	float diffuse = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	color = vec4(a + d, opacity);
}`,K0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 up = vec3(0.0, 1.0, 0.0);
	float ax = dot(n, up) * 0.5 + 0.5;  //Shreiner et al. (2013) OpenGL Programming Guide, 8th Ed., p 388. ISBN-10: 0321773039
	vec3 upClr = vec3(1.0, 1.0, 0.95);
	vec3 downClr = vec3(0.4, 0.4, 0.6);
	vec3 a = vClr.rgb * ambient;
	a *= mix(downClr, upClr, ax);
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`,j0=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
//Spherical harmonics constants
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;
//Spherical harmonics coefficients
// Ramamoorthi, R., and P. Hanrahan. 2001b. "An Efficient Representation for Irradiance Environment Maps." In Proceedings of SIGGRAPH 2001, pp. 497500.
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// Constants for Eucalyptus Grove lighting
const vec3 L00  = vec3( 0.3783264,  0.4260425,  0.4504587);
const vec3 L1m1 = vec3( 0.2887813,  0.3586803,  0.4147053);
const vec3 L10  = vec3( 0.0379030,  0.0295216,  0.0098567);
const vec3 L11  = vec3(-0.1033028, -0.1031690, -0.0884924);
const vec3 L2m2 = vec3(-0.0621750, -0.0554432, -0.0396779);
const vec3 L2m1 = vec3( 0.0077820, -0.0148312, -0.0471301);
const vec3 L20  = vec3(-0.0935561, -0.1254260, -0.1525629);
const vec3 L21  = vec3(-0.0572703, -0.0502192, -0.0363410);
const vec3 L22  = vec3( 0.0203348, -0.0044201, -0.0452180);
vec3 SH(vec3 vNormal) {
	vNormal = vec3(vNormal.x,vNormal.z,vNormal.y);
	vec3 diffuseColor = C1 * L22 * (vNormal.x * vNormal.x - vNormal.y * vNormal.y) +
	C3 * L20 * vNormal.z * vNormal.z +
	C4 * L00 -
	C5 * L20 +
	2.0 * C1 * L2m2 * vNormal.x * vNormal.y +
	2.0 * C1 * L21  * vNormal.x * vNormal.z +
	2.0 * C1 * L2m1 * vNormal.y * vNormal.z +
	2.0 * C2 * L11  * vNormal.x +
	2.0 * C2 * L1m1 * vNormal.y +
	2.0 * C2 * L10  * vNormal.z;
	return diffuseColor;
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.1;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 a = vClr.rgb * ambient;
	vec3 d = vClr.rgb * diffuse * SH(-reflect(n, vec3(l.x, l.y, -l.z)) );
	color = vec4(a + d + s, opacity);
}`,H0=`#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
flat out vec3 vN;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`,Ea=`#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
flat in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`,q0=`#version 300 es
#line 1260
//precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 volScale;
uniform vec3 texVox;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform mat4 matRAS;
uniform mat4 mvpMtx;
uniform float drawOpacity, renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform int backgroundMasksOverlays;
in vec3 vColor;
out vec4 fColor;
`+ns+`
void main() {
	int id = 254;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	fColor = vec4(0.0, 0.0, 0.0, 0.0); //assume no hit: ID = 0
	float fid = float(id & 255)/ 255.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) return;//discard; //length limit for parallel rays
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	dir = normalize(dir);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	if (isClip) fColor = vec4(samplePos.xyz, 253.0 / 255.0); //assume no hit: ID = 0
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			break;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//end: fast pass
	if ((overlays < 1.0) || (backgroundMasksOverlays > 0)) {
		return; //background hit, no overlays
	}
	//overlay pass
	len = min(lenNoClip, samplePos.a); //only find overlay closer than background
	samplePos = vec4(start.xyz, 0.0); //ray position
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			return;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//if (fColor.a == 0.0) discard; //no hit in either background or overlays
	//you only get here if there is a hit with the background that is closer than any overlay
}`,Q0=`#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
layout(location=0)  in vec3 a_position;
layout(location=1)  in vec3 a_color;
// A matrix to transform the positions by
uniform mat4 u_matrix;
out vec3 vColor;
// all shaders have a main function
void main() {
	// Multiply the position by the matrix.
	vec4 pos = vec4(a_position, 1.0);
	gl_Position = u_matrix * vec4(pos);
	vColor = a_color;
}
`,X0=`#version 300 es
precision highp float;
uniform vec4 u_color;
in vec3 vColor;
out vec4 outColor;
void main() {
	outColor = vec4(vColor, 1.0);
}`,Z0=`#version 300 es
#line 1359
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	vec2 viewCoord = (vPos.xy - 0.5) * 2.0;
	gl_Position = vec4((vPos.xy - 0.5) * 2.0, 0.0, 1.0);
}`,J0=`#version 300 es
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform lowp sampler3D in3D;
void main(void) {
 FragColor = texture(in3D, vec3(TexCoord.xy, coordZ));
}`,ms=`#version 300 es
#line 286
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
    TexCoord = vPos.xy;
    gl_Position = vec4( (vPos.xy-vec2(0.5,0.5))* 2.0, 0.0, 1.0);
}`,_0=`#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 samp = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
 FragColor = samp*0.125;
}`,$0=`#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 XYZ = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 vec4 OYZ = texture(intensityVol,vx+vec3(0.0,+dY,+dZ));
 vec4 xYZ = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 vec4 XOZ = texture(intensityVol,vx+vec3(+dX,0.0,+dZ));
 vec4 OOZ = texture(intensityVol,vx+vec3(0.0,0.0,+dZ));
 vec4 xOZ = texture(intensityVol,vx+vec3(-dX,0.0,+dZ));
 vec4 XyZ = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 vec4 OyZ = texture(intensityVol,vx+vec3(0.0,-dY,+dZ));
 vec4 xyZ = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));

 vec4 XYO = texture(intensityVol,vx+vec3(+dX,+dY,0.0));
 vec4 OYO = texture(intensityVol,vx+vec3(0.0,+dY,0.0));
 vec4 xYO = texture(intensityVol,vx+vec3(-dX,+dY,0.0));
 vec4 XOO = texture(intensityVol,vx+vec3(+dX,0.0,0.0));
 vec4 OOO = texture(intensityVol,vx+vec3(0.0,0.0,0.0));
 vec4 xOO = texture(intensityVol,vx+vec3(-dX,0.0,0.0));
 vec4 XyO = texture(intensityVol,vx+vec3(+dX,-dY,0.0));
 vec4 OyO = texture(intensityVol,vx+vec3(0.0,-dY,0.0));
 vec4 xyO = texture(intensityVol,vx+vec3(-dX,-dY,0.0));

 vec4 XYz = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 vec4 OYz = texture(intensityVol,vx+vec3(0.0,+dY,-dZ));
 vec4 xYz = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 vec4 XOz = texture(intensityVol,vx+vec3(+dX,0.0,-dZ));
 vec4 OOz = texture(intensityVol,vx+vec3(0.0,0.0,-dZ));
 vec4 xOz = texture(intensityVol,vx+vec3(-dX,0.0,-dZ));
 vec4 Xyz = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 vec4 Oyz = texture(intensityVol,vx+vec3(0.0,-dY,-dZ));
 vec4 xyz = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));

 vec4 blurred = vec4 (0.0, 0.0, 0.0, 0.0);
 blurred.r = 2.0*(xOz.r +xOZ.r +xyO.r +xYO.r +xOO.r +XOz.r +XOZ.r +XyO.r +XYO.r +XOO.r) +xyz.r +xyZ.r +xYz.r +xYZ.r +Xyz.r +XyZ.r +XYz.r +XYZ.r;
 blurred.g = 2.0*(Oyz.r +OyZ.r +xyO.r +XyO.r +OyO.r +OYz.r +OYZ.r +xYO.r +XYO.r +OYO.r) +xyz.r +Xyz.r +xyZ.r +XyZ.r +xYz.r +XYz.r +xYZ.r +XYZ.r;
 blurred.b = 2.0*(Oyz.r +OYz.r +xOz.r +XOz.r +OOz.r +OyZ.r +OYZ.r +xOZ.r +XOZ.r +OOZ.r) +xyz.r +Xyz.r +xYz.r +XYz.r +xyZ.r +XyZ.r +XyZ.r +XYZ.r;
 blurred.a = 0.32*(abs(blurred.r)+abs(blurred.g)+abs(blurred.b));
 // 0.0357 = 1/28 to account for weights, rescale to 2**16,
 FragColor = 0.0357*blurred;
}`,tl=`
  gradientSample.a = log2(gradientSample.r*gradientSample.r + gradientSample.g*gradientSample.g + gradientSample.b*gradientSample.b + 1.922337562475971e-06) + 18.988706873717717;
`,ef=`#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  float TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ)).r;
  float TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ)).r;
  float TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ)).r;
  float TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ)).r;
  float BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ)).r;
  float BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ)).r;
  float BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ)).r;
  float BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ)).r;
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = BAR+BAL+BPR+BPL -TAR-TAL-TPR-TPL;
  gradientSample.g = TPR+TPL+BPR+BPL -TAR-TAL-BAR-BAL;
  gradientSample.b = TAL+TPL+BAL+BPL -TAR-TPR-BAR-BPR;
${tl}
	// 0.04242020977371934 = 1/(log2(3*8) - log2(1/(255**2*8))) // 3*8 -> max for 1st order gradient
	gradientSample.a *= 0.04242020977371934;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb = (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`,tf=`#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform float dX2;
uniform float dY2;
uniform float dZ2;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  vec4 TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
  vec4 TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
  vec4 TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
  vec4 TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
  vec4 BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
  vec4 BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
  vec4 BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
  vec4 BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
  vec4 T = texture(intensityVol,vx+vec3(+dX2,0.0,0.0));
  vec4 A = texture(intensityVol,vx+vec3(0.0,+dY2,0.0));
  vec4 R = texture(intensityVol,vx+vec3(0.0,0.0,+dZ2));
  vec4 B = texture(intensityVol,vx+vec3(-dX2,0.0,0.0));
  vec4 P = texture(intensityVol,vx+vec3(0.0,-dY2,0.0));
  vec4 L = texture(intensityVol,vx+vec3(0.0,0.0,-dZ2));
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = -4.0*B.r +8.0*(BAR.r+BAL.r+BPR.r+BPL.r) -8.0*(TAR.r+TAL.r+TPR.r+TPL.r) +4.0*T.r;
  gradientSample.g = -4.0*P.g +8.0*(TPR.g+TPL.g+BPR.g+BPL.g) -8.0*(TAR.g+TAL.g+BAR.g+BAL.g) +4.0*A.g;
  gradientSample.b = -4.0*L.b +8.0*(TAL.b+TPL.b+BAL.b+BPL.b) -8.0*(TAR.b+TPR.b+BAR.b+BPR.b) +4.0*R.b;
${tl}
	gradientSample.a *= 0.0325;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb =  (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`,sf=new Float32Array([-1,-1,-1,.28,.28,.28,-1,-1,-1,.28,.28,.28,-1,1,-1,.28,.28,.28,1,-1,-1,.28,.28,.28,1,1,-1,.28,.28,.28,1,1,-1,.28,.28,.28,-1,-1,1,.8,.8,.8,-1,-1,1,.8,.8,.8,1,-1,1,.8,.8,.8,-1,1,1,.8,.8,.8,1,1,1,.8,.8,.8,1,1,1,.8,.8,.8,-1,1,-1,0,0,.74,-1,1,-1,0,0,.74,-1,1,1,0,0,.74,1,1,-1,0,0,.74,1,1,1,0,0,.74,1,1,1,0,0,.74,-1,-1,-1,.42,0,.42,-1,-1,-1,.42,0,.42,1,-1,-1,.42,0,.42,-1,-1,1,.42,0,.42,1,-1,1,.42,0,.42,1,-1,1,.42,0,.42,-1,-1,-1,.64,0,0,-1,-1,-1,.64,0,0,-1,-1,1,.64,0,0,-1,1,-1,.64,0,0,-1,1,1,.64,0,0,-1,1,1,.64,0,0,1,-1,-1,0,.5,0,1,-1,-1,0,.5,0,1,1,-1,0,.5,0,1,-1,1,0,.5,0,1,1,1,0,.5,0,1,1,1,0,.5,0,-.45,1,-.8,0,0,0,-.45,1,-.8,0,0,0,-.45,1,.8,0,0,0,-.25,1,-.8,0,0,0,-.25,1,.8,0,0,0,-.25,1,.8,0,0,0,-.25,1,.6,0,0,0,-.25,1,.6,0,0,0,-.25,1,.8,0,0,0,.45,1,.6,0,0,0,.25,1,.8,0,0,0,.25,1,.8,0,0,0,.25,1,.1,0,0,0,.25,1,.1,0,0,0,.25,1,.6,0,0,0,.45,1,.1,0,0,0,.45,1,.6,0,0,0,.45,1,.6,0,0,0,-.25,1,-.1,0,0,0,-.25,1,-.1,0,0,0,-.25,1,.1,0,0,0,.25,1,-.1,0,0,0,.45,1,.1,0,0,0,.45,1,.1,0,0,0,.45,-1,-.8,0,0,0,.45,-1,-.8,0,0,0,.05,-1,.8,0,0,0,.25,-1,-.8,0,0,0,-.15,-1,.8,0,0,0,-.15,-1,.8,0,0,0,-.25,-1,-.8,0,0,0,-.25,-1,-.8,0,0,0,.05,-1,.8,0,0,0,-.45,-1,-.8,0,0,0,-.15,-1,.8,0,0,0,-.15,-1,.8,0,0,0,.13,-1,-.3,0,0,0,.13,-1,-.3,0,0,0,.07,-1,-.1,0,0,0,-.33,-1,-.3,0,0,0,-.27,-1,-.1,0,0,0,-.27,-1,-.1,0,0,0,-.45,.6,1,0,0,0,-.45,.6,1,0,0,0,-.45,.4,1,0,0,0,-.25,.8,1,0,0,0,-.25,.4,1,0,0,0,-.25,.4,1,0,0,0,-.25,.8,1,0,0,0,-.25,.8,1,0,0,0,-.25,.6,1,0,0,0,.25,.8,1,0,0,0,.45,.6,1,0,0,0,.45,.6,1,0,0,0,.25,.8,1,0,0,0,.25,.8,1,0,0,0,.25,-.1,1,0,0,0,.45,.6,1,0,0,0,.45,.1,1,0,0,0,.45,.1,1,0,0,0,-.25,.1,1,0,0,0,-.25,.1,1,0,0,0,-.45,-.1,1,0,0,0,.25,.1,1,0,0,0,.25,-.1,1,0,0,0,.25,-.1,1,0,0,0,-.45,-.1,1,0,0,0,-.45,-.1,1,0,0,0,-.45,-.6,1,0,0,0,-.25,-.1,1,0,0,0,-.25,-.8,1,0,0,0,-.25,-.8,1,0,0,0,-.25,-.6,1,0,0,0,-.25,-.6,1,0,0,0,-.25,-.8,1,0,0,0,.45,-.6,1,0,0,0,.25,-.8,1,0,0,0,.25,-.8,1,0,0,0,.25,-.4,1,0,0,0,.25,-.4,1,0,0,0,.25,-.6,1,0,0,0,.45,-.4,1,0,0,0,.45,-.6,1,0,0,0,.45,-.6,1,0,0,0,-.1,-.8,-1,0,0,0,-.1,-.8,-1,0,0,0,-.1,.8,-1,0,0,0,.1,-.8,-1,0,0,0,.1,.8,-1,0,0,0,.1,.8,-1,0,0,0,-1,-.45,-.8,0,0,0,-1,-.45,-.8,0,0,0,-1,-.45,.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,.8,0,0,0,-1,-.25,.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,-.6,0,0,0,-1,.45,-.8,0,0,0,-1,.45,-.6,0,0,0,-1,.45,-.6,0,0,0,1,.45,-.8,0,0,0,1,.45,-.8,0,0,0,1,.45,.8,0,0,0,1,.25,-.8,0,0,0,1,.25,.8,0,0,0,1,.25,.8,0,0,0,1,.25,.6,0,0,0,1,.25,.6,0,0,0,1,.25,.8,0,0,0,1,-.45,.6,0,0,0,1,-.25,.8,0,0,0,1,-.25,.8,0,0,0,1,-.25,.1,0,0,0,1,-.25,.1,0,0,0,1,-.25,.6,0,0,0,1,-.45,.1,0,0,0,1,-.45,.6,0,0,0,1,-.45,.6,0,0,0,1,.25,-.1,0,0,0,1,.25,-.1,0,0,0,1,.25,.1,0,0,0,1,-.25,-.1,0,0,0,1,-.45,.1,0,0,0,1,-.45,.1,0,0,0,1,-.25,-.8,0,0,0,1,-.25,-.8,0,0,0,1,-.05,-.1,0,0,0,1,-.45,-.8,0,0,0,1,-.25,-.1,0,0,0,1,-.25,-.1,0,0,0]),oe=class{constructor(e,i,s,r,n=null,a=null){F(this,"sphereIdx",[]),F(this,"sphereVtx",[]),F(this,"renderShaders",[]),F(this,"isVisible",!0),F(this,"isPickable",!0),F(this,"vertexBuffer"),F(this,"indexCount"),F(this,"indexBuffer"),F(this,"vao"),F(this,"mode"),F(this,"glFlags",0),F(this,"id"),F(this,"colorId"),F(this,"modelMatrix",se()),F(this,"scale",[1,1,1]),F(this,"position",[0,0,0]),F(this,"rotation",[0,0,0]),F(this,"rotationRadians",0),F(this,"extentsMin",[]),F(this,"extentsMax",[]),F(this,"furthestVertexFromOrigin"),F(this,"originNegate"),F(this,"fieldOfViewDeObliqueMM"),F(this,"mm"),this.vertexBuffer=i,this.indexCount=r,this.indexBuffer=n,this.vao=a,this.mode=s,this.id=e,this.colorId=[(e>>0&255)/255,(e>>8&255)/255,(e>>16&255)/255,(e>>24&255)/255]}};F(oe,"BLEND",1);F(oe,"CULL_FACE",2);F(oe,"CULL_FRONT",4);F(oe,"CULL_BACK",8);F(oe,"ENABLE_DEPTH_TEST",16);F(oe,"generateCrosshairs",function(t,e,i,s,r,n,a=20,o=0){const l=oe.generateCrosshairsGeometry(t,i,s,r,n,a,o);return new oe(e,l.vertexBuffer,t.TRIANGLES,l.indexCount,l.indexBuffer,l.vao)});F(oe,"generateCrosshairsGeometry",function(t,e,i,s,r,n=20,a=0){const o=[],l=[],c=r*a;if(c<=0){let u=H(i[0],e[1],e[2]),m=H(s[0],e[1],e[2]);oe.makeCylinder(o,l,u,m,r,n),u=H(e[0],i[1],e[2]),m=H(e[0],s[1],e[2]),oe.makeCylinder(o,l,u,m,r,n),u=H(e[0],e[1],i[2]),m=H(e[0],e[1],s[2]),oe.makeCylinder(o,l,u,m,r,n)}else{let u=H(i[0],e[1],e[2]),m=H(e[0]-c,e[1],e[2]);oe.makeCylinder(o,l,u,m,r,n,!1),u=H(e[0]+c,e[1],e[2]),m=H(s[0],e[1],e[2]),oe.makeCylinder(o,l,u,m,r,n,!1),u=H(e[0],i[1],e[2]),m=H(e[0],e[1]-c,e[2]),oe.makeCylinder(o,l,u,m,r,n,!1),u=H(e[0],e[1]+c,e[2]),m=H(e[0],s[1],e[2]),oe.makeCylinder(o,l,u,m,r,n,!1),u=H(e[0],e[1],i[2]),m=H(e[0],e[1],e[2]-c),oe.makeCylinder(o,l,u,m,r,n,!1),u=H(e[0],e[1],e[2]+c),m=H(e[0],e[1],s[2]),oe.makeCylinder(o,l,u,m,r,n,!1)}const h=t.createBuffer();if(h===null)throw new Error("could not instantiate vertex buffer");t.bindBuffer(t.ARRAY_BUFFER,h),t.bufferData(t.ARRAY_BUFFER,new Float32Array(o),t.STATIC_DRAW);const d=t.createBuffer();if(d===null)throw new Error("could not instantiate index buffer");t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,d),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(l),t.STATIC_DRAW);const f=t.createVertexArray();return t.bindVertexArray(f),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,d),t.bindBuffer(t.ARRAY_BUFFER,h),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,3,t.FLOAT,!1,0,0),t.bindVertexArray(null),{vertexBuffer:h,indexBuffer:d,indexCount:l.length,vao:f}});F(oe,"getFirstPerpVector",function(t){const e=H(0,0,0);return t[0]===0?e[0]=1:t[1]===0?e[1]=1:t[2]===0?e[2]=1:(e[0]=t[2],e[1]=t[2],e[2]=-(t[0]+t[1]),ft(e,e)),e});F(oe,"subdivide",function(t,e){let i=t.length/3,s=e.length/3;const r=s,n=fe(),a=fe();for(let o=0;o<r;o++){const l=e[o*3+0],c=e[o*3+1],h=e[o*3+2],d=H(t[l*3+0],t[l*3+1],t[l*3+2]),f=H(t[c*3+0],t[c*3+1],t[c*3+2]),u=H(t[h*3+0],t[h*3+1],t[h*3+2]);Ht(n,d,f),ft(a,n),t.push(...a),Ht(n,f,u),ft(a,n),t.push(...a),Ht(n,d,u),ft(a,n),t.push(...a);let m=[i,i+1,i+2];e.push(...m),m=[l,i,i+2],e.push(...m),m=[i,c,i+1],e.push(...m),e[o*3+0]=i+2,e[o*3+1]=i+1,e[o*3+2]=h,s=s+3,i=i+3}});F(oe,"weldVertices",function(t,e){const i=t.length/3;let s=0;const r=new Int32Array(i);for(let o=0;o<i-1;o++){if(r[o]!==0)continue;r[o]=s;let l=o*3;const c=t[l],h=t[l+1],d=t[l+2];for(let f=o+1;f<i;f++)l+=3,c===t[l]&&h===t[l+1]&&d===t[l+2]&&(r[f]=s);s++}if(s===i)return t;const n=e.length;for(let o=0;o<n;o++)e[o]=r[e[o]];const a=t.slice(0,s*3-1);for(let o=0;o<i-1;o++){const l=o*3,c=r[o]*3;a[c]=t[l],a[c+1]=t[l+1],a[c+2]=t[l+2]}return a});F(oe,"makeSphere",function(t,e,i,s=[0,0,0]){let r=[0,0,1,.894,0,.447,.276,.851,.447,-.724,.526,.447,-.724,-.526,.447,.276,-.851,.447,.724,.526,-.447,-.276,.851,-.447,-.894,0,-.447,-.276,-.851,-.447,.724,-.526,-.447,0,0,-1];const n=[0,1,2,0,2,3,0,3,4,0,4,5,0,5,1,7,6,11,8,7,11,9,8,11,10,9,11,6,10,11,6,2,1,7,3,2,8,4,3,9,5,4,10,1,5,6,7,2,7,8,3,8,9,4,9,10,5,10,6,1];oe.subdivide(r,n),oe.subdivide(r,n),r=oe.weldVertices(r,n);for(let c=0;c<r.length;c++)r[c]=r[c]*i;const a=r.length/3;let o=0;for(let c=0;c<a;c++)r[o]=r[o]+s[0],o++,r[o]=r[o]+s[1],o++,r[o]=r[o]+s[2],o++;const l=Math.floor(t.length/3);for(let c=0;c<n.length;c++)n[c]=n[c]+l;e.push(...n),t.push(...r)});F(oe,"makeCylinder",function(t,e,i,s,r,n=20,a=!0){n<3&&(n=3);const o=fe();de(o,s,i),ft(o,o);const l=oe.getFirstPerpVector(o),c=fe();bs(c,o,l),ft(c,c);let h=2*n,d=2*n;a&&(d+=2*n,h+=2);const f=Math.floor(t.length/3),u=new Uint32Array(d*3),m=new Float32Array(h*3);function g(v,D){m[v*3+0]=D[0],m[v*3+1]=D[1],m[v*3+2]=D[2]}function p(v,D,b,C){u[v*3+0]=D+f,u[v*3+1]=b+f,u[v*3+2]=C+f}const A=2*n,w=A+1;a&&(g(A,i),g(w,s));const x=fe(),y=fe();for(let v=0;v<n;v++){const D=Math.cos(v/n*2*Math.PI),b=Math.sin(v/n*2*Math.PI);x[0]=r*(D*l[0]+b*c[0]),x[1]=r*(D*l[1]+b*c[1]),x[2]=r*(D*l[2]+b*c[2]),Ht(y,i,x),g(v,y),Ht(y,s,x),g(v+n,y);let C=0;v<n-1&&(C=v+1),p(v*2,v,C,v+n),p(v*2+1,C,C+n,v+n),a&&(p(n*2+v,v,A,C),p(n*2+v+n,w,v+n,C+n))}e.push(...u),t.push(...m)});F(oe,"makeColoredCylinder",function(t,e,i,s,r,n,a=[192,0,0,255],o=20,l=!1){let c=t.length/3;oe.makeCylinder(t,e,s,r,n,o,l),c=t.length/3-c;const h=[];for(let d=0;d<c*4-1;d+=4)h[d]=a[0],h[d+1]=a[1],h[d+2]=a[2],h[d+3]=a[3];i.push(...h)});F(oe,"makeColoredSphere",function(t,e,i,s,r=[0,0,0],n=[0,0,192,255]){let a=t.length/3;oe.makeSphere(t,e,s,r),a=t.length/3-a;const o=[];for(let l=0;l<a*4-1;l+=4)o[l]=n[0],o[l+1]=n[1],o[l+2]=n[2],o[l+3]=n[3];i.push(...o)});var Zt=oe,Ts={};tr(Ts,{$itksnap:()=>rf,$slicer3d:()=>nf,actc:()=>af,afni_blues_inv:()=>xd,afni_reds_inv:()=>yd,batlow:()=>of,bcgwhw:()=>cf,bcgwhw_dark:()=>lf,blue:()=>mf,blue2cyan:()=>df,blue2magenta:()=>ff,blue2red:()=>hf,bluegrn:()=>uf,bone:()=>gf,bronze:()=>pf,cet_l17:()=>Af,cividis:()=>wf,cool:()=>xf,copper:()=>vf,copper2:()=>yf,ct_airways:()=>bf,ct_artery:()=>Cf,ct_bones:()=>Sf,ct_brain:()=>Df,ct_brain_gray:()=>Ef,ct_cardiac:()=>Tf,ct_head:()=>Mf,ct_kidneys:()=>If,ct_liver:()=>Ff,ct_muscles:()=>Bf,ct_scalp:()=>Uf,ct_skull:()=>Pf,ct_soft:()=>Vf,ct_soft_tissue:()=>Rf,ct_surface:()=>Nf,ct_vessels:()=>kf,ct_w_contrast:()=>Lf,cubehelix:()=>Of,electric_blue:()=>zf,freesurfer:()=>Gf,ge_color:()=>Yf,gold:()=>Wf,gray:()=>Kf,green:()=>jf,green2cyan:()=>Hf,green2orange:()=>qf,hot:()=>Xf,hotiron:()=>Qf,hsv:()=>Zf,inferno:()=>Jf,jet:()=>_f,kry:()=>$f,linspecer:()=>ed,lipari:()=>td,magma:()=>id,mako:()=>sd,navia:()=>rd,nih:()=>nd,plasma:()=>ad,random:()=>od,red:()=>ld,redyell:()=>cd,rocket:()=>hd,roi_i256:()=>vd,surface:()=>fd,thermal:()=>dd,turbo:()=>ud,violet:()=>md,viridis:()=>gd,warm:()=>pd,winter:()=>Ad,x_rain:()=>wd});var rf={R:[0,255,0,0,255,0,255,255,0,205,210,102,0,0,46,255,106,221,233,165,255,147,218,75,255,60,255,255,218,0,188,255,255,222,127,139,124,255,70,0,238,238,240,245,184,32,255,25,112,34,248,245,255,144,173,65,255,250,128,50,244,255,123,255,173,255,127,255,143,220,253,255,0,0,128,255,250,148,178,255,135,100,240,250,255,107,135,0,139,245,186,255,255,0,210,255,47,72,175,128,176,255,139,240,255,216,119,219,72,255,199,154,189,240,230,0,85,64,153,205,250,95,0,255,224,176,138,30,240,152,160],G:[0,0,255,0,255,255,0,239,0,133,180,205,0,139,139,228,90,160,150,42,250,112,112,0,182,179,235,228,165,128,143,105,218,184,255,69,252,255,130,100,130,232,255,222,134,178,20,25,128,139,248,255,160,238,255,105,99,240,0,205,164,255,104,165,216,192,255,140,188,20,245,250,206,255,0,250,128,0,34,127,206,149,230,235,245,142,206,0,0,245,85,228,222,191,105,248,79,61,238,128,224,240,0,255,215,191,136,112,209,0,21,205,183,248,230,250,107,224,50,92,250,158,128,69,255,196,43,144,128,251,82],B:[0,0,0,255,0,255,255,213,205,63,140,170,128,139,87,225,205,221,122,42,250,219,214,130,193,113,205,196,32,128,143,180,185,135,0,19,0,224,180,0,238,170,240,179,11,170,147,112,144,34,255,250,122,144,47,225,71,230,0,50,96,240,238,0,230,203,212,0,143,60,230,240,209,127,128,205,114,211,34,80,235,237,140,215,238,35,250,139,139,220,211,181,173,255,30,220,79,139,238,0,230,245,0,255,0,216,153,147,204,255,133,50,107,255,250,154,47,208,204,92,210,160,0,0,255,222,226,255,128,152,45],A:[0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130]},nf={labels:["background","tissue","bone","skin","connective tissue","blood","organ","mass","muscle","foreign object","waste","teeth","fat","gray matter","white matter","nerve","vein","artery","capillary","ligament","tendon","cartilage","meniscus","lymph node","lymphatic vessel","cerebro-spinal fluid","bile","urine","feces","gas","fluid","edema","bleeding","necrosis","clot","embolism","head","central nervous system","brain","gray matter of brain","telencephalon","cerebral cortex","right frontal lobe","left frontal lobe","right temporal lobe","left temporal lobe","right parietal lobe","left parietal lobe","right occipital lobe","left occipital lobe","right insular lobe","left insular lobe","right limbic lobe","left limbic lobe","right striatum","left striatum","right caudate nucleus","left caudate nucleus","right putamen","left putamen","right pallidum","left pallidum","right amygdaloid complex","left amygdaloid complex","diencephalon","thalamus","right thalamus","left thalamus","pineal gland","midbrain","substantia nigra","right substantia nigra","left substantia nigra","cerebral white matter","right superior longitudinal fasciculus","left superior longitudinal fasciculus","right inferior longitudinal fasciculus","left inferior longitudinal fasciculus","right arcuate fasciculus","left arcuate fasciculus","right uncinate fasciculus","left uncinate fasciculus","right cingulum bundle","left cingulum bundle","projection fibers","right corticospinal tract","left corticospinal tract","right optic radiation","left optic radiation","right medial lemniscus","left medial lemniscus","right superior cerebellar peduncle","left superior cerebellar peduncle","right middle cerebellar peduncle","left middle cerebellar peduncle","right inferior cerebellar peduncle","left inferior cerebellar peduncle","optic chiasm","right optic tract","left optic tract","right fornix","left fornix","commissural fibers","corpus callosum","posterior commissure","cerebellar white matter","CSF space","ventricles of brain","right lateral ventricle","left lateral ventricle","right third ventricle","left third ventricle","cerebral aqueduct","fourth ventricle","subarachnoid space","spinal cord","gray matter of spinal cord","white matter of spinal cord","endocrine system of brain","pituitary gland","adenohypophysis","neurohypophysis","meninges","dura mater","arachnoid","pia mater","muscles of head","salivary glands","lips","nose","tongue","soft palate","right inner ear","left inner ear","right external ear","left external ear","right middle ear","left middle ear","right eyeball","left eyeball","skull","right frontal bone","left frontal bone","right parietal bone","left parietal bone","right temporal bone","left temporal bone","right sphenoid bone","left sphenoid bone","right ethmoid bone","left ethmoid bone","occipital bone","maxilla","right zygomatic bone","right lacrimal bone","vomer bone","right palatine bone","left palatine bone","mandible","neck","muscles of neck","pharynx","larynx","thyroid gland","right parathyroid glands","left parathyroid glands","skeleton of neck","hyoid bone","cervical vertebral column","thorax","trachea","bronchi","right lung","left lung","superior lobe of right lung","superior lobe of left lung","middle lobe of right lung","inferior lobe of right lung","inferior lobe of left lung","pleura","heart","right atrium","left atrium","atrial septum","ventricular septum","right ventricle of heart","left ventricle of heart","mitral valve","tricuspid valve","aortic valve","pulmonary valve","aorta","pericardium","pericardial cavity","esophagus","thymus","mediastinum","skin of thoracic wall","muscles of thoracic wall","skeleton of thorax","thoracic vertebral column","ribs","sternum","right clavicle","left clavicle","abdominal cavity","abdomen","peritoneum","omentum","peritoneal cavity","retroperitoneal space","stomach","duodenum","small bowel","colon","anus","liver","biliary tree","gallbladder","pancreas","spleen","urinary system","right kidney","left kidney","right ureter","left ureter","urinary bladder","urethra","right adrenal gland","left adrenal gland","female internal genitalia","uterus","right fallopian tube","left fallopian tube","right ovary","left ovary","vagina","male internal genitalia","prostate","right seminal vesicle","left seminal vesicle","right deferent duct","left deferent duct","skin of abdominal wall","muscles of abdominal wall","skeleton of abdomen","lumbar vertebral column","female external genitalia","male external genitalia","skeleton of upper limb","muscles of upper limb","right upper limb","left upper limb","right shoulder","left shoulder","right arm"],R:[0,128,241,177,111,216,221,144,192,220,78,255,230,200,250,244,0,216,183,183,152,111,178,68,111,85,0,214,78,218,170,140,188,216,145,150,177,244,250,200,68,128,83,83,162,162,141,141,182,182,188,188,154,154,177,177,30,30,210,210,48,48,98,98,69,166,122,122,253,145,46,0,0,250,127,127,159,159,125,125,106,106,154,154,126,201,201,78,78,174,174,139,139,148,148,186,186,99,156,156,64,64,138,97,126,194,85,88,88,88,88,88,88,88,88,244,200,250,82,57,60,92,255,255,255,255,201,70,188,177,166,182,229,229,174,174,201,201,194,194,241,203,203,229,229,255,255,209,209,248,248,255,196,255,255,255,242,242,222,177,213,184,150,62,62,62,242,250,255,177,182,175,197,197,172,172,202,224,224,255,206,210,203,233,195,181,152,159,166,218,225,224,255,184,211,47,255,173,188,255,226,253,244,205,205,186,177,255,234,204,180,216,255,205,204,255,221,0,139,249,157,203,185,185,247,247,222,124,249,249,244,255,255,227,213,213,193,216,230,245,245,241,241,177,171,217,212,185,185,198,194,177,177,177,177,177],G:[0,174,214,122,184,101,130,238,104,245,63,250,220,200,250,214,151,101,156,214,189,184,212,172,197,188,145,230,63,255,250,224,65,191,60,98,122,214,250,200,131,174,146,146,115,115,93,93,166,166,135,135,150,150,140,140,111,111,157,157,129,129,153,153,110,113,101,101,135,92,101,108,108,250,150,150,116,116,102,102,174,174,146,146,126,160,160,152,152,140,140,126,126,120,120,135,135,106,171,171,123,123,95,113,161,195,188,106,106,106,106,106,106,106,106,214,200,250,174,157,143,162,244,244,244,244,121,163,91,122,84,105,147,147,122,122,112,112,142,142,213,179,179,204,204,243,243,185,185,223,223,230,172,255,250,237,217,217,198,122,124,105,208,162,162,162,206,210,255,122,228,216,165,165,138,138,164,186,186,245,110,115,108,138,100,85,55,63,70,123,130,97,244,122,171,150,244,121,95,239,202,232,217,179,179,124,122,255,234,142,119,132,253,167,168,224,130,145,150,180,108,136,102,102,182,182,154,186,186,186,170,181,190,153,141,141,123,146,158,172,172,172,172,124,85,198,188,135,135,175,98,122,122,122,122,122],B:[0,128,145,101,210,79,101,144,88,20,0,220,70,235,210,49,206,79,220,211,207,210,242,100,131,255,30,130,0,255,250,228,28,216,66,83,101,49,225,215,98,128,164,164,105,105,137,137,110,110,166,166,201,201,190,190,85,85,166,166,126,126,112,112,53,137,38,38,192,109,131,112,112,225,88,88,163,163,154,154,155,155,83,83,55,133,133,141,141,103,103,177,177,72,72,135,135,24,108,108,147,147,74,158,197,164,255,215,215,215,215,215,215,215,215,49,215,225,128,110,83,109,209,209,209,209,77,117,95,101,94,107,118,118,90,90,73,73,0,0,144,77,77,109,109,152,152,85,85,131,131,138,68,167,160,145,123,123,101,101,109,108,243,114,114,114,142,139,207,101,255,244,145,145,115,115,140,162,162,217,84,89,81,112,73,57,13,27,38,97,104,76,209,154,143,103,209,88,76,172,134,158,154,108,108,161,101,220,194,178,153,105,229,142,143,199,101,30,98,111,162,116,83,83,164,164,132,223,150,150,147,158,165,130,113,113,103,127,140,147,147,151,151,92,68,131,102,134,134,125,79,101,101,101,101,101],A:[0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},af={R:[0,0,24,248,255],G:[0,0,177,254,0],B:[0,136,0,0,0],A:[0,32,64,78,128],I:[0,64,128,156,255]},of={R:[1,10,15,17,21,27,36,49,65,82,99,118,140,161,183,203,222,238,248,253,253,253,252,250],G:[25,42,56,68,79,88,97,105,111,116,122,127,133,138,142,146,150,155,162,170,178,186,195,204],B:[89,92,95,96,98,98,96,91,83,74,64,55,46,43,49,62,79,100,126,151,175,199,223,250],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},lf={R:[0,248,242,235,229,222,212,202,193,183,173,145,117,78,39,0,0,0,0,0,0,64,128,191,255,255,255,255,255,238,221,204,214,224,235,245,255,249,242,236,229,223,217,210,204,197,191,184,176,169,161,154,146,139,132,124,117,109,102,0],G:[0,251,247,243,239,235,235,235,235,235,235,216,197,174,150,127,153,178,204,229,255,255,255,255,255,220,185,150,115,77,38,0,31,61,92,122,153,138,122,107,92,77,61,46,31,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0],B:[0,254,253,252,251,250,251,252,253,254,255,226,198,132,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,80,120,160,200,199,198,197,196,196,195,194,193,192,191,184,176,169,161,154,146,139,132,124,117,109,102,0],A:[256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256],I:[0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,255]},cf={R:[255,248,242,235,229,222,212,202,193,183,173,145,117,78,39,0,0,0,0,0,0,64,128,191,255,255,255,255,255,238,221,204,214,224,235,245,255,249,242,236,229,223,217,210,204,197,191,184,176,169,161,154,146,139,132,124,117,109,102,0],G:[255,251,247,243,239,235,235,235,235,235,235,216,197,174,150,127,153,178,204,229,255,255,255,255,255,220,185,150,115,77,38,0,31,61,92,122,153,138,122,107,92,77,61,46,31,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0],B:[255,254,253,252,251,250,251,252,253,254,255,226,198,132,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,80,120,160,200,199,198,197,196,196,195,194,193,192,191,184,176,169,161,154,146,139,132,124,117,109,102,0],A:[256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256],I:[0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,255]},hf={R:[0,0,0,0,196,255],G:[0,32,128,128,128,32],B:[0,255,196,0,0,0],A:[0,128,64,64,64,128],I:[0,1,64,128,192,255]},ff={R:[0,255],G:[0,0],B:[255,255],A:[0,128],I:[0,255]},df={R:[0,0],G:[0,255],B:[255,255],A:[0,128],I:[0,255]},uf={R:[0,0,0,0],G:[0,1,128,255],B:[0,222,127,32],A:[0,0,64,128],I:[0,1,128,255]},mf={R:[0,0,0],G:[0,0,0],B:[0,128,255],A:[0,64,128],I:[0,128,255]},gf={R:[0,103,255],G:[0,126,255],B:[0,165,255],A:[0,76,128],I:[0,153,255]},pf={R:[0,43,103,199,216,255],G:[0,0,37,155,213,255],B:[0,0,20,97,201,255],A:[0,44,48,54,56,56],I:[0,64,128,196,240,255]},Af={R:[0,9,24,33,40,46,52,57,62,66,70,74,78,81,85,88,91,94,98,101,103,106,109,112,114,117,119,121,124,126,128,130,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,164,166,168,169,171,172,174,175,177,178,180,181,183,184,186,187,189,190,191,193,194,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,222,223,224,224,225,226,226,227,228,228,229,229,230,231,231,232,233,233,234,234,235,235,236,236,236,237,237,237,238,238,238,239,239,239,240,240,240,241,241,241,242,242,242,243,243,243,243,243,243,243,243,244,244,244,244,244,244,244,244,244,244,244,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,244,244,244,244,244,244,244,244,244,244,244,244,244,244,244,243,243,243,243,243,243,243,243,243,243,243,243,242,242,242,242,242,242,242,242,241,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,243,243,244,244,245,246,246,247,247,248,249,249,250,250,251,251,252,252,253,253,254,254,254],G:[42,41,41,41,40,40,40,39,39,39,38,38,37,37,36,36,35,35,34,34,33,32,32,31,30,30,30,30,29,29,29,29,28,28,28,27,27,27,26,26,26,25,25,25,24,24,24,24,24,25,25,26,27,27,28,28,29,30,30,31,31,32,33,33,34,34,35,36,36,37,38,39,40,42,43,44,45,47,48,49,50,51,53,54,55,56,57,58,59,60,62,63,64,65,66,68,69,71,72,73,75,76,77,79,80,81,83,84,85,87,88,89,90,92,93,94,95,97,98,100,101,102,104,105,107,108,109,111,112,113,115,116,117,119,120,121,122,124,125,126,128,129,130,132,133,134,136,137,138,140,141,142,144,145,146,147,149,150,151,153,154,155,156,158,159,160,161,163,164,165,167,168,169,170,172,173,174,175,176,178,179,180,181,183,184,185,186,187,189,190,191,192,193,194,196,197,198,199,200,201,203,204,205,206,207,208,209,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,228,229,230,231,232,233,234,235,236,237,238,238,239,240,241,241,242,243,244,244,245,246,247,248,248,249,250,251,251,252,253,254,255],B:[167,167,166,166,166,165,165,165,164,164,164,163,163,162,162,162,161,161,161,160,160,160,159,159,158,158,157,157,156,155,155,154,154,153,153,152,151,151,150,150,149,149,148,147,147,146,146,145,144,144,143,143,142,141,141,140,139,139,138,137,137,136,135,135,134,133,133,132,131,131,130,130,129,128,128,127,127,126,125,125,124,124,123,123,122,121,121,120,119,119,118,118,117,116,116,116,115,115,114,114,113,113,113,112,112,111,111,110,110,109,109,109,108,108,107,107,106,106,106,106,106,105,105,105,105,105,105,105,104,104,104,104,104,103,103,103,103,103,102,102,102,103,103,103,103,104,104,104,104,104,105,105,105,105,106,106,106,106,106,107,107,107,107,108,108,109,110,111,111,112,113,113,114,115,115,116,117,117,118,119,120,120,121,122,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,140,141,142,143,144,146,147,148,149,150,152,153,155,157,158,160,162,163,165,167,168,170,172,173,175,177,178,180,182,183,185,187,188,190,193,196,199,201,204,207,210,212,215,218,221,224,226,229,232,235,238,240,243,246,249,252,255],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},wf={R:[0,86,166,255],G:[32,92,156,233],B:[76,108,117,69],A:[0,56,80,88],I:[0,64,192,255]},xf={R:[0,0,0],G:[127,196,254],B:[255,255,255],A:[0,64,128],I:[0,128,255]},yf={R:[0,61,122,183,244,255],G:[0,41,81,122,163,255],B:[0,25,51,76,102,255],A:[0,25,51,71,102,128],I:[0,51,102,153,204,255]},vf={R:[0,61,122,183,244,255],G:[0,41,81,122,163,203],B:[0,25,51,76,102,127],A:[0,25,51,71,102,128],I:[0,51,102,153,204,255]},bf={min:-643,max:-235,R:[0,0,0],G:[154,154,154],B:[179,179,101],A:[0,32,0],I:[0,163,255]},Cf={min:114,max:800,R:[0,255,255,255],G:[0,0,129,255],B:[0,0,0,255],A:[0,64,88,228],I:[0,80,160,255]},Sf={min:180,max:600,R:[0,0,113,255],G:[0,0,109,250],B:[0,0,101,245],A:[0,0,100,160],I:[0,1,128,255]},Ef={min:-10,max:110,R:[0,127,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},Df={min:-10,max:110,R:[0,199,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},Tf={min:-80,max:1e3,R:[0,189,150,150,150,150,255],G:[0,169,54,54,54,54,240],B:[0,153,52,52,52,52,242],A:[0,32,64,0,0,64,64],I:[0,1,82,92,234,242,255]},Mf={min:-590,max:600,R:[0,241,241,248,248,178,178,232,255,255,255],G:[0,156,156,222,222,36,36,51,255,255,255],B:[0,130,130,169,169,24,24,37,255,255,255],A:[0,8,0,0,0,64,64,0,0,222,222],I:[0,2,3,64,122,142,172,182,252,253,255]},If={min:114,max:302,R:[0,255,255],G:[0,129,255],B:[0,0,255],A:[0,88,228],I:[0,103,255]},Ff={min:-23,max:246,R:[0,44,255,255,255],G:[0,128,90,255,255],B:[0,0,70,0,255],A:[0,0,82,184,228],I:[0,64,131,196,255]},Bf={min:-100,max:246,R:[0,128,159,255,255,255,255],G:[0,0,56,90,0,255,255],B:[0,0,41,70,0,0,255],A:[0,63,105,135,167,184,228],I:[0,100,128,155,180,209,255]},Uf={min:-590,max:600,R:[0,241,241,248,248,178,232,255,255],G:[0,156,156,222,222,36,51,255,255],B:[0,130,130,169,169,24,37,255,255],A:[0,63,105,135,167,184,228,228,228],I:[0,1,52,127,137,162,172,252,255]},Pf={min:140,max:1024,R:[0,2,113,255],G:[0,1,109,250],B:[0,1,101,245],A:[0,1,96,168],I:[0,1,128,255]},Vf={min:-923,max:679,R:[0,0,0,0,0,255,255,255],G:[154,154,154,154,0,0,254,255],B:[179,179,179,179,0,0,0,255],A:[0,3,8,0,0,10,15,20],I:[0,30,62,88,170,200,232,255]},Rf={min:-10,max:110,R:[0,199,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},Nf={min:-600,max:100,R:[0,134,255],G:[0,109,250],B:[0,101,245],A:[0,60,148],I:[0,128,255]},kf={min:114,max:246,R:[0,255,255],G:[0,128,255],B:[0,128,255],A:[0,64,96],I:[0,87,255]},Lf={min:50,max:1e3,R:[98,210,169,128,255],G:[94,26,77,128,255],B:[45,21,74,128,255],A:[0,25,0,4,168],I:[0,41,87,154,255]},Of={R:[0,13,21,26,27,25,22,21,22,28,39,54,75,98,124,148,171,189,202,210,213,211,206,200,195,193,195,201,211,225,240,255],G:[0,5,11,20,31,44,58,72,86,99,109,116,120,122,122,122,121,121,124,129,137,147,161,175,190,205,218,229,238,245,251,255],B:[0,14,30,46,61,71,77,78,75,68,60,52,48,47,53,65,83,105,131,157,183,205,222,235,241,243,242,240,239,240,245,255],A:[0,4,8,12,17,21,25,29,33,37,41,45,50,54,58,62,66,70,74,78,83,87,91,95,99,103,107,111,116,120,124,128],I:[0,8,16,25,33,41,49,58,66,74,82,90,99,107,115,123,132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255]},zf={R:[0,10,136,255],G:[0,39,220,255],B:[0,223,253,255],A:[0,48,64,70],I:[0,92,192,255]},Gf={R:[0,245,205,120,196,220,230,0,122,236,12,204,42,119,220,103,60,255,165,160,0,245,205,120,196,220,230,0,122,236,13,220,103,255,165,160,0,120,200,255,255,164,164,164,234,0,0,0,0,0],G:[0,245,62,18,58,248,148,118,186,13,48,182,204,159,216,255,60,165,42,32,200,245,62,18,58,248,148,118,186,13,48,216,255,165,42,32,200,190,70,148,148,108,108,108,169,0,0,0,0,0],B:[0,245,78,134,250,164,34,14,220,176,255,142,164,176,20,255,60,0,42,240,200,245,78,134,250,164,34,14,220,176,255,20,255,0,42,240,221,150,255,10,10,226,226,226,30,64,112,160,208,255],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,2,3,4,5,7,8,10,11,12,13,14,15,16,17,18,24,26,28,30,31,41,42,43,44,46,47,49,50,51,52,53,54,58,60,62,63,72,77,78,79,80,81,82,85,251,252,253,254,255]},Yf={R:[0,0,128,255,255],G:[0,128,0,128,255],B:[0,125,255,0,255],A:[0,32,64,96,128],I:[0,63,128,192,255]},Wf={R:[0,142,227,255],G:[0,85,170,255],B:[0,14,76,255],A:[0,42,84,128],I:[0,85,170,255]},Kf={R:[0,255],G:[0,255],B:[0,255],A:[0,128],I:[0,255]},jf={R:[0,0,0],G:[0,128,255],B:[0,0,0],A:[0,64,128],I:[0,128,255]},Hf={R:[0,0,0],G:[72,72,255],B:[0,255,255],A:[0,64,128],I:[0,88,255]},qf={R:[0,255,255],G:[72,88,255],B:[0,0,0],A:[0,64,128],I:[0,88,255]},Qf={R:[0,255,255,255],G:[0,0,126,255],B:[0,0,0,255],A:[0,64,96,128],I:[0,128,191,255]},Xf={R:[3,255,255,255],G:[0,0,255,255],B:[0,0,0,255],A:[0,48,96,128],I:[0,95,191,255]},Zf={R:[255,255,0,0,0,255,255],G:[0,255,255,255,0,0,0],B:[0,0,0,255,255,255,0],A:[0,14,28,43,57,71,85],I:[0,43,85,128,170,213,255]},Jf={R:[0,120,237,240],G:[0,28,105,249],B:[4,109,37,33],A:[0,56,80,88],I:[0,64,192,255]},_f={R:[0,0,127,255,127],G:[0,127,255,127,0],B:[127,255,127,0,0],A:[0,32,64,96,128],I:[0,63,128,192,255]},$f={R:[0,255,255],G:[0,0,255],B:[0,0,0],A:[0,64,64],I:[0,86,255]},ed={R:[94,50,90,152,215,238,249,254,252,241,209,158],G:[79,131,186,214,240,244,237,210,157,100,57,1],B:[162,189,167,164,155,169,168,123,86,68,79,66],A:[0,12,23,35,47,58,70,81,93,105,116,128],I:[0,23,46,70,93,116,139,162,185,209,232,255]},td={R:[3,7,13,25,45,67,84,98,110,124,138,154,173,191,210,225,233,233,231,229,230,235,243,253],G:[19,33,48,63,77,87,92,94,95,96,96,97,99,101,106,118,133,149,163,177,192,208,225,245],B:[38,58,79,99,114,122,122,120,117,113,110,105,101,97,94,96,103,112,122,134,149,169,192,218],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},id={R:[0,148,183,223,247,252],G:[0,44,55,74,112,253],B:[4,128,121,104,92,191],A:[0,44,53,64,75,107],I:[0,107,128,154,179,255]},sd={R:[11,59,55,222],G:[4,45,165,245],B:[5,91,172,229],A:[0,23,70,107],I:[0,56,167,255]},rd={R:[3,5,6,8,12,19,28,36,42,48,54,61,68,76,86,96,110,129,154,181,205,224,239,252],G:[19,32,44,58,72,86,98,108,116,122,128,134,141,149,157,167,178,191,204,216,225,232,239,244],B:[39,60,82,104,123,137,144,145,142,138,134,130,126,121,116,110,105,104,112,131,155,178,198,217],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},nd={R:[0,85,0,0,0,0,0,0,85,255,255,255,172],G:[0,0,0,0,85,170,255,255,255,255,85,0,0],B:[0,170,85,255,255,170,170,0,85,0,0,0,0],A:[0,5,10,21,26,32,37,42,48,53,64,72,85],I:[0,15,31,63,79,95,111,127,143,159,191,217,255]},ad={R:[13,156,237,240],G:[8,23,121,249],B:[135,158,83,33],A:[0,56,80,88],I:[0,64,192,255]},od={R:[208,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248,161,189,41,114,65,121,97,50,238,149,44,214,124,167,40,167,127,178,231,30,173,244,193,203,204,238,139,135,71,234,234,217,66,14,129,19,97,165,112,244,35,73,192,12,149,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248,161,189,41,114,65,121,97,50,238,149,44,214,124,167,40,167,127,178,231,30,173,244,193,203,204,238,139,135,71,234,234,217,66,14,129,19,97,165,112,244,35,73,192,12,149,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248],G:[182,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21,42,22,241,61,99,115,199,166,114,190,204,60,233,66,115,230,125,103,203,125,13,176,94,131,39,198,167,124,67,175,254,1,15,198,62,237,159,31,218,58,244,47,61,67,94,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21,42,22,241,61,99,115,199,166,114,190,204,60,233,66,115,230,125,103,203,125,13,176,94,131,39,198,167,124,67,175,254,1,15,198,62,237,159,31,218,58,244,47,61,67,94,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21],B:[191,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77,89,112,59,125,226,50,205,227,125,128,104,27,59,66,53,133,159,203,97,125,139,159,158,7,215,47,140,226,223,231,44,110,184,61,233,47,67,148,22,120,173,156,117,181,94,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77,89,112,59,125,226,50,205,227,125,128,104,27,59,66,53,133,159,203,97,125,139,159,158,7,215,47,140,226,223,231,44,110,184,61,233,47,67,148,22,120,173,156,117,181,94,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},ld={R:[0,128,255],G:[0,0,0],B:[0,0,0],A:[0,64,128],I:[0,128,255]},cd={R:[192,224,255],G:[1,128,255],B:[0,0,0],A:[0,64,128],I:[0,128,255]},hd={R:[3,112,144,188,236,246,255],G:[5,31,29,22,76,158,250],B:[26,87,91,86,62,117,235],A:[0,30,38,49,67,85,107],I:[0,73,92,118,160,205,255]},fd={R:[1,240,255],G:[1,128,255],B:[1,128,255],A:[0,76,128],I:[0,153,255]},dd={R:[0,5,18,34,53,72,90,107,126,144,161,178,194,209,222,233,242,248,251,251,249,244,241,252],G:[0,4,10,11,9,11,17,23,30,36,43,50,59,70,83,98,117,136,157,177,199,220,240,254],B:[3,24,50,76,96,106,109,110,108,104,97,89,79,67,55,42,26,12,6,22,47,79,121,164],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},ud={R:[48,48,64,70,65,25,132,195,244,254,218,122],G:[18,18,64,107,150,226,255,241,199,158,57,4],B:[59,59,162,227,255,187,81,52,58,47,7,3],A:[0,22,26,30,34,43,52,57,63,67,77,86],I:[0,1,16,32,49,83,118,140,164,181,219,255]},md={R:[0,128,255],G:[0,0,0],B:[0,128,255],A:[0,64,128],I:[0,128,255]},gd={R:[68,49,53,253],G:[1,104,183,231],B:[84,142,121,37],A:[0,56,80,88],I:[0,64,192,255]},pd={R:[255,255,255],G:[127,196,254],B:[0,0,0],A:[0,64,128],I:[0,128,255]},Ad={R:[0,0,0],G:[0,128,255],B:[255,196,128],A:[0,64,128],I:[0,128,255]},wd={R:[3,64,0,0,255,255,255],G:[0,0,0,255,255,192,3],B:[0,32,48,56,64,96,128],A:[0,8,16,24,32,52,80],I:[0,32,64,96,160,192,255]},xd={min:0,max:0,R:[0,37],G:[242,0],B:[255,255],A:[0,64],I:[0,255]},yd={R:[255,255],G:[255,11],B:[0,0],A:[0,64],I:[0,255]},vd={min:0,max:0,R:[65,10,223,120,216,207,251,93,252,217,21,253,131,165,173,143,144,217,86,89,63,254,172,1,142,107,42,78,221,8,222,71,127,126,167,33,104,2,208,216,0,251,7,105,2,101,248,190,253,62,255,224,166,37,110,138,45,34,6,37,69,201,43,122,199,37,173,194,103,211,75,159,96,4,239,98,110,193,253,166,40,255,48,130,140,243,101,9,177,220,133,32,4,81,48,48,210,109,60,132,1,119,1,159,247,33,212,187,253,144,196,254,168,79,64,196,39,97,73,173,104,216,217,43,101,119,254,5,237,103,203,122,57,87,251,164,19,75,200,2,252,150,66,0,255,157,23,254,55,16,240,161,69,253,207,195,5,60,255,251,200,217,134,123,253,180,27,246,130,136,250,232,4,125,140,22,253,255,13,180,123,61,254,111,10,185,76,192,255,223,186,61,198,5,172,13,83,172,171,6,23,73,134,133,109,61,213,55,57,132,36,209,2,144,1,253,68,155,3,160,2,77,121,70,67,176,223,131,4,162,232,255,150,94,235,191,207,10,246,0,225,4,209,116,57,112,172,253,1,6,92,227,73,62,135,223],G:[162,50,112,245,4,124,176,243,56,125,183,139,182,68,189,4,225,10,20,223,7,46,31,193,225,250,219,41,2,100,83,181,34,150,72,223,168,248,80,253,7,117,214,2,248,10,3,59,179,160,90,244,146,4,207,4,125,255,96,100,1,208,130,51,116,181,236,53,244,5,165,28,181,86,96,42,254,1,134,194,214,92,41,204,137,86,207,3,143,3,100,239,164,94,65,251,131,244,173,57,143,107,217,53,210,0,148,250,45,198,81,40,61,218,252,88,171,0,248,24,248,4,41,100,187,46,208,145,43,168,121,46,175,250,125,107,233,112,207,231,174,215,53,9,43,153,52,124,128,65,210,147,255,147,63,200,148,254,0,179,241,42,239,2,230,8,82,135,87,16,3,87,86,151,254,8,255,86,53,19,7,192,171,201,253,247,197,103,251,126,0,149,54,183,61,126,79,113,10,103,184,75,11,195,222,136,149,131,8,99,240,177,252,255,198,16,7,68,178,66,191,150,73,26,211,109,78,209,240,254,1,166,247,131,2,0,167,127,133,10,43,99,235,3,214,142,176,82,132,38,10,249,255,215,44,81],B:[176,182,248,37,117,35,96,69,32,152,108,20,237,250,2,89,141,216,111,251,211,149,10,44,214,103,31,251,3,32,252,246,97,1,219,167,197,4,36,116,206,118,106,43,205,204,114,69,127,205,87,80,41,251,145,204,253,161,247,1,149,9,43,253,97,72,136,161,171,181,26,255,108,80,218,214,231,255,84,31,109,4,218,3,217,36,68,85,241,39,221,2,240,2,173,42,206,5,110,46,103,27,212,184,2,207,246,45,116,72,110,253,38,105,248,159,243,81,192,93,141,145,24,157,234,131,57,178,62,75,65,176,148,40,253,66,76,240,51,154,17,251,139,253,207,9,114,49,200,254,96,73,138,118,204,102,137,89,145,161,4,112,66,234,147,178,212,205,185,11,203,131,2,250,118,169,1,185,154,53,171,197,61,175,249,96,15,254,95,5,222,75,246,194,2,61,180,25,133,165,15,233,59,35,221,140,109,7,114,255,198,0,115,168,252,23,242,80,75,142,137,255,12,182,68,201,4,111,37,228,83,248,24,192,249,5,54,223,160,122,160,114,145,119,252,31,253,250,10,214,8,47,0,142,222,70],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},bd=class{constructor(){F(this,"gamma",1),F(this,"version",.1),F(this,"cluts",{});const e=Object.keys(Ts).filter(i=>!i.startsWith("$")).sort(new Intl.Collator("en").compare);for(const i of e)this.cluts[i]=Ts[i]}addColormap(t,e){this.cluts[t]=e}colormaps(){return Object.keys(this.cluts)}colorMaps(){return this.colormaps()}colormapFromKey(t){let e=this.cluts[t];return e!==void 0||(e=this.cluts[t.toLowerCase()],e!==void 0)?e:(t.length>0&&U.warn("No color map named "+t),{min:0,max:0,R:[0,255],G:[0,255],B:[0,255],A:[0,255],I:[0,255]})}colormap(t="",e=!1){const i=this.colormapFromKey(t);return this.makeLut(i.R,i.G,i.B,i.A,i.I,e)}makeLabelLut(t,e=255){if(t.R===void 0||t.G===void 0||t.B===void 0)throw new Error(`Invalid colormap table: ${t}`);const i=t.R.length,s=t.I??[...Array(i).keys()];if(i!==t.G.length||i!==t.B.length||i!==s.length)throw new Error(`colormap does not make sense: ${t} Rs ${t.R.length} Gs ${t.G.length} Bs ${t.B.length} Is ${s.length}`);let r=new Uint8ClampedArray(i).fill(e);r[0]=0,t.A!==void 0&&(r=Uint8ClampedArray.from(t.A));const n=Math.min(...s),a=Math.max(...s),o=a-n+1,l=new Uint8ClampedArray(o*4).fill(0);for(let h=0;h<i;h++){let d=(s[h]-n)*4;l[d++]=t.R[h],l[d++]=t.G[h],l[d++]=t.B[h],l[d++]=r[h]}const c={lut:l,min:n,max:a};if(t.labels){const h=t.labels.length;if(h===o)c.labels=t.labels;else if(h===i){c.labels=Array(o).fill("?");for(let d=0;d<i;d++){const f=s[d];c.labels[f]=t.labels[d]}}}return c}async makeLabelLutFromUrl(t){const i=await(await fetch(t)).json();return this.makeLabelLut(i)}makeDrawLut(t){let e=typeof t=="object"?t:Ts[t];e===void 0&&(e={min:0,max:0,R:[0,255,0,0,255,0,255],G:[0,0,255,0,255,255,0],B:[0,0,0,255,0,255,255],A:[0,255,255,255,255,255,255],I:[0,255]});const i=this.makeLabelLut(e,255);if(i.labels===void 0&&(i.labels=[]),i.labels.length<256){const a=i.labels.length;for(let o=a;o<256;o++)i.labels.push(o.toString())}const s=new Uint8ClampedArray(256*4);let r=0;for(let a=0;a<256;a++)s[r++]=255,s[r++]=0,s[r++]=0,s[r++]=255;s[3]=0;const n=Math.min(i.lut.length,256*4);if(n>0)for(let a=0;a<n;a++)s[a]=i.lut[a];return{lut:s,labels:i.labels}}makeLut(t,e,i,s,r,n){const a=t.length,o=[...t],l=[...e],c=[...i];if(!r){r=new Array(a);for(let u=0;u<a;u++)r[u]=u/(a-1)*255}s||(s=new Array(a).fill(64),s[0]=0);let h=Uint8ClampedArray.from(s),d=Uint8ClampedArray.from(r);if(n)for(let u=0;u<a;u++)o[u]=t[a-1-u],l[u]=e[a-1-u],c[u]=i[a-1-u],h[u]=255-s[a-1-u],d[u]=255-r[a-1-u];const f=new Uint8ClampedArray(256*4);if(typeof d>"u"){d=new Uint8ClampedArray(a).fill(0);for(let u=0;u<a;u++)d[u]=Math.round(u*255/(a-1))}typeof h>"u"&&(h=new Uint8ClampedArray(a).fill(64),h[0]=0);for(let u=0;u<a-1;u++){const m=d[u];let g=d[u+1];u===0&&m!==0&&U.warn("colormap issue: indices expected to start with 0 not ",m),u===d.length-2&&g!==255&&(U.warn("padding colormap: indices expected end with 255 not ",g),g=255);const p=g-m;let A=m*4;for(let w=m;w<=g;w++){const x=(w-m)/p;f[A++]=o[u]+x*(o[u+1]-o[u]),f[A++]=l[u]+x*(l[u+1]-l[u]),f[A++]=c[u]+x*(c[u+1]-c[u]),f[A++]=h[u]+x*(h[u+1]-h[u])}}if(this.gamma===1)return f;for(let u=0;u<255*4;u++)u%4!==3&&(f[u]=Math.pow(f[u]/255,1/this.gamma)*255);return f}},ce=new bd,bt=class{static getClusterBoundaryU8(t,e){const i=new Array(t.length).fill(!1),s=new Array(t.length).fill(!1);for(let a=0;a<t.length;a++)t[a]>0&&(s[a]=!0);const r=e.length/3;let n=0;for(let a=0;a<r;a++){const o=e[n],l=e[n+1],c=e[n+2];n+=3,!(s[o]===s[l]&&s[o]===s[c]&&s[l]===s[c])&&(i[o]=!0,i[l]=!0,i[c]=!0)}return i}static async gzip(t){const e=new CompressionStream("gzip"),i=e.writable.getWriter();i.write(t).catch(console.error);const s=i.close().catch(console.error),r=new Response(e.readable),n=new Uint8Array(await r.arrayBuffer());return await s,n}static createMZ3(t,e,i=!1,s=null){const n=s instanceof Uint8Array&&s.length===t.length/3*4,a=n?7:3,o=e.length/3,l=t.length/3,c=0,h=16,d=o*3*4,f=l*3*4,u=h+d+f,m=new ArrayBuffer(u),g=new DataView(m);g.setUint16(0,23117,!0),g.setUint16(2,a,!0),g.setUint32(4,o,!0),g.setUint32(8,l,!0),g.setUint32(12,c,!0);let p=h;if(new Uint32Array(m,p,e.length).set(e),p+=d,new Float32Array(m,p,t.length).set(t),n&&(p+=f,new Uint8Array(m,p,s.length).set(s)),i)throw new Error("Call async createMZ3Async() for compression");return m}static async createMZ3Async(t,e,i=!1,s=null){const r=this.createMZ3(t,e,i,s);return i?await this.gzip(new Uint8Array(r)):r}static createOBJ(t,e){let i="";for(let n=0;n<t.length;n+=3)i+=`v ${t[n]} ${t[n+1]} ${t[n+2]}
`;for(let n=0;n<e.length;n+=3)i+=`f ${e[n]+1} ${e[n+1]+1} ${e[n+2]+1}
`;return new TextEncoder().encode(i).buffer}static createSTL(t,e){const i=e.length/3,s=84+i*50,r=new ArrayBuffer(s),n=new DataView(r);for(let o=0;o<80;o++)n.setUint8(o,0);n.setUint32(80,i,!0);let a=84;for(let o=0;o<e.length;o+=3){const l=e[o]*3,c=e[o+1]*3,h=e[o+2]*3;n.setFloat32(a,0,!0),n.setFloat32(a+4,0,!0),n.setFloat32(a+8,0,!0),a+=12,n.setFloat32(a,t[l],!0),n.setFloat32(a+4,t[l+1],!0),n.setFloat32(a+8,t[l+2],!0),a+=12,n.setFloat32(a,t[c],!0),n.setFloat32(a+4,t[c+1],!0),n.setFloat32(a+8,t[c+2],!0),a+=12,n.setFloat32(a,t[h],!0),n.setFloat32(a+4,t[h+1],!0),n.setFloat32(a+8,t[h+2],!0),a+=12,n.setUint16(a,0,!0),a+=2}return r}static downloadArrayBuffer(t,e){const i=new Blob([t],{type:"application/octet-stream"}),s=URL.createObjectURL(i),r=document.createElement("a");r.href=s,r.download=e,document.body.appendChild(r),r.style.display="none",r.click(),setTimeout(()=>{document.body.removeChild(r),URL.revokeObjectURL(s)},0)}static async saveMesh(t,e,i=".mz3",s=!1){let r=new ArrayBuffer(0);return/\.obj$/i.test(i)?r=this.createOBJ(t,e):/\.stl$/i.test(i)?r=this.createSTL(t,e):(/\.mz3$/i.test(i)||(i+=".mz3"),r=await this.createMZ3Async(t,e,s)),i.length>4&&this.downloadArrayBuffer(r,i),r}static getClusterBoundary(t,e){const i=new Uint32Array(t.buffer),s=new Array(i.length).fill(!1),r=e.length/3;let n=0;for(let a=0;a<r;a++){const o=e[n],l=e[n+1],c=e[n+2];n+=3,!(i[o]===i[l]&&i[o]===i[c]&&i[l]===i[c])&&(s[o]=!0,s[l]=!0,s[c]=!0)}return s}static getExtents(t){if(!ArrayBuffer.isView(t)&&!Array.isArray(t)||t.length<3)return{mxDx:0,extentsMin:0,extentsMax:0};let e=0;const i=H(t[0],t[1],t[2]),s=H(t[0],t[1],t[2]);for(let a=0;a<t.length;a+=3){const o=H(t[a],t[a+1],t[a+2]);e=Math.max(e,Li(o)),un(i,i,o),mn(s,s,o)}const r=[i[0],i[1],i[2]],n=[s[0],s[1],s[2]];return{mxDx:e,extentsMin:r,extentsMax:n}}static generateNormals(t,e){const i=[];let s;const r=t.length;let n,a,o,l,c,h,d,f,u;const m=new Float32Array(r),g=e.length;for(s=0;s<g;s+=3){d=e[s]*3,f=e[s+1]*3,u=e[s+2]*3;const p=[t[d],t[d+1],t[d+2]],A=[t[f],t[f+1],t[f+2]],w=[t[u],t[u+1],t[u+2]];n=A[0]-p[0],a=A[1]-p[1],o=A[2]-p[2],l=w[0]-p[0],c=w[1]-p[1],h=w[2]-p[2],i[0]=c*o-h*a,i[1]=h*n-l*o,i[2]=l*a-c*n,m[d]+=i[0],m[d+1]+=i[1],m[d+2]+=i[2],m[f]+=i[0],m[f+1]+=i[1],m[f+2]+=i[2],m[u]+=i[0],m[u+1]+=i[1],m[u+2]+=i[2]}for(s=0;s<r;s+=3){i[0]=-1*m[s],i[1]=-1*m[s+1],i[2]=-1*m[s+2];let p=i[0]*i[0]+i[1]*i[1]+i[2]*i[2];p>0&&(p=1/Math.sqrt(p),i[0]*=p,i[1]*=p,i[2]*=p),m[s]=i[0],m[s+1]=i[1],m[s+2]=i[2]}return m}},_,Xe,Ms,Qr,Ii,il=class{constructor(t){xi(this,_),xi(this,Xe,0),xi(this,Ms,[]),xi(this,Qr,[]),xi(this,Ii),ti(this,_,new DataView(t)),this.read()}async extract(t){const e=new Uint8Array(J(this,_).buffer.slice(t.startsAt,t.startsAt+t.compressedSize));if(t.compressionMethod===0)return e;if(t.compressionMethod===8){const i=new DecompressionStream("deflate-raw"),s=i.writable.getWriter();s.write(e).catch(console.error);const r=s.close().catch(console.error),n=new Response(i.readable),a=new Uint8Array(await n.arrayBuffer());return await r,a}throw new Error(`Unsupported compression method: ${t.compressionMethod}`)}read(){for(;!J(this,Ii)&&J(this,Xe)<J(this,_).byteLength;){const t=J(this,_).getUint32(J(this,Xe),!0);if(t===67324752){const e=this.readLocalFile(J(this,Xe));e.extract=this.extract.bind(this,e),J(this,Ms).push(e);const i=(e.generalPurpose&8)!==0;if(e.startsAt=J(this,Xe)+30+e.fileNameLength+e.extraLength,e.compressedSize===0&&i){let s=e.startsAt;for(;s+20<=J(this,_).byteLength;){if(J(this,_).getUint32(s,!0)===134695760&&J(this,_).getUint16(s+16,!0)===19280){s+=4;break}s++}e.crc=J(this,_).getUint32(s,!0),e.compressedSize=J(this,_).getUint32(s+4,!0),e.uncompressedSize=J(this,_).getUint32(s+8,!0),ti(this,Xe,s+12)}else ti(this,Xe,e.startsAt+e.compressedSize)}else if(t===33639248){const e=this.readCentralDirectory(J(this,Xe));J(this,Qr).push(e),ti(this,Xe,J(this,Xe)+(46+e.fileNameLength+e.extraLength+e.fileCommentLength))}else if(t===101010256){ti(this,Ii,this.readEndCentralDirectory(J(this,Xe)));break}else if(t===101075792){ti(this,Ii,this.readEndCentralDirectory64(J(this,Xe)));break}else{console.error(`Unexpected ZIP signature 0x${t.toString(16).padStart(8,"0")} at index ${J(this,Xe)}`);break}}}readLocalFile(t){let e=J(this,_).getUint32(t+18,!0),i=J(this,_).getUint32(t+22,!0);const s=J(this,_).getUint16(t+26,!0),r=J(this,_).getUint16(t+28,!0),n=t+30+s;if(this.readString(n,r),e===4294967295&&i===4294967295){let a=n,o=!1;for(;a<n+r-4;){const l=J(this,_).getUint16(a,!0),c=J(this,_).getUint16(a+2,!0);if(a+=4,l===1)if(c>=16){i=Number(J(this,_).getBigUint64(a,!0)),a+=8,e=Number(J(this,_).getBigUint64(a,!0)),o=!0;break}else throw new Error(`ZIP64 extra field found but is too small (expected at least 16 bytes, got ${c}).`);a+=c}if(!o)throw new Error("ZIP64 format missing extra field with signature 0x0001.")}return{signature:this.readString(t,4),version:J(this,_).getUint16(t+4,!0),generalPurpose:J(this,_).getUint16(t+6,!0),compressionMethod:J(this,_).getUint16(t+8,!0),lastModifiedTime:J(this,_).getUint16(t+10,!0),lastModifiedDate:J(this,_).getUint16(t+12,!0),crc:J(this,_).getUint32(t+14,!0),compressedSize:e,uncompressedSize:i,fileNameLength:s,extraLength:r,fileName:this.readString(t+30,s),extra:this.readString(t+30+s,r)}}readCentralDirectory(t){return{versionCreated:J(this,_).getUint16(t+4,!0),versionNeeded:J(this,_).getUint16(t+6,!0),fileNameLength:J(this,_).getUint16(t+28,!0),extraLength:J(this,_).getUint16(t+30,!0),fileCommentLength:J(this,_).getUint16(t+32,!0),diskNumber:J(this,_).getUint16(t+34,!0),internalAttributes:J(this,_).getUint16(t+36,!0),externalAttributes:J(this,_).getUint32(t+38,!0),offset:J(this,_).getUint32(t+42,!0),comments:this.readString(t+46,J(this,_).getUint16(t+32,!0))}}readEndCentralDirectory(t){const e=J(this,_).getUint16(t+20,!0);return{numberOfDisks:J(this,_).getUint16(t+4,!0),centralDirectoryStartDisk:J(this,_).getUint16(t+6,!0),numberCentralDirectoryRecordsOnThisDisk:J(this,_).getUint16(t+8,!0),numberCentralDirectoryRecords:J(this,_).getUint16(t+10,!0),centralDirectorySize:J(this,_).getUint32(t+12,!0),centralDirectoryOffset:J(this,_).getUint32(t+16,!0),commentLength:e,comment:this.readString(t+22,e)}}readEndCentralDirectory64(t){const e=Number(J(this,_).getBigUint64(t+0,!0));return{numberOfDisks:J(this,_).getUint32(t+16,!0),centralDirectoryStartDisk:J(this,_).getUint32(t+20,!0),numberCentralDirectoryRecordsOnThisDisk:Number(J(this,_).getBigUint64(t+24,!0)),numberCentralDirectoryRecords:Number(J(this,_).getBigUint64(t+32,!0)),centralDirectorySize:Number(J(this,_).getBigUint64(t+40,!0)),centralDirectoryOffset:Number(J(this,_).getBigUint64(t+48,!0)),commentLength:e,comment:""}}readString(t,e){return Array.from({length:e},(i,s)=>String.fromCharCode(J(this,_).getUint8(t+s))).join("")}get entries(){return J(this,Ms)}};_=new WeakMap;Xe=new WeakMap;Ms=new WeakMap;Qr=new WeakMap;Ii=new WeakMap;var Z=class oi{static arrayBufferToBase64(e){const i=new Uint8Array(e);return oi.uint8tob64(i)}static async decompress(e){const i=e[0]===31&&e[1]===139&&e[2]===8?"gzip":e[0]===120&&(e[1]===1||e[1]===94||e[1]===156||e[1]===218)?"deflate":"deflate-raw",s=new DecompressionStream(i),r=s.writable.getWriter();r.write(e).catch(console.error);const n=r.close().catch(console.error),a=new Response(s.readable),o=new Uint8Array(await a.arrayBuffer());return await n,o}static async decompressToBuffer(e){const i=await oi.decompress(e);return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}static async readMatV4(e,i=!1){let s=e.byteLength;if(s<40)throw new Error("File too small to be MAT v4: bytes = "+e.byteLength);let r=new DataView(e),n=r.getUint16(0,!0),a=e;if(n===35615||n===8075){const m=await this.decompress(new Uint8Array(e));r=new DataView(m.buffer),n=r.getUint16(0,!0),a=m.buffer,s=a.byteLength}const o=new TextDecoder("utf-8"),l=new Uint8Array(a);let c=0;const h={};function d(m){return Math.floor(m/10)%10}function f(m,g,p){const A=new Uint8Array(l.subarray(g,p));return m===1?new Float32Array(A.buffer):m===2?new Int32Array(A.buffer):m===3?new Int16Array(A.buffer):m===4?new Uint16Array(A.buffer):m===5?new Uint8Array(A.buffer):new Float64Array(A.buffer)}function u(){const m=r.getUint32(c,!0),g=r.getUint32(c+4,!0),p=r.getUint32(c+8,!0),A=r.getUint32(c+12,!0),w=r.getUint32(c+16,!0);if(c+=20,A!==0)throw new Error("Matlab V4 reader does not support imaginary numbers");const x=g*p;if(x<1)throw new Error("mrows * ncols must be greater than one");const y=new Uint8Array(l.subarray(c,c+w));let v=o.decode(y).trim().replaceAll("\0","");i&&(v=v.replaceAll(".","_"));const D=d(m);let b=8;if(D>=1&&D<=2)b=4;else if(D>=3&&D<=4)b=2;else if(D===5)b=1;else if(D!==0)throw new Error("impossible Matlab v4 datatype");if(c+=w,m>50)throw new Error("Does not appear to be little-endian V4 Matlab file");const C=c+x*b;h[v]=f(D,c,C),c=C}for(;c+20<s;)u();return h}static b64toUint8(e){const i=atob(e),s=i.length,r=new Uint8Array(s);for(let n=0;n<s;n++)r[n]=i.charCodeAt(n);return r}static uint8tob64(e){let i="";const s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=e.byteLength,n=r%3,a=r-n;let o,l,c,h,d;for(let f=0;f<a;f=f+3)d=e[f]<<16|e[f+1]<<8|e[f+2],o=(d&16515072)>>18,l=(d&258048)>>12,c=(d&4032)>>6,h=d&63,i+=s[o]+s[l]+s[c]+s[h];return n===1?(d=e[a],o=(d&252)>>2,l=(d&3)<<4,i+=s[o]+s[l]+"=="):n===2&&(d=e[a]<<8|e[a+1],o=(d&64512)>>10,l=(d&1008)>>4,c=(d&15)<<2,i+=s[o]+s[l]+s[c]+"="),i}static download(e,i,s){const r=document.createElement("a"),n=Array.isArray(e)?e:[e],a=new Blob(n,{type:s});r.href=URL.createObjectURL(a),r.download=i,r.click()}static readFileAsync(e){return new Promise((i,s)=>{const r=new FileReader;r.onload=()=>{i(r.result)},r.onerror=s,r.readAsArrayBuffer(e)})}static blobToBase64(e){return new Promise(i=>{const s=new FileReader;s.onloadend=()=>i(s.result),s.readAsDataURL(e)})}static async decompressBase64String(e){const i=atob(e),s=new ArrayBuffer(i.length),r=new Uint8Array(s);for(let n=0;n<i.length;n++)r[n]=i.charCodeAt(n);return oi.decompressArrayBuffer(r)}static async compressToBase64String(e){const i=await oi.compressStringToArrayBuffer(e);return oi.uint8tob64(new Uint8Array(i))}static strToU8(e,i){if(i){const l=new Uint8Array(e.length);for(let c=0;c<e.length;++c)l[c]=e.charCodeAt(c);return l}const s=e.length,r=(l,c,h)=>((h==null||h>l.length)&&(h=l.length),new Uint8Array(l.subarray(c,h)));let n=new Uint8Array(e.length+(e.length>>1)),a=0;const o=l=>{n[a++]=l};for(let l=0;l<s;++l){if(a+5>n.length){const h=new Uint8Array(a+8+(s-l<<1));h.set(n),n=h}let c=e.charCodeAt(l);c<128||i?o(c):c<2048?(o(192|c>>6),o(128|c&63)):(c>55295&&c<57344,c=65536+(c&1047552)|e.charCodeAt(++l)&1023,o(240|c>>18),o(128|c>>12&63),o(128|c>>6&63),o(128|c&63))}return r(n,0,a)}static async compress(e,i="gzip"){const s=new CompressionStream(i),r=s.writable.getWriter();r.write(e).catch(console.error);const n=r.close().catch(console.error),o=await new Response(s.readable).arrayBuffer();return await n,o}static async compressStringToArrayBuffer(e){const i=this.strToU8(e);return await this.compress(i)}static isArrayBufferCompressed(e){if(e&&e.byteLength){const i=new Uint8Array(e);return(i[0]<<8|i[1])===8075}else return!1}static strFromU8(e,i){if(i){let s="";for(let r=0;r<e.length;r+=16384)s+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return s}else{const s=(o,l,c)=>((l==null||l<0)&&(l=0),(c==null||c>o.length)&&(c=o.length),new Uint8Array(o.subarray(l,c))),r=o=>{for(let l="",c=0;;){let h=o[c++];const d=(h>127)+(h>223)+(h>239);if(c+d>o.length)return{s:l,r:s(o,c-1)};d?d===3?(h=((h&15)<<18|(o[c++]&63)<<12|(o[c++]&63)<<6|o[c++]&63)-65536,l+=String.fromCharCode(55296|h>>10,56320|h&1023)):d&1?l+=String.fromCharCode((h&31)<<6|o[c++]&63):l+=String.fromCharCode((h&15)<<12|(o[c++]&63)<<6|o[c++]&63):l+=String.fromCharCode(h)}},{s:n,r:a}=r(e);if(a.length)throw new Error("Unexpected trailing bytes in UTF-8 decoding");return n}}static async decompressArrayBuffer(e){const i=await this.decompress(new Uint8Array(e));return this.strFromU8(i)}static arraysAreEqual(e,i){return Pc(e,i)}static range(e,i,s){return Array.from({length:(i-e)/s+1},(r,n)=>e+n*s)}static sph2cartDeg(e,i){const s=-i*(Math.PI/180),r=(e-90)%360*(Math.PI/180),n=[Math.cos(s)*Math.cos(r),Math.cos(s)*Math.sin(r),Math.sin(s)],a=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);return a<=0||(n[0]/=a,n[1]/=a,n[2]/=a),n}static vox2mm(e,i){const s=be(i);rt(s,s);const r=ue(e[0],e[1],e[2],1);return Ve(r,r,s),H(r[0],r[1],r[2])}},vi=U,Ae=class Ue{static readTRACT(e){const i=e.byteLength;if(i<20)throw new Error("File too small to be niml.tract: bytes = "+i);const s=new DataView(e),r=new Uint8Array(e);let n=0;function a(){for(;n<i&&r[n]!==60;)n++;const g=n;for(;n<i&&r[n]!==62;)n++;return n++,n-g<1?"":new TextDecoder().decode(e.slice(g,n-1)).trim()}let o=a();function l(g){const p=o.indexOf(g);if(p<0)return 0;const A=o.indexOf('"',p)+1,w=o.indexOf('"',A),x=o.slice(A,w);return parseInt(x)}const c=l("N_tracts=");(!o.startsWith("<network")||c<1)&&U.warn("This is not a valid niml.tract file "+o);let h=0;const d=[];d.push(h);const f=[],u=[];for(let g=0;g<c;g++){o=a();const p=l("ni_dimen="),A=l("Bundle_Tag="),w=o.includes("binary.lsbfirst");for(let x=0;x<p;x++){n+=4;const y=s.getUint32(n,w)/3;n+=4;for(let v=0;v<y;v++)f.push(s.getFloat32(n,w)),n+=4,f.push(-s.getFloat32(n,w)),n+=4,f.push(s.getFloat32(n,w)),n+=4;h+=y,d.push(h),u.push(A)}o=a()}const m=[];return m.push({id:"tract",vals:Float32Array.from(u)}),{pts:new Float32Array(f),offsetPt0:new Uint32Array(d),dps:m}}static async readTT(e){let i=new Uint32Array(0),s=new Float32Array(0);const r=await Z.readMatV4(e);if(!("trans_to_mni"in r))throw new Error("TT format file must have 'trans_to_mni'");if(!("voxel_size"in r))throw new Error("TT format file must have 'voxel_size'");if(!("track"in r))throw new Error("TT format file must have 'track'");let n=se();const a=r.trans_to_mni;n=nt(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]),rt(n,n);function o(l){const c=new DataView(l.buffer),h=[];let d=0,f=0;for(;f<l.length;){h.push(f);const g=c.getUint32(f,!0);f=f+g+13,d+=g}i=new Uint32Array(h.length+1),s=new Float32Array(d);let u=0;for(let g=0;g<h.length;g++){i[g]=u/3;let p=h[g];const A=c.getUint32(p,!0)/3;let w=c.getInt32(p+4,!0),x=c.getInt32(p+8,!0),y=c.getInt32(p+12,!0);p+=16,s[u++]=w,s[u++]=x,s[u++]=y;for(let v=2;v<=A;v++)w=w+c.getInt8(p++),x=x+c.getInt8(p++),y=y+c.getInt8(p++),s[u++]=w,s[u++]=x,s[u++]=y}for(let g=0;g<u;g++)s[g]=s[g]/32;let m=0;for(let g=0;g<u/3;g++){const p=ue(s[m],s[m+1],s[m+2],1);Ve(p,p,n),s[m++]=p[0],s[m++]=p[1],s[m++]=p[2]}i[h.length]=u/3}return o(r.track),{pts:s,offsetPt0:i}}static async readTRX(e){function i(u){const m=(u&31744)>>10,g=u&1023;return(u>>15?-1:1)*(m?m===31?g?NaN:1/0:Math.pow(2,m-15)*(1+g/1024):6103515625e-14*(g/1024))}let s=0,r=0,n=new Float32Array([]);const a=[],o=[],l=[],c=[];let h=[],d=!1;const f=new il(e);for(let u=0;u<f.entries.length;u++){const m=f.entries[u];if(m.uncompressedSize===0)continue;const g=m.fileName.split("/"),p=g.slice(-1)[0];if(p.startsWith("."))continue;const A=g.slice(-2)[0],w=p.split(".")[0],x=await m.extract();if(p.includes("header.json")){const D=new TextDecoder().decode(x);h=JSON.parse(D);continue}let y=0,v=[];if(p.endsWith(".uint64")||p.endsWith(".int64")){y=x.length/8,v=new Uint32Array(y);const D=new Uint32Array(x.buffer);let b=0;for(let C=0;C<y;C++)v[C]=D[b],D[b+1]!==0&&(d=!0),b+=2}else if(p.endsWith(".uint32"))v=new Uint32Array(x.buffer);else if(p.endsWith(".uint16"))v=new Uint16Array(x.buffer);else if(p.endsWith(".uint8"))v=new Uint8Array(x.buffer);else if(p.endsWith(".int32"))v=new Int32Array(x.buffer);else if(p.endsWith(".int16"))v=new Int16Array(x.buffer);else if(p.endsWith(".int8"))v=new Int8Array(x.buffer);else if(p.endsWith(".float64"))v=new Float64Array(x.buffer);else if(p.endsWith(".float32"))v=new Float32Array(x.buffer);else if(p.endsWith(".float16")){y=x.length/2,v=new Float32Array(y);const D=new Uint16Array(x.buffer),b=new Float32Array(65536);for(let C=0;C<65536;C++)b[C]=i(C);for(let C=0;C<y;C++)v[C]=b[D[C]]}else continue;if(y=v.length,A.includes("groups")){o.push({id:w,vals:Float32Array.from(v.slice())});continue}if(A.includes("dpv")){c.push({id:w,vals:Float32Array.from(v.slice())});continue}if(A.includes("dps")){l.push({id:w,vals:Float32Array.from(v.slice())});continue}if(p.startsWith("offsets.")){s=y;for(let D=0;D<y;D++)a[D]=v[D]}p.startsWith("positions.3.")&&(r=y,n=new Float32Array(v))}if(s===0||r===0)throw new Error("Failure reading TRX format (no offsets or points).");if(d)throw new Error("Too many vertices: JavaScript does not support 64 bit integers");return a[s]=r/3,{pts:n,offsetPt0:new Uint32Array(a),dpg:o,dps:l,dpv:c,header:h}}static readTSF(e,i=0){const s=new Float32Array(i),r=e.byteLength;if(r<20)throw new Error("File too small to be TSF: bytes = "+r);const n=new Uint8Array(e);let a=0;function o(){for(;a<r&&n[a]===10;)a++;const f=a;for(;a<r&&n[a]!==10;)a++;return a++,a-f<1?"":new TextDecoder().decode(e.slice(f,a-1))}let l=o();if(!l.includes("mrtrix track scalars"))throw new Error("Not a valid TSF file");let c=-1;for(;a<r&&!l.includes("END");)if(l=o(),l.toLowerCase().startsWith("file:")&&(c=parseInt(l.split(" ").pop())),l.toLowerCase().startsWith("datatype:")&&!l.endsWith("Float32LE"))throw new Error("Only supports TSF files with Float32LE");if(c<20)throw new Error("Not a valid TSF file (missing file offset)");a=c;const h=new DataView(e);let d=0;for(;a+4<=r&&d<i;){const f=h.getFloat32(a,!0);if(a+=4,isFinite(f))s[d++]=f;else if(!isNaN(f))break}return s}static readTCK(e){const i=e.byteLength;if(i<20)throw new Error("File too small to be TCK: bytes = "+i);const s=new Uint8Array(e);let r=0;function n(){for(;r<i&&s[r]===10;)r++;const m=r;for(;r<i&&s[r]!==10;)r++;return r++,r-m<1?"":new TextDecoder().decode(e.slice(m,r-1))}let a=n();if(!a.includes("mrtrix tracks"))throw new Error("Not a valid TCK file");let o=-1;for(;r<i&&!a.includes("END");)a=n(),a.toLowerCase().startsWith("file:")&&(o=parseInt(a.split(" ").pop()));if(o<20)throw new Error("Not a valid TCK file (missing file offset)");r=o;const l=new DataView(e);let c=0,h=new Uint32Array(i/(4*4)),d=0,f=0,u=new Float32Array(i/4);for(h[0]=0;r+12<i;){const m=l.getFloat32(r,!0);r+=4;const g=l.getFloat32(r,!0);r+=4;const p=l.getFloat32(r,!0);if(r+=4,isFinite(m))u[f++]=m,u[f++]=g,u[f++]=p,c++;else if(h[d++]=c,!isNaN(m))break}return u=u.slice(0,f),h=h.slice(0,d),{pts:u,offsetPt0:h}}static async readTRK(e){let i=new DataView(e),s=i.getUint32(0,!0);if(s!==1128354388){let T;if(s===4247762216)throw new Error("zstd TRK decompression is not supported");T=await Z.decompress(new Uint8Array(e)),e=T.buffer,i=new DataView(e),s=i.getUint32(0,!0)}const r=i.getUint32(992,!0),n=i.getUint32(996,!0);if(r>2||n!==1e3||s!==1128354388)throw new Error("Not a valid TRK file");const a=i.getInt16(36,!0),o=[];for(let T=0;T<a;T++){const S=new Uint8Array(e.slice(38+T*20,58+T*20)),E=new TextDecoder().decode(S).split("\0").shift();o.push({id:E.trim(),vals:[]})}const l=i.getFloat32(12,!0),c=i.getFloat32(16,!0),h=i.getFloat32(20,!0),d=nt(1/l,0,0,-.5,0,1/c,0,-.5,0,0,1/h,-.5,0,0,0,1),f=i.getInt16(238,!0),u=[];for(let T=0;T<f;T++){const S=new Uint8Array(e.slice(240+T*20,260+T*20)),E=new TextDecoder().decode(S).split("\0").shift();u.push({id:E.trim(),vals:[]})}const m=se();for(let T=0;T<16;T++)m[T]=i.getFloat32(440+T*4,!0);m[15]===0&&(U.warn("TRK vox_to_ras not set"),To(m));const g=se();Mo(g,d,m);let p=null,A=null;p=new Int32Array(e.slice(n)),A=new Float32Array(p.buffer);const w=p.length;if(w<1)throw new Error("Empty TRK file.");let x=0,y=0,v=new Uint32Array(p.length/4),D=0,b=new Float32Array(p.length),C=0;for(;x<w;){const T=p[x];x=x+1,v[D++]=y;for(let S=0;S<T;S++){const E=A[x+0],B=A[x+1],P=A[x+2];if(x+=3,b[C++]=E*g[0]+B*g[1]+P*g[2]+g[3],b[C++]=E*g[4]+B*g[5]+P*g[6]+g[7],b[C++]=E*g[8]+B*g[9]+P*g[10]+g[11],a>0)for(let V=0;V<a;V++)o[V].vals.push(A[x]),x++;y++}if(f>0)for(let S=0;S<f;S++)u[S].vals.push(A[x]),x++}const I=[];for(let T=0;T<u.length;T++)I.push({id:u[T].id,vals:Float32Array.from(u[T].vals)});const M=[];for(let T=0;T<o.length;T++)M.push({id:o[T].id,vals:Float32Array.from(o[T].vals)});return v[D++]=y,b=b.slice(0,C),v=v.slice(0,D),{pts:b,offsetPt0:v,dps:I,dpv:M}}static readTxtVTK(e){const r=new TextDecoder("utf-8").decode(e).split(`
`);if(r.length<7||!r[0].startsWith("# vtk DataFile"))throw new Error("Invalid VTK image");if(!r[2].startsWith("ASCII"))throw new Error("Not ASCII VTK mesh");let a=3;for(;r[a].length<1;)a++;if(!r[a].includes("POLYDATA"))throw new Error("Not ASCII VTK polydata");for(a++;r[a].length<1;)a++;if(!r[a].startsWith("POINTS"))throw new Error("Not VTK POINTS");let o=r[a].trim().split(/\s+/);const l=parseInt(o[1]),c=l*3,h=new Float32Array(l*3);let d=0;for(;d<l*3;){a++;const g=r[a].trim().trim().split(/\s+/);for(let p=0;p<g.length&&!(d>=c);p++)h[d]=parseFloat(g[p]),d++}const f=[];for(a++;r[a].length<1;)a++;if(r[a].startsWith("METADATA")){for(;r[a].length>1;)a++;a++}if(o=r[a].trim().split(/\s+/),a++,o[0].includes("LINES")){const m=parseInt(o[1]);if(m<1)throw new Error("Corrupted VTK ASCII");let g=r[a].trim();const p=[];let A=[];if(g.startsWith("OFFSETS")){a++;let w=0;for(;w<m;){g=r[a].trim(),a++;const x=g.trim().split(/\s+/);for(let y=0;y<x.length&&(p[w]=parseInt(x[y]),w++,!(w>=m));y++);}A=Array.from(h)}else{let w=function(){g=r[a].trim();const D=g.trim().split(/\s+/);y=[];for(let b=0;b<D.length;b++)y.push(parseInt(D[b]));v=0,a++},x=0;p[0]=0;let y=[],v=0;w();for(let D=0;D<m;D++){v>=y.length&&w();const b=y[v++];x+=b,p[D+1]=x;for(let C=0;C<b;C++){v>=y.length&&w();const I=y[v++]*3;A.push(h[I+0]),A.push(h[I+1]),A.push(h[I+2])}}}return{pts:Float32Array.from(A),offsetPt0:Uint32Array.from(p)}}else if(o[0].includes("TRIANGLE_STRIPS")){const m=parseInt(o[1]);for(let g=0;g<m;g++){const p=r[a].trim();a++;const A=p.trim().split(/\s+/),w=parseInt(A[0])-2;let x=1;for(let y=0;y<w;y++)y%2?(f.push(parseInt(A[x+2])),f.push(parseInt(A[x+1])),f.push(parseInt(A[x]))):(f.push(parseInt(A[x])),f.push(parseInt(A[x+1])),f.push(parseInt(A[x+2]))),x+=1}}else if(o[0].includes("POLYGONS")){const m=parseInt(o[1]);for(let g=0;g<m;g++){const p=r[a].trim();a++;const A=p.trim().split(/\s+/),w=parseInt(A[0])-2,x=parseInt(A[1]);let y=parseInt(A[2]);for(let v=0;v<w;v++){const D=parseInt(A[3+v]);f.push(x),f.push(y),f.push(D),y=D}}}else throw new Error("Unsupported ASCII VTK datatype "+o[0]);const u=new Uint32Array(f);return{positions:h,indices:u}}static async readLayer(e="",i,s,r=.5,n="warm",a="winter",o=!1,l=null,c=null,h=0){const d={...Rd,colormapInvert:!1,colormapType:0,isTransparentBelowCalMin:!0,isAdditiveBlend:!1,colorbarVisible:!0,colormapLabel:null},f=/(?:\.([^.]+))?$/;let u=f.exec(e)[1];u=u.toUpperCase(),u==="GZ"&&(u=f.exec(e.slice(0,-3))[1],u=u.toUpperCase());const m=s.vertexCount/3;if(s.offsetPt0){if(u!=="TSF")throw new Error("readLayer for streamlines only supports TSF files.");const A=s.pts.length/3,w=e.split("/");let x="Unknown";w.length>1&&w.pop()&&(x=x.split(".").slice(0,-1).join("."));const y=Ue.readTSF(i,A);s.dpv||(s.dpv=[]);const v=y.reduce((b,C)=>Math.min(b,C)),D=y.reduce((b,C)=>Math.max(b,C));return s.dpv.push({id:x,vals:Float32Array.from(y.slice()),global_min:v,global_max:D,cal_min:v,cal_max:D}),d}if(m<3){U.error("n_vert < 3 in layer");return}if(u==="MZ3"){const A=await Ue.readMZ3(i,m);d.values=A.scalars,"colormapLabel"in A&&(d.colormapLabel=A.colormapLabel)}else if(u==="ANNOT"){const A=Ue.readANNOT(i,m,!0);A instanceof Uint32Array?d.values=A:(d.values=A.scalars,d.colormapLabel=A.colormapLabel)}else if(u==="CRV"||u==="CURV"||u==="THICKNESS"||u==="AREA")d.values=Ue.readCURV(i,m),d.isTransparentBelowCalMin=!1;else if(u==="GII"){const A=await Ue.readGII(i,m);d.values=A.scalars,d.colormapLabel=A.colormapLabel}else if(u==="MGH"||u==="MGZ"){const A=await Ue.readMGH(i,m,!0);"scalars"in A?(d.values=A.scalars,d.colormapLabel=A.colormapLabel):d.values=A}else if(u==="NII")d.values=await Ue.readNII(i,m,s.anatomicalStructurePrimary);else if(u==="SMP")d.values=await Ue.readSMP(i,m);else if(u==="STC")d.values=Ue.readSTC(i,m);else if(Ue.isCurv(i))d.values=Ue.readCURV(i,m),d.isTransparentBelowCalMin=!1;else return U.warn("Unknown layer overlay format "+e),d;if(!d.values){U.error("no values in layer");return}d.nFrame4D=d.values.length/m,d.frame4D=0,d.outlineBorder=h;let g=d.values[0],p=d.values[0];for(let A=0;A<d.values.length;A++)g=Math.min(g,d.values[A]),p=Math.max(p,d.values[A]);return d.global_min=g,d.global_max=p,d.cal_min=l||0,l||(d.cal_min=g),d.cal_max=c||0,c||(d.cal_max=p),d.cal_minNeg=NaN,d.cal_maxNeg=NaN,d.opacity=r,d.colormap=n,d.colormapNegative=a,d.useNegativeCmap=o,d}static async readSMP(e,i){const s=e.byteLength;let r=new DataView(e),n=r.getUint16(0,!0);if(n>5){const d=await Z.decompress(new Uint8Array(e));r=new DataView(d.buffer),n=r.getUint16(0,!0),e=d.buffer}n>5&&U.error("Unsupported or invalid BrainVoyager SMP version "+n);const a=r.getUint32(2,!0);a!==i&&U.error("SMP file has "+a+" vertices, background mesh has "+i);const o=r.getUint16(6,!0),l=new Float32Array(a*o);let c=9;function h(){const d=c;for(;c<s&&r.getUint8(c)!==0;)c++;return c++,new TextDecoder().decode(e.slice(d,c-1))}h();for(let d=0;d<o;d++){const f={};f.mapType=r.getUint32(c,!0),c+=4,n>=3&&f.mapType===3&&(f.nLags=r.getUint32(c,!0),c+=4,f.mnLag=r.getUint32(c,!0),c+=4,f.mxLag=r.getUint32(c,!0),c+=4,f.ccOverlay=r.getUint32(c,!0),c+=4),f.clusterSize=r.getUint32(c,!0),c+=4,f.clusterCheck=r.getUint8(c),c+=1,f.critThresh=r.getFloat32(c,!0),c+=4,f.maxThresh=r.getFloat32(c,!0),c+=4,n>=4&&(f.includeValuesGreaterThreshMax=r.getUint32(c,!0),c+=4),f.df1=r.getUint32(c,!0),c+=4,f.df2=r.getUint32(c,!0),c+=4,n>=5?(f.posNegFlag=r.getUint32(c,!0),c+=4):f.posNegFlag=3,f.cortexBonferroni=r.getUint32(c,!0),c+=4,f.posMinRGB=[0,0,0],f.posMaxRGB=[0,0,0],f.negMinRGB=[0,0,0],f.negMaxRGB=[0,0,0],n>=2&&(f.posMinRGB[0]=r.getUint8(c),c++,f.posMinRGB[1]=r.getUint8(c),c++,f.posMinRGB[2]=r.getUint8(c),c++,f.posMaxRGB[0]=r.getUint8(c),c++,f.posMaxRGB[1]=r.getUint8(c),c++,f.posMaxRGB[2]=r.getUint8(c),c++,n>=4&&(f.negMinRGB[0]=r.getUint8(c),c++,f.negMinRGB[1]=r.getUint8(c),c++,f.negMinRGB[2]=r.getUint8(c),c++,f.negMaxRGB[0]=r.getUint8(c),c++,f.negMaxRGB[1]=r.getUint8(c),c++,f.negMaxRGB[2]=r.getUint8(c),c++),f.enableSMPColor=r.getUint8(c),c++,n>=4&&(f.lut=h()),f.colorAlpha=r.getFloat32(c,!0),c+=4),f.name=h();const u=new Float32Array(e,c,a);l.set(u,d*a),c+=a*4}return l}static readSTC(e,i){const s=new DataView(e),r=s.getInt32(8,!1);if(r!==i)throw new Error("Overlay has "+r+" vertices, expected "+i);let n=12+r*4;const a=s.getUint32(n,!1);n+=4;const o=new Float32Array(a*r);for(let l=0;l<a*r;l++)o[l]=s.getFloat32(n,!1),n+=4;return o}static isCurv(e){const i=new DataView(e),s=i.getUint8(0),r=i.getUint8(1),n=i.getUint8(2);return s!==255||r!==255||n!==255?(vi.debug("Unable to recognize file type: does not appear to be FreeSurfer format."),!1):!0}static readCURV(e,i){const s=new DataView(e),r=s.getUint8(0),n=s.getUint8(1),a=s.getUint8(2),o=s.getUint32(3,!1),l=s.getUint32(11,!1);if((r!==255||n!==255||a!==255)&&vi.debug("Unable to recognize file type: does not appear to be FreeSurfer format."),i!==o)throw new Error("CURV file has different number of vertices ( "+o+")than mesh ("+i+")");if(e.byteLength<15+4*o*l)throw new Error("CURV file smaller than specified");const c=new Float32Array(l*o);let h=15;for(let m=0;m<l*o;m++)c[m]=s.getFloat32(h,!1),h+=4;let d=c[0],f=c[0];for(let m=0;m<c.length;m++)d=Math.min(d,c[m]),f=Math.max(f,c[m]);const u=1/(f-d);for(let m=0;m<c.length;m++)c[m]=1-(c[m]-d)*u;return c}static readANNOT(e,i,s=!1){const r=new DataView(e),n=r.getUint32(0,!1),a=this.decimateLayerVertices(n,i);if(i!==a)throw new Error("ANNOT file has different number of vertices than mesh");if(e.byteLength<4+8*n)throw new Error("ANNOT file smaller than specified");let o=0;const l=new Uint32Array(n);for(let x=0;x<n;x++){const y=r.getUint32(o+=4,!1);l[y]=r.getUint32(o+=4,!1)}if(!s)return l;let c=0;try{c=r.getInt32(o+=4,!1)}catch{return l}if(c!==1||r.getInt32(o+=4,!1)>0)return l;const f=r.getInt32(o+=4,!1),u=r.getInt32(o+=4,!1);o+=u;const m=r.getInt32(o+=4,!1);if(m<1)return l;const g={R:Array(f).fill(0),G:Array(f).fill(0),B:Array(f).fill(0),A:Array(f).fill(0),I:Array(f).fill(0),labels:Array(f).fill("")};for(let x=0;x<m;x++){const y=r.getInt32(o+=4,!1),v=r.getInt32(o+=4,!1);o+=4;let D="";for(let T=0;T<v;T++){const S=r.getUint8(o++);if(S===0)break;D+=String.fromCharCode(S)}o-=4;const b=r.getInt32(o+=4,!1),C=r.getInt32(o+=4,!1),I=r.getInt32(o+=4,!1),M=r.getInt32(o+=4,!1);if(y<0||y>=f){U.warn("annot entry out of range");continue}g.R[y]=b,g.G[y]=C,g.B[y]=I,g.A[y]=M,g.I[y]=(M<<24)+(I<<16)+(C<<8)+b,g.labels[y]=D}const p=new Float32Array(n);p.fill(-1);let A=0;for(let x=0;x<i;x++){const y=l[x];for(let v=0;v<f;v++)if(g.I[v]===y){p[x]=v;break}p[x]<0&&(A++,p[x]=0)}A>0&&U.error(`annot vertex colors do not match ${A} of ${n} vertices.`);for(let x=0;x<f;x++)g.I[x]=x;const w=ce.makeLabelLut(g);return{scalars:p,colormapLabel:w}}static readNV(e){const i=e.byteLength,s=new Uint8Array(e);let r=0;function n(){for(;r<i&&s[r]===10;)r++;const f=r;for(;r<i&&s[r]!==10;)r++;return r++,r-f<1?"":new TextDecoder().decode(e.slice(f,r-1))}let a=0,o=0,l=0,c=0,h,d;for(;r<i;){const f=n();if(f.startsWith("#"))continue;const u=f.trim().split(/\s+/);if(a<1){a=parseInt(u[0]),h=new Float32Array(a*3);continue}if(l<a*3){h[l]=parseFloat(u[0]),h[l+1]=parseFloat(u[1]),h[l+2]=parseFloat(u[2]),l+=3;continue}if(o<1){o=parseInt(u[0]),d=new Uint32Array(o*3);continue}if(c>=o*3)break;d[c+2]=parseInt(u[0])-1,d[c+1]=parseInt(u[1])-1,d[c+0]=parseInt(u[2])-1,c+=3}return{positions:h,indices:d}}static readASC(e){const i=e.byteLength,s=new Uint8Array(e);let r=0;function n(){for(;r<i&&s[r]===10;)r++;const u=r;for(;r<i&&s[r]!==10;)r++;return r++,r-u<1?"":new TextDecoder().decode(e.slice(u,r-1))}let a=n();a.startsWith("#!ascii")||U.warn("Invalid ASC mesh"),a=n();let o=a.trim().split(/\s+/);const l=parseInt(o[0]),c=parseInt(o[1]),h=new Float32Array(l*3);let d=0;for(let u=0;u<l;u++)a=n(),o=a.trim().split(/\s+/),h[d]=parseFloat(o[0]),h[d+1]=parseFloat(o[1]),h[d+2]=parseFloat(o[2]),d+=3;const f=new Uint32Array(c*3);d=0;for(let u=0;u<c;u++)a=n(),o=a.trim().split(/\s+/),f[d]=parseInt(o[0]),f[d+1]=parseInt(o[1]),f[d+2]=parseInt(o[2]),d+=3;return{positions:h,indices:f}}static readVTK(e){const i=e.byteLength;if(i<20)throw new Error("File too small to be VTK: bytes = "+e.byteLength);const s=new Uint8Array(e);let r=0;function n(g=!0){if(g)for(;r<i&&s[r]===10;)r++;const p=r;for(;r<i&&s[r]!==10;)r++;return r++,r-p<1?"":new TextDecoder().decode(e.slice(p,r-1))}let a=n();if(!a.startsWith("# vtk DataFile"))throw new Error("Invalid VTK mesh");if(a=n(!1),a=n(),a.startsWith("ASCII"))return Ue.readTxtVTK(e);if(!a.startsWith("BINARY"))throw new Error("Invalid VTK image, expected ASCII or BINARY "+a);if(a=n(),!a.includes("POLYDATA"))throw new Error("Only able to read VTK POLYDATA "+a);a=n(),(!a.includes("POINTS")||!a.includes("double")&&!a.includes("float"))&&U.warn("Only able to read VTK float or double POINTS"+a);const o=a.includes("double");let l=a.trim().split(/\s+/);const h=parseInt(l[1])*3,d=new Float32Array(h),f=new DataView(e);if(o)for(let g=0;g<h;g++)d[g]=f.getFloat64(r,!1),r+=8;else for(let g=0;g<h;g++)d[g]=f.getFloat32(r,!1),r+=4;a=n(),l=a.trim().split(/\s+/);const u=[];if(l[0].includes("LINES")){const g=parseInt(l[1]),p=r;if(a=n(),a.startsWith("OFFSETS")){let y=!1;a.includes("int64")&&(y=!0);const v=new Uint32Array(g);if(y){let b=!1;for(let C=0;C<g;C++){let I=f.getInt32(r,!1);I!==0&&(b=!0),r+=4,I=f.getInt32(r,!1),r+=4,v[C]=I}b&&U.warn("int32 overflow: JavaScript does not support int64")}else for(let b=0;b<g;b++){const C=f.getInt32(r,!1);r+=4,v[b]=C}return{pts:d,offsetPt0:v}}r=p;let A=0;const w=[],x=[];w.push(A);for(let y=0;y<g;y++){const v=f.getInt32(r,!1);r+=4,A+=v,w.push(A);for(let D=0;D<v;D++){const b=f.getInt32(r,!1)*3;r+=4,x.push(d[b+0]),x.push(d[b+1]),x.push(d[b+2])}}return{pts:Float32Array.from(x),offsetPt0:Uint32Array.from(w)}}else if(l[0].includes("TRIANGLE_STRIPS")){const g=parseInt(l[1]);for(let p=0;p<g;p++){const A=f.getInt32(r,!1)-2;r+=4;for(let w=0;w<A;w++)w%2?(u.push(f.getInt32(r+8,!1)),u.push(f.getInt32(r+4,!1)),u.push(f.getInt32(r,!1))):(u.push(f.getInt32(r,!1)),u.push(f.getInt32(r+4,!1)),u.push(f.getInt32(r+8,!1))),r+=4;r+=8}}else if(l[0].includes("POLYGONS")){const g=parseInt(l[1]),p=r,A=n();if(A.startsWith("OFFSETS")){let w=A.includes("int64");const x=new Uint32Array(g);let y=!1;for(let C=0;C<g;C++)w&&(f.getInt32(r,!1)!==0&&(y=!0),r+=4),x[C]=f.getInt32(r,!1),r+=4;if(!Number.isSafeInteger(g)||g>=2147483648||y)throw new Error("values exceed 2GB limit");const v=n();if(!v.startsWith("CONNECTIVITY"))throw new Error("Expected CONNECTIVITY after OFFSETS");w=v.includes("int64");const D=x[g-1],b=new Uint32Array(D);for(let C=0;C<D;C++)w&&(r+=4),b[C]=f.getInt32(r,!1),r+=4;for(let C=0;C<g;C++){const I=C===0?0:x[C-1],M=x[C];for(let T=1;T<M-I-1;T++)u.push(b[I]),u.push(b[I+T]),u.push(b[I+T+1])}}else{r=p;for(let w=0;w<g;w++){const x=f.getInt32(r,!1)-2;if(w===0&&x>65535)throw new Error("Invalid VTK binary polygons using little-endian data (MRtrix)");r+=4;const y=f.getInt32(r,!1);r+=4;let v=f.getInt32(r,!1);r+=4;for(let D=0;D<x;D++){const b=f.getInt32(r,!1);r+=4,u.push(y,v,b),v=b}}}}else throw new Error("Unsupported binary VTK datatype "+l[0]);const m=new Uint32Array(u);return{positions:d,indices:m}}static readWRL(e){const i=new TextDecoder("utf-8").decode(e),s=/coord\s+Coordinate\s*\{\s*point\s*\[([\s\S]*?)\]/,r=/coordIndex\s*\[([\s\S]*?)\]/,n=/color\s+Color\s*\{\s*color\s*\[([\s\S]*?)\]/,a=s.exec(i),o=r.exec(i),l=n.exec(i);if(!a||!o)throw new Error("Invalid WRL file: Could not find vertices or indices.");const c=new Float32Array(a[1].trim().split(/[\s,]+/).map(Number));let h=null;if(l){h=new Float32Array(l[1].trim().split(/[\s,]+/).map(Number));const f=c.length/3;h.length!==f*3&&(console.warn(`Unexpected color count: expected ${f*3}, got ${h.length}`),h=null)}const d=new Uint32Array(o[1].trim().split(/[\s,]+/).map(Number).filter(f=>f!==-1));return{positions:c,indices:d,colors:h}}static readDFS(e){const i=new DataView(e),s=i.getUint32(0,!0),r=i.getUint16(4,!0);(s!==1599292996||r!==17740)&&U.warn("Not a little-endian brainsuite DFS mesh");const n=i.getUint32(12,!0),a=i.getUint32(24,!0),o=i.getUint32(28,!0),l=i.getUint32(48,!0);let c=n;const h=new Uint32Array(e,c,a*3);c+=a*3*4;const d=new Float32Array(e,c,o*3);for(let u=0;u<o*3;u+=3){const m=d[u];d[u]=d[u+1],d[u+1]=m}let f;return l>=0&&(f=new Float32Array(e,l,o*3)),{positions:d,indices:h,colors:f}}static async readMZ3(e,i=0){if(e.byteLength<20)throw new Error("File too small to be mz3: bytes = "+e.byteLength);let s=new DataView(e),r=e,n=s.getUint16(0,!0);if(n===35615||n===8075){const I=await Z.decompress(new Uint8Array(e));s=new DataView(I.buffer),n=s.getUint16(0,!0),r=I.buffer}const a=s.getUint16(2,!0),o=s.getUint32(4,!0);let l=s.getUint32(8,!0);const c=s.getUint32(12,!0);if(vi.debug("MZ3 magic %d attr %d face %d vert %d skip %d",n,a,o,l,c),n!==23117)throw new Error("Invalid MZ3 file");const h=(a&1)!==0,d=(a&2)!==0,f=(a&4)!==0;let u=(a&8)!==0;const m=(a&16)!==0,g=(a&32)!==0,p=(a&64)!==0;if(vi.debug(`isFace=${h} isVert=${d} isRGBA=${f} isSCALAR=${u} isDOUBLE=${m} isAOMAP=${g} isLOOKUP=${p}`),a>127)throw new Error("Unsupported future version of MZ3 file");let A=4;m&&(A=8);let w=0;if(i>0&&!h&&o<1&&!f&&(u=!0),u){const I=i||l,M=16+c+(h?o*12:0)+(d?I*12:0)+(f?I*4:0),T=Math.floor((r.byteLength-M)/A);l!==i&&T%i===0&&(l=i),w=Math.floor(T/l),w<1&&(U.warn("Corrupt MZ3: file reports NSCALAR but not enough bytes"),u=!1)}if(l<3&&i<3)throw new Error("Not a mesh MZ3 file (maybe scalar)");i>0&&i!==l&&U.warn("Layer has "+l+"vertices, but background mesh has "+i);let x=16+c;const y=new DataView(r);let v=null;if(h){v=new Uint32Array(o*3);for(let I=0;I<o*3;I++)v[I]=y.getUint32(x,!0),x+=4}let D=null;if(d){D=new Float32Array(l*3);for(let I=0;I<l*3;I++)D[I]=y.getFloat32(x,!0),x+=4}let b=null;if(f){b=new Float32Array(l*3);for(let I=0;I<l;I++){for(let M=0;M<3;M++)b[I*3+M]=y.getUint8(x++)/255;x++}}let C=new Float32Array;if(u&&w>0)if(m){const I=new Float64Array(w*l);for(let M=0;M<w*l;M++)I[M]=y.getFloat64(x,!0),x+=8;C=Float32Array.from(I)}else{C=new Float32Array(w*l);for(let I=0;I<w*l;I++)C[I]=y.getFloat32(x,!0),x+=4}if(i>0&&p&&u){const I=new TextDecoder("utf-8"),M=new Uint8Array(r,16,c),T=I.decode(M),S=JSON.parse(T),E=ce.makeLabelLut(S);return{scalars:C,colormapLabel:E}}if(i>0&&f&&u){let I=C[0];for(let S=0;S<l;S++)I=Math.max(I,C[S]);const M={R:[],G:[],B:[],A:[],I:[],labels:[]};for(let S=0;S<=I;S++)for(let E=0;E<l;E++)if(S===C[E]){const B=E*3;M.I.push(S),M.R.push(b[B]*255),M.G.push(b[B+1]*255),M.B.push(b[B+2]*255),M.A.push(255),M.labels.push(`${S}`);break}const T=ce.makeLabelLut(M);return{scalars:C,colormapLabel:T}}return i>0?{scalars:C}:{positions:D,indices:v,scalars:C,colors:b}}static readPLY(e){const i=e.byteLength,s=new Uint8Array(e);let r=0;function n(){for(;r<i&&s[r]===10;)r++;const C=r;for(;r<i&&s[r]!==10;)r++;return r++,r-C<1?"":new TextDecoder().decode(e.slice(C,r-1))}let a=n();if(!a.startsWith("ply"))throw new Error("Not a valid PLY file");a=n();const o=a.includes("ascii");function l(C){if(C==="char"||C==="uchar"||C==="int8"||C==="uint8")return 1;if(C==="short"||C==="ushort"||C==="int16"||C==="uint16")return 2;if(C==="int"||C==="uint"||C==="int32"||C==="uint32"||C==="float"||C==="float32")return 4;if(C==="double")return 8;throw new Error("Unknown data type: "+C)}const c=a.includes("binary_little_endian");let h=0,d=!1,f=0,u=0,m=0,g=0,p=0,A=0,w=0;for(;r<i&&!a.startsWith("end_header");){if(a=n(),a.startsWith("comment"))continue;let C=a.split(/\s/);if(a.startsWith("element vertex"))for(h=parseInt(C[C.length-1]),a=n(),C=a.split(/\s/);a.startsWith("property");){const I=C[1];C[2]==="x"&&I.startsWith("double")?d=!0:C[2]==="x"&&!I.startsWith("float")&&U.error("Error: expect ply xyz to be float or double: "+a),f+=l(I),a=n(),C=a.split(/\s/)}if(a.startsWith("element face"))for(w=parseInt(C[C.length-1]),a=n(),C=a.split(/\s/);a.startsWith("property");){if(C[1]==="list")m=l(C[2]),g=l(C[3]),u+=m+3*g;else{const I=l(C[1]);u+=I,g===0&&(p+=I,A++)}a=n(),C=a.split(/\s/)}}if(o){w<1&&U.error(`Malformed ply format: faces ${w} `);const C=new Float32Array(h*3);let I=0;for(let S=0;S<h;S++){a=n();const E=a.split(/\s/);C[I]=parseFloat(E[0]),C[I+1]=parseFloat(E[1]),C[I+2]=parseFloat(E[2]),I+=3}let M=new Uint32Array(w*3),T=0;for(let S=0;S<w;S++){a=n();const E=a.split(/\s/),B=parseInt(E[A])-2;if(B<1)break;if(T+B*3>M.length){const R=new Uint32Array(M.length+M.length);R.set(M),M=R.slice()}const P=parseInt(E[A+1]);let V=parseInt(E[A+2]);for(let R=0;R<B;R++){const k=parseInt(E[A+3+R]);M[T+0]=P,M[T+1]=V,M[T+2]=k,V=k,T+=3}}return M.length!==T&&(M=M.slice(0,T)),{positions:C,indices:M}}(f<12||m<1||g<1||w<1)&&U.warn(`Malformed ply format: stride ${f} count ${m} iBytes ${g} iStrideBytes ${u} iPadBytes ${p} faces ${w}`);const x=new DataView(e);let y;if(r%4===0&&f===12&&c)y=new Float32Array(e,r,h*3),r+=h*f;else{y=new Float32Array(h*3);let C=0;for(let I=0;I<h;I++)d?(y[C]=x.getFloat64(r,c),y[C+1]=x.getFloat64(r+8,c),y[C+2]=x.getFloat64(r+16,c)):(y[C]=x.getFloat32(r,c),y[C+1]=x.getFloat32(r+4,c),y[C+2]=x.getFloat32(r+8,c)),C+=3,r+=f}const v=new Uint32Array(w*3);let D=!0,b=0;if(m===1&&g===4&&u===13)for(let C=0;C<w;C++){const I=x.getUint8(r);r+=m,I!==3&&(D=!1),v[b]=x.getUint32(r,c),r+=4,v[b+1]=x.getUint32(r,c),r+=4,v[b+2]=x.getUint32(r,c),r+=4,b+=3}else{let C=r;for(let I=0;I<w;I++){r=C+p;let M=0;m===1?M=x.getUint8(r):m===2?M=x.getUint16(r,c):m===4&&(M=x.getUint32(r,c)),r+=m,M!==3&&(D=!1);for(let T=0;T<3;T++)g===1?v[b]=x.getUint8(r):g===2?v[b]=x.getUint16(r,c):g===4&&(v[b]=x.getUint32(r,c)),b++,r+=g;C+=u}}return D||U.warn("Only able to read PLY meshes limited to triangles."),{positions:y,indices:v}}static readICO(e){const r=new TextDecoder("utf-8").decode(e).split(`
`);let n=r[0].trim().split(/\s+/);n.length>1&&U.warn("This is not a valid FreeSurfer ICO/TRI mesh.");const a=parseInt(n[0]),o=new Float32Array(a*3);let l=1;for(let d=0;d<a;d++){const f=r[l].trim().split(/\s+/);l++;let u=parseInt(f[0])-1;const m=parseFloat(f[1]),g=parseFloat(f[2]),p=parseFloat(f[3]);if(u<0||u>=a){U.error("ICO vertices corrupted");break}u*=3,o[u]=m,o[u+1]=g,o[u+2]=p}n=r[l].trim().split(/\s+/),l++;const c=parseInt(n[0]),h=new Uint32Array(c*3);for(let d=0;d<c;d++){const f=r[l].trim().split(/\s+/);l++;let u=parseInt(f[0])-1;const m=parseInt(f[1])-1,g=parseInt(f[2])-1,p=parseInt(f[3])-1;if(u<0||u>=c){U.error("ICO indices corrupted");break}u*=3,h[u]=m,h[u+1]=g,h[u+2]=p}for(let d=0;d<h.length;d+=3){const f=h[d];h[d]=h[d+1],h[d+1]=f}return{positions:o,indices:h}}static readGEO(e,i=!1){const n=new TextDecoder("utf-8").decode(e).split(`
`),a=n[0].trim().split(/\s+/),o=parseInt(a[0]);let l=parseInt(a[1]),c=parseInt(a[2]);const h=parseInt(a[3]);(o>1||h!==c*3)&&U.warn("Multi-part BYU/GEO header or not a triangular mesh.");const d=[];l*=3;let f=0,u=2;for(;f<l;){const w=n[u].trim().split(/\s+/);u++;for(let x=0;x<w.length&&(d.push(parseFloat(w[x])),f++,!(f>=l));x++);}const m=[];c*=3;let g=0;for(;g<c;){const w=n[u].trim().split(/\s+/);u++;for(let x=0;x<w.length&&(m.push(Math.abs(parseInt(w[x]))-1),g++,!(g>=c));x++);}if(i)for(let w=0;w<m.length;w+=3){const x=m[w];m[w]=m[w+1],m[w+1]=x}const p=new Float32Array(d),A=new Uint32Array(m);return{positions:p,indices:A}}static readOFF(e){const r=new TextDecoder("utf-8").decode(e).split(`
`),n=[],a=[];let o=0;r[o].includes("OFF")?o++:U.warn("File does not start with OFF");let l=r[o].trim().split(/\s+/);const c=parseInt(l[0]),h=parseInt(l[1]);o++;for(let u=0;u<c;u++)l=r[o].trim().split(/\s+/),n.push(parseFloat(l[0])),n.push(parseFloat(l[1])),n.push(parseFloat(l[2])),o++;for(let u=0;u<h;u++)l=r[o].trim().split(/\s+/),parseInt(l[0])!==3&&U.warn("Only able to read OFF files with triangular meshes"),a.push(parseInt(l[1])),a.push(parseInt(l[2])),a.push(parseInt(l[3])),o++;const d=new Float32Array(n),f=new Uint32Array(a);return{positions:d,indices:f}}static readOBJMNI(e){const r=new TextDecoder("utf-8").decode(e).trim().split(/\s*,\s*|\s+/);(r.length<1||r[0]!=="P")&&U.warn("This is not a valid MNI OBJ mesh.");let n=6;const a=parseInt(r[n++]),o=a*3,l=new Float32Array(o);for(let m=0;m<o;m++)l[m]=parseFloat(r[n++]);n+=o;const c=parseInt(r[n++]),h=parseInt(r[n++]);(c<1||h<0||h>2)&&U.warn("This is not a valid MNI OBJ mesh.");let d=1;h===1?d=c:h===1&&(d=a),n+=d*4,n+=c;const f=c*3,u=new Uint32Array(f);for(let m=0;m<f;m++)u[m]=parseInt(r[n++]);return{positions:l,indices:u}}static async readOBJ(e){const i=new Uint8Array(e,0,2);i[0]===31&&i[1]===139&&(e=await Z.decompressToBuffer(new Uint8Array(e)));const r=new TextDecoder("utf-8").decode(e);if(r[0]==="P")return this.readOBJMNI(e);const n=r.split(`
`),a=n.length,o=[],l=[];for(let u=0;u<a;u++){const m=n[u];if(m[0]==="v"&&m[1]===" "){const g=m.trim().split(/\s+/);o.push(parseFloat(g[1])),o.push(parseFloat(g[2])),o.push(parseFloat(g[3]))}if(m[0]==="f"){const g=m.trim().split(/\s+/),p=g.length-3;if(p<1)break;let A=g[1].split("/");const w=parseInt(A[0])-1;A=g[2].split("/");let x=parseInt(A[0])-1;for(let y=0;y<p;y++){A=g[3+y].split("/");const v=parseInt(A[0])-1;l.push(w),l.push(x),l.push(v),x=v}}}const c=new Float32Array(o),h=new Uint32Array(l);let d=h[0],f=h[0];for(let u=1;u<h.length;u++)h[u]<d&&(d=h[u]),h[u]>f&&(f=h[u]);if(f-d+1>c.length/3)throw new Error("Not a valid OBJ file");for(let u=0;u<h.length;u++)h[u]-=d;return{positions:c,indices:h}}static readFreeSurfer(e){const i=new Uint8Array(e);if(i[0]===35&&i[1]===33&&i[2]===97)return Ue.readASC(e);const s=new DataView(e),r=s.getUint32(0,!1),n=s.getUint32(4,!1);(r!==4294966883||n!==1919246708)&&vi.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");let a=0;for(;s.getUint8(a)!==10;)a++;a+=2;let o=s.getUint32(a,!1);a+=4;let l=s.getUint32(a,!1);a+=4,o*=3;const c=new Float32Array(o);for(let u=0;u<o;u++)c[u]=s.getFloat32(a,!1),a+=4;l*=3;const h=new Uint32Array(l);for(let u=0;u<l;u++)h[u]=s.getUint32(a,!1),a+=4;const d=s.getUint32(a,!1);a+=4;let f=d===20;if(!f){const u=s.getUint32(a,!1);a+=4;const m=s.getUint32(a,!1);a+=4,f=d===2&&u===0&&m===20}if(!f)U.warn("Unknown FreeSurfer Mesh extension code.");else{const m=new TextDecoder().decode(e.slice(a)).trim().split(`
`);for(let g=0;g<m.length;g++){if(!m[g].startsWith("cras"))continue;const A=m[g].split("=")[1].trim().split(" ").map(Number),w=Math.floor(c.length/3);let x=0;for(let y=0;y<w;y++)c[x]+=A[0],x++,c[x]+=A[1],x++,c[x]+=A[2],x++}}return{positions:c,indices:h}}static async readSRF(e){const i=new Uint8Array(e);if(i[0]===35&&i[1]===33&&i[2]===97)return Ue.readASC(e);i[0]===31&&i[1]===139&&(e=(await Z.decompress(new Uint8Array(e))).buffer);const s=new DataView(e),r=s.getFloat32(0,!0),n=s.getUint32(8,!0),a=s.getUint32(12,!0),o=s.getFloat32(16,!0),l=s.getFloat32(20,!0),c=s.getFloat32(24,!0),h=new Float32Array(n*3);let d=28,f=1;for(let D=0;D<n;D++)h[f]=-s.getFloat32(d,!0)+o,f+=3,d+=4;f=2;for(let D=0;D<n;D++)h[f]=-s.getFloat32(d,!0)+l,f+=3,d+=4;f=0;for(let D=0;D<n;D++)h[f]=-s.getFloat32(d,!0)+c,f+=3,d+=4;d=28+4*6*n;const u=s.getFloat32(d,!0),m=s.getFloat32(d+4,!0),g=s.getFloat32(d+8,!0),p=s.getFloat32(d+16,!0),A=s.getFloat32(d+20,!0),w=s.getFloat32(d+24,!0);d+=8*4;const x=new Float32Array(n*3),y=new Uint32Array(e,d,n);f=0;for(let D=0;D<n;D++){const b=y[D];b>1056964608&&(x[f+0]=(b>>16&255)/255,x[f+1]=(b>>8&255)/255,x[f+2]=(b&255)/255),b===0&&(x[f+0]=u,x[f+1]=m,x[f+2]=g),b===1&&(x[f+0]=p,x[f+1]=A,x[f+2]=w),f+=3}d+=n*4;for(let D=0;D<n;D++){const b=s.getUint32(d,!0);d+=4+4*b}const v=new Uint32Array(a*3);for(let D=0;D<a*3;D++)v[D]=s.getInt32(d,!0),d+=4;return r!==4&&U.warn("Not valid SRF"),{positions:h,indices:v,colors:x}}static readTxtSTL(e){const r=new TextDecoder("utf-8").decode(e).split(`
`);if(!r[0].startsWith("solid"))throw new Error("Not a valid STL file");const n=[];for(let c=1;c<r.length;c++){if(!r[c].includes("vertex"))continue;const h=r[c].trim().split(/\s+/);for(let d=1;d<h.length;d++)n.push(parseFloat(h[d]))}const a=Math.floor(n.length/3);if(a*3!==n.length)throw new Error("Unable to parse ASCII STL file.");const o=new Float32Array(n),l=new Uint32Array(a);for(let c=0;c<a;c++)l[c]=c;return{positions:o,indices:l}}static readSTL(e){if(e.byteLength<134)throw new Error("File too small to be STL: bytes = "+e.byteLength);const i=new DataView(e);if(i.getUint32(0,!0)===1768714099)return Ue.readTxtSTL(e);const r=i.getUint32(80,!0),n=3*r;if(e.byteLength<84+r*50)throw new Error("STL file too small to store triangles = "+r);const a=new Uint32Array(n),o=new Float32Array(n*3);let l=96,c=0;for(let h=0;h<r;h++){for(let d=0;d<9;d++)o[c]=i.getFloat32(l,!0),c+=1,l+=4;l+=14}for(let h=0;h<n;h++)a[h]=h;return{positions:o,indices:a}}static decimateLayerVertices(e,i){if(e%i===0)return e;const s=12,r=Math.round(Math.log((e-2)/(s-2))/Math.log(4)),n=Math.round(Math.log((i-2)/(s-2))/Math.log(4)),a=Math.pow(4,r)*(s-2)+2,o=Math.pow(4,n)*(s-2)+2;return a!==e||o!==i?e:i}static async readNII2(e,i=0,s=""){let r=new Float32Array;const n=e.byteLength;let a=!0;const o=new DataView(e);let l=o.getUint16(0,a);if(l===469893120&&(a=!1,l=o.getUint16(0,a)),l!==540)throw new Error("Not a valid NIfTI-2 dataset");const c=Number(o.getBigInt64(168,a)),h=o.getFloat64(176,a),d=o.getFloat64(184,a);(h!==1||d!==0)&&U.warn("ignoring scale slope and intercept");const f=o.getUint32(504,a),u=o.getUint16(12,a);if(u!==2&&u!==4&&u!==8&&u!==16)throw new Error("Unsupported NIfTI datatype "+u);let m=1;const g=[1,1,1,1,1,1,1,1];for(let p=1;p<8;p++)g[p]=Math.max(Number(o.getBigInt64(16+p*8,a)),1),m*=g[p];if(f>=3e3&&f<=3099&&c>580){let p=function(){for(;I<n&&C[I]===10;)I++;const V=I;for(;I<n&&C[I]!==10;)I++;return I++,I-V<1?"":new TextDecoder().decode(e.slice(V,I-1)).trim()},A=function(){let V=p();if(!V.startsWith("<")||V.endsWith(">"))return V;for(;I<n&&!V.endsWith(">");)V+=p();return V},w=function(V,R=!1){const k=M.indexOf(V);if(k<0)return 1;const z=M.indexOf('"',k)+1,W=M.indexOf('"',z),j=M.slice(z,W);return R?j:parseInt(j)},x=0,y=0,v=0,D="",b=new Uint32Array;const C=new Uint8Array(e);let I=552,M;const T=g[5],S=new Float32Array(i*T);for(;I<n&&(M=A(),!M.includes("</CIFTI>"));)if(M.includes("<BrainModel")){const V=w("SurfaceNumberOfVertices="),R=w("BrainStructure=",!0).toUpperCase();if(V%i!==0)continue;let k=!1;if(s.includes("CORTEX")&&R.includes("CORTEX")&&(k=!0),!k||(k=!1,s.includes("LEFT")&&R.includes("LEFT")&&(k=!0),s.includes("RIGHT")&&R.includes("RIGHT")&&(k=!0),!k))continue;if(v=V,x=w("IndexOffset="),y=w("IndexCount="),D=R,M.includes("<VertexIndices>")||(M=A()),!M.startsWith("<VertexIndices>")||!M.endsWith("</VertexIndices>"))return U.warn("Unable to find CIfTI <VertexIndices>"),S;M=M.slice(15,-16);const z=M.trim().split(/\s+/);z.length<y&&U.error("Error parsing VertexIndices"),b=new Uint32Array(y);for(let W=0;W<y;W++)b[W]=parseInt(z[W])}if(v===0||b.length===0)return U.warn("Unable to find CIfTI structure that matches the mesh."),S;if(u!==16)return U.warn("Only able to read float32 CIfTI (only known datatype)."),S;const E=new Float32Array(y*T),B=c+T*x*4;for(let V=0;V<y*T;V++)E[V]=o.getFloat32(B+V*4,a);let P=0;for(let V=0;V<y;V++)for(let R=0;R<T;R++)S[b[V]+R*i]=E[P],P++;return U.debug("CIfTI diagnostics",v,D,x,y,x,s),S}if(m=this.decimateLayerVertices(m,i),m%i!==0)throw new Error("Vertices in layer ("+m+") is not a multiple of number of vertices ("+i+")");if(a)u===16?r=new Float32Array(e,c,m):u===8?r=new Int32Array(e,c,m):u===4&&(r=new Int16Array(e,c,m));else if(u===16){r=new Float32Array(m);for(let p=0;p<m;p++)r[p]=o.getFloat32(c+p*4,a)}else if(u===8){r=new Int32Array(m);for(let p=0;p<m;p++)r[p]=o.getInt32(c+p*4,a)}else if(u===4){r=new Int16Array(m);for(let p=0;p<m;p++)r[p]=o.getInt16(c+p*2,a)}return u===2&&(r=new Uint8Array(e,c,m)),r}static async readNII(e,i=0,s=""){let r=new Float32Array,n=!0,a=new DataView(e),o=a.getUint16(0,n);if(o===540||o===469893120)return Ue.readNII2(e,i,s);if(o===23553&&(n=!1,o=a.getUint16(0,n)),o!==348){const u=await Z.decompress(new Uint8Array(e));if(a=new DataView(u.buffer),e=u.buffer,o=a.getUint16(0,n),o===540||o===469893120)return Ue.readNII2(e,i,s);o===23553&&(n=!1,o=a.getUint16(0,n))}o!==348&&U.error("Not a valid NIfTI image.");const l=a.getFloat32(108,n),c=a.getFloat32(112,n),h=a.getFloat32(116,n);(c!==1||h!==0)&&U.warn("ignoring scale slope and intercept");const d=a.getUint16(70,n);if(d!==2&&d!==4&&d!==8&&d!==16)throw new Error("Unsupported NIfTI datatype "+d);let f=1;for(let u=1;u<8;u++){const m=a.getUint16(40+u*2,n);f*=Math.max(m,1)}if(f=this.decimateLayerVertices(f,i),f%i!==0)throw new Error("Vertices in layer ("+f+") is not a multiple of number of vertices ("+i+")");if(n)d===16?r=new Float32Array(e,l,f):d===8?r=new Int32Array(e,l,f):d===4&&(r=new Int16Array(e,l,f));else if(d===16){r=new Float32Array(f);for(let u=0;u<f;u++)r[u]=a.getFloat32(l+u*4,n)}else if(d===8){r=new Int32Array(f);for(let u=0;u<f;u++)r[u]=a.getInt32(l+u*4,n)}else if(d===4){r=new Int16Array(f);for(let u=0;u<f;u++)r[u]=a.getInt16(l+u*2,n)}return d===2&&(r=new Uint8Array(e,l,f)),r}static async readMGH(e,i=0,s=!1){let r=new DataView(e),n=e;if(r.getUint8(0)===31&&r.getUint8(1)===139){const b=await Z.decompress(new Uint8Array(e));n=new ArrayBuffer(b.byteLength),new Uint8Array(n).set(new Uint8Array(b)),r=new DataView(b.buffer)}const a=r.getInt32(0,!1),o=Math.max(1,r.getInt32(4,!1)),l=Math.max(1,r.getInt32(8,!1)),c=Math.max(1,r.getInt32(12,!1)),h=Math.max(1,r.getInt32(16,!1)),d=r.getInt32(20,!1);let f=284;const u=!1;(a!==1||d<0||d>4)&&U.warn("Not a valid MGH file");let m=o*l*c*h,g=[];if(m=this.decimateLayerVertices(m,i),m%i!==0)return U.warn("Vertices in layer ("+m+") is not a multiple of number of vertices ("+i+")"),g;if(d===3){g=new Float32Array(m);for(let b=0;b<m;b++)g[b]=r.getFloat32(f+b*4,u)}else if(d===1){g=new Int32Array(m);for(let b=0;b<m;b++)g[b]=r.getInt32(f+b*4,u)}else if(d===4){g=new Int16Array(m);for(let b=0;b<m;b++)g[b]=r.getInt16(f+b*2,u)}else d===0&&(g=new Uint8Array(e,f,m));if(!s)return g;let p=4;d===4&&(p=2),d===0&&(p=1),f+=p*m,f+=4*4;const A=1,w=2,x=20,y=30,v=n.byteLength;let D;for(;f<v-8;){const b=r.getInt32(f+=4,u);let C=0;switch(b){case y:C=r.getInt32(f+=4,u)-1;break;case x:case w:C=0;break;case A:C=0;{let I=r.getInt32(f+=4,u);if(I>0)return U.warn("unsupported CTABreadFromBinaryV1"),g;if(I=-I,I!==2)return U.warn("CTABreadFromBinary: unknown version"),g;const M=r.getInt32(f+=4,u);if(M<0)return U.warn("CTABreadFromBinaryV2: nentries was ",M),g;const T=r.getInt32(f+=4,u);f+=T;const S=r.getInt32(f+=4,u);if(S<0)return g;const E={R:[],G:[],B:[],A:[],I:[],labels:[]};for(let B=0;B<S;B++){const P=r.getInt32(f+=4,u),V=r.getInt32(f+=4,u);let R=f+4,k="";for(let pe=0;pe<V;pe++){const Ce=r.getUint8(R++);if(Ce===0)break;k+=String.fromCharCode(Ce)}f+=V;const z=r.getInt32(f+=4,u),W=r.getInt32(f+=4,u),j=r.getInt32(f+=4,u),Q=255-r.getInt32(f+=4,u);E.I.push(P),E.R.push(z),E.G.push(W),E.B.push(j),E.A.push(Q),E.labels.push(k)}D=ce.makeLabelLut(E)}break;default:C=r.getInt32(f+=8,u)}f+=C}return{scalars:g,colormapLabel:D}}static readX3D(e){const i=e.byteLength;if(i<20)throw new Error("File too small to be X3D: bytes = "+i);const s=new Uint8Array(e);let r=0;function n(){for(;r<i&&s[r]!==60;)r++;const x=r;for(;r<i&&s[r]!==62;)r++;const y=r;return new TextDecoder().decode(e.slice(x,y+1)).trim()}let a=n();function o(x){const y=a.indexOf(x+"=");if(y<0)return"";const v=a[y+x.length+1],D=a.indexOf(v,y)+1,b=a.indexOf(v,D);return a.slice(D,b)}function l(x){const y=a.indexOf(x+"=");if(y<0)return 1;const v=a[y+x.length+1],D=a.indexOf(v,y)+1,b=a.indexOf(v,D);let C=a.slice(D,b).trim();C=C.replace(/,\s*$/,"");const I=C.trim().split(/\s*,\s*|\s+/);if(I.length<2)return parseFloat(C);let M=new Array(I.length),T=0;for(let S=0;S<I.length;S++){const E=parseFloat(I[S]);isFinite(E)&&(M[T]=E,T++)}return M=M.slice(0,T),M}a.includes("xml version")||U.warn("Not a X3D image");let c=[],h=[],d=[],f=[],u=[0,0,0,0],m=[0,0,0,0],g=[255,255,255,255],p=[255,255,255,255];const A={};function w(){if(!a.endsWith("/>"))if(a.startsWith("<Appearance>"))for(;r<i&&!a.endsWith("</Appearance>");)a+=n();else for(;r<i&&!a.endsWith("/>");)a+=n();const x=o("USE");if(x.length>1){x in A?g=A[x]:U.warn("Unable to find DEF for "+x);return}const y=l("diffuseColor");if(y.length<3)return;g[0]=Math.round(y[0]*255),g[1]=Math.round(y[1]*255),g[2]=Math.round(y[2]*255);const v=o("DEF");v.length<1||(A[v]=g)}for(;r<i;)if(a=n(),g=p.slice(),a.startsWith("<Transform")&&(u=l("translation"),m=l("rotation")),a.startsWith("<Appearance")&&(w(),p=g.slice()),a.startsWith("<Shape")){let x=1,y=1,v=[],D=[];for(;r<i&&(a=n(),a.startsWith("<Appearance")&&w(),!a.startsWith("</Shape"));){if(a.startsWith("<Sphere")&&(x=l("radius"),y=-1),a.startsWith("<Cylinder")&&(x=l("radius"),y=l("height")),a.startsWith("<IndexedFaceSet")&&(y=-2,v=l("coordIndex")),a.startsWith("<IndexedTriangleSet")&&(y=-7,v=l("index")),a.startsWith("<IndexedTriangleStripSet")&&(y=-3,v=l("index")),a.startsWith("<Coordinate")){D=l("point");const b=D.length%3;b!==0&&(D=D.slice(0,-b))}a.startsWith("<Color")&&(f=l("color")),a.startsWith("<Box")&&(y=-4,U.warn("Unsupported x3d shape: Box")),a.startsWith("<Cone")&&(y=-5,U.warn("Unsupported x3d shape: Cone")),a.startsWith("<ElevationGrid")&&(y=-6,U.warn("Unsupported x3d shape: ElevationGrid"))}if(!(y<-3&&y!==-7))if(y<-1){if(v.length<1||D.length<3||D.length===void 0){U.warn("Indexed mesh must specify indices and points");break}const b=Math.floor(c.length/3);let C=2;if(y===-7)h=[...h,...v];else if(y===-2){let T=0;for(;C<v.length;)v[C]>=0?(h.push(v[T]+b),h.push(v[C-1]+b),h.push(v[C-0]+b),C+=1):(C+=3,T=C-2)}else for(;C<v.length;)v[C]>=0?(h.push(v[C-2]+b),h.push(v[C-1]+b),h.push(v[C-0]+b),C+=1):C+=3;c=[...c,...D];const I=Math.floor(D.length/3),M=Array(I).fill(g).flat();if(f.length===I*3){let T=0,S=0;for(let E=0;E<I;E++){for(let B=0;B<3;B++)M[S]=Math.round(f[T]*255),T++,S++;S++}}d=[...d,...M]}else if(y<0)Zt.makeColoredSphere(c,h,d,x,u,g);else{const b=se();wc(b,m[3],[m[0],m[1],m[2]]);const C=ue(0,-y*.5,0,1),I=ue(0,+y*.5,0,1);Ve(C,C,b),Ve(I,I,b),ia(C,C,u),ia(I,I,u);const M=H(C[0],C[1],C[2]),T=H(I[0],I[1],I[2]);Zt.makeColoredCylinder(c,h,d,M,T,x,g)}}return{positions:Float32Array.from(c),indices:Uint32Array.from(h),rgba255:Uint8Array.from(d)}}static async readGII(e,i=0){let s=e.byteLength;if(s<20)throw new Error("File too small to be GII: bytes = "+s);let r=new TextDecoder("ascii").decode(e);if(r[0].charCodeAt(0)===31){const S=await Z.decompress(new Uint8Array(e));e=S.buffer,r=new TextDecoder("ascii").decode(S.buffer)}let n=0;function a(){let S=!0,E=n;for(;S;){for(;n<s&&r[n]!=="<";)n++;for(E=n;n<s&&r[n]!==">";)n++;if(S=r[n-1]==="/",E+1<s&&r[E+1]==="/"&&(n+=1,S=!0),n>=s)break}const B=new TextDecoder().decode(e.slice(E+1,n)).trim(),P=B.split(" ")[0].trim(),V=n;let R=n,k=n;if(r[E+1]!=="?"&&r[E+1]!=="!"){const z="</"+P+">";R=r.indexOf(z,V),k=R+z.length-1}return{name:B,startPos:E,contentStartPos:V,contentEndPos:R,endPos:k}}let o=a();if(!o.name.startsWith("?xml"))throw new Error("readGII: Invalid XML file");for(;!o.name.startsWith("GIFTI")&&o.endPos<s;)o=a();if(!o.name.startsWith("GIFTI")||o.contentStartPos===o.contentEndPos)throw new Error("readGII: XML file does not include GIFTI tag");s=o.contentEndPos;let l=new Float32Array,c=new Uint32Array,h=new Float32Array,d="",f=!1,u=!1,m=!1,g=!1,p=[1,1,1];const A=[0,0,0];let w=0,x=!1,y=!1,v=0,D=!1;o.endPos=o.contentStartPos;let b="";function C(S,E=!1){const B=b.indexOf(S);if(B<0)return 1;const P=b.indexOf('"',B)+1,V=b.indexOf('"',P),R=b.slice(P,V);return E?parseFloat(R):parseInt(R)}function I(S){const E=b.indexOf(S);if(E<0)return"";const B=E+S.length,P=b.indexOf("]",B);return b.slice(B,P)}const M={R:[],G:[],B:[],A:[],I:[],labels:[]};for(;o.endPos<s&&o.name.length>1;){if(o=a(),o.name.startsWith("Label Key")&&(b=o.name,M.I.push(C("Key=")),M.R.push(Math.round(255*C("Red=",!0))),M.G.push(Math.round(255*C("Green=",!0))),M.B.push(Math.round(255*C("Blue=",!0))),M.A.push(Math.round(255*C("Alpha",!0))),b=new TextDecoder().decode(e.slice(o.contentStartPos+1,o.contentEndPos)).trim(),M.labels.push(I("<![CDATA["))),o.name.trim()==="Data"){if(m)continue;b=new TextDecoder().decode(e.slice(o.contentStartPos+1,o.contentEndPos)).trim();let S;if(y){const E=p[0]*p[1]*p[2],B=b.split(/\s+/);if(E!==B.length)throw new Error("Unable to parse ASCII GIfTI");if(w===2&&(w=8),w===32&&(w=16),w===8){S=new Int32Array(E);for(let P=0;P<E;P++)S[P]=parseInt(B[P])}if(w===16){S=new Float32Array(E);for(let P=0;P<E;P++)S[P]=parseFloat(B[P])}}else if(typeof Buffer>"u"){let E=function(B){const P=atob(B),V=P.length,R=new Uint8Array(V);for(let k=0;k<V;k++)R[k]=P.charCodeAt(k);return R};if(x){const B=E(b.slice());S=await Z.decompress(new Uint8Array(B))}else S=E(b.slice())}else if(x){const E=Buffer.from(b.slice(),"base64");S=await Z.decompress(new Uint8Array(E))}else S=Buffer.from(b.slice(),"base64");if(u){if(w!==16&&U.warn("expect positions as FLOAT32"),l=new Float32Array(S.buffer),g){const E=l.slice(),B=E.length/3;let P=0;for(let V=0;V<B;V++)for(let R=0;R<3;R++)l[P]=E[R*B+V],P++}}else if(f){if(w!==8&&U.warn("expect indices as INT32"),c=new Uint32Array(S.buffer),g){const E=c.slice(),B=E.length/3;let P=0;for(let V=0;V<B;V++)for(let R=0;R<3;R++)c[P]=E[R*B+V],P++}}else{let E=function(P,V){const R=P.length,k=new Float32Array(R+V.length);return k.set(P),k.set(V,R),k};v=p[0]*p[1]*p[2],i!==0&&v%i!==0&&U.warn("Number of vertices in scalar overlay ("+v+") does not match mesh ("+i+")");let B;if(w===2){const P=new Uint8Array(S.buffer);B=Float32Array.from(P)}else if(w===8){const P=new Int32Array(S.buffer);B=Float32Array.from(P)}else if(w===16)B=new Float32Array(S.buffer);else if(w===32){const P=new Float64Array(S.buffer);B=Float32Array.from(P)}else throw new Error(`Invalid dataType: ${w}`);h=E(h,B)}continue}if(o.name.trim()==="DataSpace"&&(b=new TextDecoder().decode(e.slice(o.contentStartPos+1,o.contentEndPos)).trim(),b.includes("NIFTI_XFORM_SCANNER_ANAT")&&(D=!0)),o.name.trim()==="MD"&&(b=new TextDecoder().decode(e.slice(o.contentStartPos+1,o.contentEndPos)).trim(),b.includes("AnatomicalStructurePrimary")&&b.includes("CDATA[")&&(d=I("<Value><![CDATA[").toUpperCase()),b.includes("VolGeom")&&b.includes("CDATA["))){let S=-1;if(b.includes("VolGeomC_R")&&(S=0),b.includes("VolGeomC_A")&&(S=1),b.includes("VolGeomC_S")&&(S=2),S<0)continue;A[S]=parseFloat(I("<Value><![CDATA["))}o.name.startsWith("DataArray")&&(b=o.name,p=[1,1,1],x=b.includes('Encoding="GZipBase64Binary"'),y=b.includes('Encoding="ASCII"'),f=b.includes('Intent="NIFTI_INTENT_TRIANGLE"'),u=b.includes('Intent="NIFTI_INTENT_POINTSET"'),m=b.includes('Intent="NIFTI_INTENT_VECTOR"'),g=b.includes('ArrayIndexingOrder="ColumnMajorOrder"'),b.includes('DataType="NIFTI_TYPE_UINT8"')&&(w=2),b.includes('DataType="NIFTI_TYPE_INT32"')&&(w=8),b.includes('DataType="NIFTI_TYPE_FLOAT32"')&&(w=16),b.includes('DataType="NIFTI_TYPE_FLOAT64"')&&(w=32),p[0]=C("Dim0="),p[1]=C("Dim1="),p[2]=C("Dim2="))}let T;if(M.I.length>1&&(T=ce.makeLabelLut(M)),i>0)return{scalars:h,colormapLabel:T,anatomicalStructurePrimary:d};if(l.length>2&&!D&&(A[0]!==0||A[1]!==0||A[2]!==0)){v=Math.floor(l.length/3);let S=0;for(let E=0;E<v;E++)l[S]+=A[0],S++,l[S]+=A[1],S++,l[S]+=A[2],S++}return{positions:l,indices:c,scalars:h,colormapLabel:T,anatomicalStructurePrimary:d}}},Bn=class{constructor(t,e,i,s,r){F(this,"text"),F(this,"style"),F(this,"points"),F(this,"anchor"),F(this,"onClick"),this.text=t,this.style=e,this.points=i,this.anchor=s||0,this.onClick=r}},Cd=()=>{const t=new ArrayBuffer(2);return new DataView(t).setInt16(0,256,!0),new Int16Array(t)[0]===256},sl=(t=>(t[t.UNKNOWN=0]="UNKNOWN",t[t.NII=1]="NII",t[t.DCM=2]="DCM",t[t.DCM_MANIFEST=3]="DCM_MANIFEST",t[t.MIH=4]="MIH",t[t.MIF=5]="MIF",t[t.NHDR=6]="NHDR",t[t.NRRD=7]="NRRD",t[t.MHD=8]="MHD",t[t.MHA=9]="MHA",t[t.MGH=10]="MGH",t[t.MGZ=11]="MGZ",t[t.V=12]="V",t[t.V16=13]="V16",t[t.VMR=14]="VMR",t[t.HEAD=15]="HEAD",t[t.DCM_FOLDER=16]="DCM_FOLDER",t[t.SRC=17]="SRC",t[t.FIB=18]="FIB",t[t.BMP=19]="BMP",t[t.ZARR=20]="ZARR",t[t.NPY=21]="NPY",t[t.NPZ=22]="NPZ",t))(sl||{}),$=Object.freeze({...sl,parse:t=>{let e=0;switch(t.toUpperCase()){case"":case"DCM":e=2;break;case"TXT":e=3;break;case"FZ":case"GQI":case"QSDR":case"FIB":e=18;break;case"NII":e=1;break;case"MIH":e=4;break;case"MIF":e=5;break;case"NHDR":e=6;break;case"NRRD":e=7;break;case"MHD":e=8;break;case"MHA":e=9;break;case"MGH":e=10;break;case"MGZ":e=11;break;case"NPY":e=21;break;case"NPZ":e=22;break;case"SRC":e=17;break;case"V":e=12;break;case"V16":e=13;break;case"VMR":e=14;break;case"HEAD":e=15;break;case"PNG":case"BMP":case"GIF":case"JPG":case"JPEG":e=19;break;case"ZARR":e=20;break}return e}}),Is=(t,e="",i="",s="gray",r=1,n=NaN,a=NaN,o=!0,l=.02,c=!1,h=!1,d="",f=0,u=$.UNKNOWN,m=NaN,g=NaN,p=!0,A=!1,w=null)=>({url:t,urlImageData:e,name:i,colormap:s,colorMap:s,opacity:r,cal_min:n,cal_max:a,trustCalMinMax:o,percentileFrac:l,ignoreZeroVoxels:c,useQFormNotSForm:h,colormapNegative:d,imageType:u,cal_minNeg:m,cal_maxNeg:g,colorbarVisible:p,frame4D:f,alphaThreshold:A,colormapLabel:w});function Da(t,e=80){t=t.replace(/[`$]/g,"");const i=[],s=Math.min(e,t.length);for(let r=0;r<s;r++){const n=t.charCodeAt(r);i.push(n&255)}return i}function Ys(t,e=!1,i=!1){let n=!0;i&&(n=t.littleEndian);const a=new Uint8Array(348),o=new DataView(a.buffer);o.setInt32(0,348,n),o.setUint8(38,114),o.setUint8(39,t.dim_info);for(let c=0;c<8;c++)o.setUint16(40+2*c,t.dims[c],n);o.setFloat32(56,t.intent_p1,n),o.setFloat32(60,t.intent_p2,n),o.setFloat32(64,t.intent_p3,n),o.setInt16(68,t.intent_code,n),e?(o.setInt16(70,2,n),o.setInt16(72,8,n)):(o.setInt16(70,t.datatypeCode,n),o.setInt16(72,t.numBitsPerVoxel,n)),o.setInt16(74,t.slice_start,n);for(let c=0;c<8;c++)o.setFloat32(76+4*c,t.pixDims[c],n);e?(o.setFloat32(108,352,n),o.setFloat32(112,1,n),o.setFloat32(116,0,n)):(o.setFloat32(108,352,n),o.setFloat32(112,t.scl_slope,n),o.setFloat32(116,t.scl_inter,n)),o.setInt16(120,t.slice_end,n),o.setUint8(122,t.slice_code),t.xyzt_units===0?o.setUint8(123,10):o.setUint8(123,t.xyzt_units),e?(o.setFloat32(124,0,n),o.setFloat32(128,0,n)):(o.setFloat32(124,t.cal_max,n),o.setFloat32(128,t.cal_min,n)),o.setFloat32(132,t.slice_duration,n),o.setFloat32(136,t.toffset,n),a.set(Da(t.description),148),a.set(Da(t.aux_file),228),o.setInt16(252,t.qform_code,n),t.sform_code<1||t.sform_code<1?o.setInt16(254,1,n):o.setInt16(254,t.sform_code,n),o.setFloat32(256,t.quatern_b,n),o.setFloat32(260,t.quatern_c,n),o.setFloat32(264,t.quatern_d,n),o.setFloat32(268,t.qoffset_x,n),o.setFloat32(272,t.qoffset_y,n),o.setFloat32(276,t.qoffset_z,n);const l=t.affine.flat();for(let c=0;c<12;c++)o.setFloat32(280+4*c,l[c],n);return o.setInt32(344,3222382,!0),a}function Sd(t,e=!0){const i=Math.round(t.length/3),s=H(0,0,0),r=fe(),n=fe();let a=0,o=1;e&&(o=2);for(let d=0;d<o;d++){a=0;for(let u=0;u<i;u++){const m=H(t[u*3],t[u*3+1],t[u*3+2]);u===0&&(ea(r,m),ea(n,m)),un(r,r,m),mn(n,n,m),de(m,m,s);const g=Li(m);a=Math.max(a,g)}if(d+1>=o)break;let f=!0;for(let u=0;u<3;++u)r[u]>s[u]&&(f=!1),n[u]<s[u]&&(f=!1);if(f)break;Sc(s,r,n,.5),U.debug("origin moved inside volume: ",s)}const l=[r[0],r[1],r[2]],c=[n[0],n[1],n[2]];return{min:l,max:c,furthestVertexFromOrigin:a,origin:s}}function Ta(t){const e=[!1,!1,!1,!1],i=[!1,!1,!1,!1];for(let s=0;s<4;s++)for(let r=0;r<4;r++)if(isNaN(t[s][r]))return!1;for(let s=0;s<3;s++)for(let r=0;r<3;r++)t[s][r]!==0&&(e[s]=!0,i[r]=!0);for(let s=0;s<3;s++)if(!e[s]||!i[s])return!1;return!0}async function Er(t){const e=t.getReader(),{done:i,value:s}=await e.read();if(i)return e.releaseLock(),new ReadableStream({start(a){a.close()}});if(!s||s.length<2)return e.releaseLock(),new ReadableStream({start(a){s&&a.enqueue(s),a.close()}});const r=s[0]===31&&s[1]===139,n=new ReadableStream({async start(a){try{for(a.enqueue(s);;){const{done:o,value:l}=await e.read();if(o){a.close(),e.releaseLock();break}a.enqueue(l)}}catch(o){a.error(o),e.releaseLock()}}});return r?n.pipeThrough(new DecompressionStream("gzip")):n}function rl(t=[256,256,256],e=[1,1,1],i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1],s=2){const r=new ee;r.littleEndian=!0,r.dims=[3,1,1,1,0,0,0,0],r.dims[0]=Math.max(3,t.length);for(let a=0;a<t.length;a++)r.dims[a+1]=t[a];r.pixDims=[1,1,1,1,1,0,0,0];for(let a=0;a<t.length;a++)r.pixDims[a+1]=e[a];if(i.length===16){let a=0;for(let o=0;o<4;o++)for(let l=0;l<4;l++)r.affine[o][l]=i[a],a++}let n=8;return s===256||s===2?n=8:s===512||s===4?n=16:s===16||s===768||s===8||s===2304?n=32:s===64?n=64:U.warn("Unsupported NIfTI datatypeCode for header creation: "+s),r.datatypeCode=s,r.numBitsPerVoxel=n,r.scl_inter=0,r.scl_slope=1,r.sform_code=2,r.magic="n+1",r.vox_offset=352,r}function Ed(t=[256,256,256],e=[1,1,1],i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1],s=2,r=new Uint8Array){const n=rl(t,e,i,s),a=Ys(n,!1);n.vox_offset=Math.max(352,a.length);const o=Ys(n,!1);if(r.length<1)return o;const l=Math.max(0,n.vox_offset-o.length),c=new Uint8Array(l),h=new Uint8Array(r.buffer,r.byteOffset,r.byteLength),d=n.vox_offset+h.length,f=new Uint8Array(d);return f.set(o,0),f.set(c,o.length),f.set(h,n.vox_offset),f}function nl(t,e=null){if(!t.hdr)throw new Error("NVImage header is not defined for toUint8Array");if(!t.img&&e===null)throw new Error("NVImage image data is not defined for toUint8Array");const i=e!==null,s=JSON.parse(JSON.stringify(t.hdr));s.vox_offset=Math.max(352,s.vox_offset),i&&(s.datatypeCode=2,s.numBitsPerVoxel=8,s.scl_slope=1,s.scl_inter=0);const r=Ys(s,i);let n;if(i){const d=e,f=t.permRAS;if(f&&(f[0]!==1||f[1]!==2||f[2]!==3)){U.debug("Reorienting drawing bytes back to native space for saving...");const u=t.hdr.dims,m=u[1]*u[2]*u[3],g=t.dimsRAS?t.dimsRAS[1]*t.dimsRAS[2]*t.dimsRAS[3]:m;if(d.length!==g)console.warn(`Drawing length (${d.length}) does not match expected RAS voxel count (${g}). Cannot reorient drawing reliably.`),n=d;else if(!t.img2RASstep||!t.img2RASstart||!t.dimsRAS)console.warn("Missing RAS transformation info (img2RASstep, img2RASstart, dimsRAS). Cannot reorient drawing reliably."),n=d;else{const p=t.img2RASstep,A=t.img2RASstart,w=t.dimsRAS,x=new Uint8Array(m);x.fill(0);const y=d;let v=0;for(let D=0;D<w[3];D++){const b=A[2]+D*p[2];for(let C=0;C<w[2];C++){const I=A[1]+C*p[1];for(let M=0;M<w[1];M++){const S=A[0]+M*p[0]+I+b;S>=0&&S<m?x[S]=y[v]:v<y.length&&console.warn(`Calculated native index ${S} is out of bounds [0..${m-1}] during drawing reorientation.`),v++}}}n=x}}else n=d}else{if(!t.img)throw new Error("NVImage image data is null when trying to save non-drawing.");n=new Uint8Array(t.img.buffer,t.img.byteOffset,t.img.byteLength)}const a=r.length,o=Math.max(0,s.vox_offset-a),l=new Uint8Array(o),c=s.vox_offset+n.length,h=new Uint8Array(c);return h.set(r,0),h.set(l,a),h.set(n,s.vox_offset),h}async function al(t,e,i=null){const s=nl(t,i);if(e.toLowerCase().endsWith(".gz"))try{const n=await Z.compress(s,"gzip");return new Uint8Array(n)}catch(n){return U.error("Compression failed:",n),U.warn("Returning uncompressed data due to compression error."),s}else return s}async function Dd(t,e="",i=null){const s=await al(t,e,i);if(!e)return U.debug("saveToDisk: empty file name, returning data as Uint8Array rather than triggering download"),s;try{const r=new Blob([s.buffer],{type:"application/octet-stream"}),n=URL.createObjectURL(r),a=document.createElement("a");a.setAttribute("href",n),a.setAttribute("download",e),a.style.visibility="hidden",document.body.appendChild(a),a.click(),document.body.removeChild(a),setTimeout(()=>URL.revokeObjectURL(n),100)}catch(r){U.error("Failed to trigger download:",r)}return s}function Td(t,e,i,s,r=0,n=!1){if(!t.hdr)throw new Error("getValue: NVImage header is not defined.");if(!n&&!t.img)throw new Error("getValue: NVImage image data is not defined.");if(n&&!t.imaginary)return U.warn("getValue: Attempted to read imaginary data, but none exists."),0;const a=t.hdr.dims[1],o=t.hdr.dims[2],l=t.hdr.dims[3],c=t.permRAS.slice();if(c[0]!==1||c[1]!==2||c[2]!==3){const w=ue(e,i,s,1);Ve(w,w,t.toRASvox),e=w[0],i=w[1],s=w[2]}e=Math.max(0,Math.min(Math.round(e),a-1)),i=Math.max(0,Math.min(Math.round(i),o-1)),s=Math.max(0,Math.min(Math.round(s),l-1)),r=Math.max(0,r);let h=e+i*a+s*a*o;if(t.hdr.datatypeCode===2304){if(!t.img)return 0;if(h*=4,h+2>=t.img.length)return U.warn(`getValue: Calculated index ${h} out of bounds for RGBA data.`),0;const w=t.img[h]*.2126+t.img[h+1]*.7152+t.img[h+2]*.0722;return Math.round(w)}if(t.hdr.datatypeCode===128){if(!t.img)return 0;if(h*=3,h+2>=t.img.length)return U.warn(`getValue: Calculated index ${h} out of bounds for RGB data.`),0;const w=t.img[h]*.2126+t.img[h+1]*.7152+t.img[h+2]*.0722;return Math.round(w)}const d=a*o*l,f=r*d,u=h+f,m=n?t.imaginary:t.img;if(u<0||u>=m.length)return 0;const g=m[u],p=isNaN(t.hdr.scl_slope)||t.hdr.scl_slope===0?1:t.hdr.scl_slope,A=isNaN(t.hdr.scl_inter)?0:t.hdr.scl_inter;return p*g+A}function Md(t,e=[-1,0,0],i=[0,0,0],s="same"){const r=[new Uint8Array,[0,0,0]];if(!t.hdr||!t.img||!t.dimsRAS||!t.img2RASstep||!t.img2RASstart)return U.error("getVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start)."),r;if(e=e.slice(0,3),i=i.slice(0,3),Math.min(...e)<0||Math.min(...i)<0)return U.warn("getVolumeData: Invalid start or end coordinates provided."),r;const n=t.dimsRAS.slice(1,4);for(let p=0;p<3;p++)if(e[p]=Math.max(0,Math.min(Math.round(e[p]),n[p]-1)),i[p]=Math.max(0,Math.min(Math.round(i[p]),n[p]-1)),i[p]<e[p]){const A=i[p];i[p]=e[p],e[p]=A}const a=[i[0]-e[0]+1,i[1]-e[1]+1,i[2]-e[2]+1],o=a[0]*a[1]*a[2];if(o<=0)return U.warn("getVolumeData: Calculated slab size is zero or negative."),r;let l=t.img.constructor;s==="uint8"?l=Uint8Array:s==="int16"?l=Int16Array:s==="uint16"?l=Uint16Array:s==="float32"||s==="scaled"||s==="normalized"||s==="windowed"?l=Float32Array:s==="float64"?l=Float64Array:s!=="same"&&U.warn(`getVolumeData: Unsupported dataType '${s}'. Using 'same'.`);let c;try{c=new l(o)}catch(p){return U.error(`getVolumeData: Failed to create output array for dataType '${s}'.`,p),r}const h=t.img2RASstep,d=t.img2RASstart,f=t.img;let u=0;for(let p=e[2];p<=i[2];p++){const A=d[2]+p*h[2];for(let w=e[1];w<=i[1];w++){const x=d[1]+w*h[1];for(let y=e[0];y<=i[0];y++){const D=d[0]+y*h[0]+x+A;let b=0;D>=0&&D<f.length&&(b=f[D]),c[u++]=b}}}const m=isNaN(t.hdr.scl_slope)||t.hdr.scl_slope===0?1:t.hdr.scl_slope,g=isNaN(t.hdr.scl_inter)?0:t.hdr.scl_inter;if(s==="scaled"||s==="normalized"||s==="windowed"){c instanceof Float32Array||(U.warn(`getVolumeData: Converting output to Float32 for scaling type '${s}'.`),c=Float32Array.from(c));for(let p=0;p<c.length;p++)c[p]=c[p]*m+g}if(s==="normalized"||s==="windowed"){let p=t.cal_min,A=t.cal_max;s==="normalized"&&(p=t.global_min,A=t.global_max);const w=A-p,x=w===0?0:1/w;for(let y=0;y<c.length;y++)c[y]=(c[y]-p)*x,c[y]=Math.max(0,Math.min(c[y],1))}return[c,a]}function Id(t,e=[-1,0,0],i=[0,0,0],s=new Uint8Array){if(!t.hdr||!t.img||!t.dimsRAS||!t.img2RASstep||!t.img2RASstart){U.error("setVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start).");return}if(s.length<1){U.warn("setVolumeData: Input slabData is empty.");return}if(e=e.slice(0,3),i=i.slice(0,3),Math.min(...e)<0||Math.min(...i)<0){U.warn("setVolumeData: Invalid start or end coordinates provided.");return}const r=t.dimsRAS.slice(1,4);for(let d=0;d<3;d++)if(e[d]=Math.max(0,Math.min(Math.round(e[d]),r[d]-1)),i[d]=Math.max(0,Math.min(Math.round(i[d]),r[d]-1)),i[d]<e[d]){const f=i[d];i[d]=e[d],e[d]=f}const n=[i[0]-e[0]+1,i[1]-e[1]+1,i[2]-e[2]+1],a=n[0]*n[1]*n[2];if(a<=0){U.warn("setVolumeData: Calculated slab size is zero or negative.");return}if(s.length<a){U.error(`setVolumeData: Input slabData length (${s.length}) is less than the calculated slab size (${a}).`);return}const o=t.img2RASstep,l=t.img2RASstart,c=t.img;let h=0;for(let d=e[2];d<=i[2];d++){const f=l[2]+d*o[2];for(let u=e[1];u<=i[1];u++){const m=l[1]+u*o[1];for(let g=e[0];g<=i[0];g++){const A=l[0]+g*o[0]+m+f;A>=0&&A<c.length&&(c[A]=s[h]),h++}}}}var ol={};tr(ol,{readMgh:()=>Bd});function Fd(t,e,i){const s=e+i;let r=e;for(;r+12<=s;){const n=t.getInt32(r,!1),a=t.getInt32(r+8,!1);if(r+=12,n!==1){r+=a;continue}if(r+4>s)return"";const o=t.getInt32(r,!1);if(r+=4,o<=1||r+o>s)return"";const l=new Uint8Array(t.buffer,r,o);return new TextDecoder("utf-8").decode(l.slice(0,-1))}return""}async function Bd(t,e){t.hdr||(U.warn("readMgh called before nvImage.hdr was initialized. Creating default."),t.hdr=new ee);const i=t.hdr;i.littleEndian=!1;let s=e,r=new DataView(s);if(s.byteLength>=2&&r.getUint8(0)===31&&r.getUint8(1)===139)try{s=await Z.decompressToBuffer(new Uint8Array(e)),r=new DataView(s)}catch(z){return U.error("Failed to decompress MGZ file.",z),null}if(s.byteLength<284)return U.error("File too small to be a valid MGH/MGZ header."),null;const n=r.getInt32(0,!1),a=r.getInt32(4,!1),o=r.getInt32(8,!1),l=r.getInt32(12,!1),c=r.getInt32(16,!1),h=r.getInt32(20,!1),d=r.getFloat32(30,!1),f=r.getFloat32(34,!1),u=r.getFloat32(38,!1),m=r.getFloat32(42,!1),g=r.getFloat32(46,!1),p=r.getFloat32(50,!1),A=r.getFloat32(54,!1),w=r.getFloat32(58,!1),x=r.getFloat32(62,!1),y=r.getFloat32(66,!1),v=r.getFloat32(70,!1),D=r.getFloat32(74,!1),b=r.getFloat32(78,!1),C=r.getFloat32(82,!1),I=r.getFloat32(86,!1);if(n!==1&&U.warn(`Unexpected MGH version: ${n}.`),a<=0||o<=0||l<=0)return U.error(`Invalid MGH dimensions: ${a}x${o}x${l}`),null;switch(h){case 0:i.numBitsPerVoxel=8,i.datatypeCode=2;break;case 4:i.numBitsPerVoxel=16,i.datatypeCode=4;break;case 1:i.numBitsPerVoxel=32,i.datatypeCode=8;break;case 3:i.numBitsPerVoxel=32,i.datatypeCode=16;break;default:return U.error(`Unsupported MGH data type: ${h}`),null}i.dims[1]=a,i.dims[2]=o,i.dims[3]=l,i.dims[4]=Math.max(1,c),i.dims[0]=i.dims[4]>1?4:3,i.pixDims[1]=Math.abs(d),i.pixDims[2]=Math.abs(f),i.pixDims[3]=Math.abs(u),i.pixDims[4]=0,i.sform_code=1,i.qform_code=0;const M=nt(m*i.pixDims[1],A*i.pixDims[2],y*i.pixDims[3],0,g*i.pixDims[1],w*i.pixDims[2],v*i.pixDims[3],0,p*i.pixDims[1],x*i.pixDims[2],D*i.pixDims[3],0,0,0,0,1),T=ue(i.dims[1]/2,i.dims[2]/2,i.dims[3]/2,1),S=Ct();Ve(S,T,M);const E=H(b-S[0],C-S[1],I-S[2]);i.affine=[[M[0],M[1],M[2],E[0]],[M[4],M[5],M[6],E[1]],[M[8],M[9],M[10],E[2]],[0,0,0,1]],i.vox_offset=284,i.magic="n+1";const B=i.numBitsPerVoxel/8,V=a*o*l*i.dims[4]*B,R=s.byteLength-i.vox_offset;if(R<V)return U.error(`MGH image data size mismatch: expected ${V}, found ${R}`),null;if(R>V){U.warn(`MGH file has extra ${R-V} bytes after image data. Truncating.`);const z=i.vox_offset+V+20,W=s.byteLength-z;if(W>12){const j=Fd(r,z,W),Q=j.toLowerCase().endsWith("lut.txt");Q&&(i.intent_code=1002),U.debug(`First tag 1 string: ${j} isLUT: ${Q}`)}}return s.slice(i.vox_offset,i.vox_offset+V)}var ll={};tr(ll,{readNifti:()=>Ud});async function Ud(t,e){let i=e,s=null;try{if(xn(i)&&(U.debug(`Decompressing NIfTI file: ${t.name}`),i=await oh(i),U.debug(`Decompression complete for: ${t.name}`)),!i||i.byteLength===0)throw new Error("Buffer became invalid after decompression attempt.");if(t.hdr=await Ti(i),t.hdr===null)throw new Error(`Failed to read NIfTI header: ${t.name}`);if(t.hdr.cal_min===0&&t.hdr.cal_max===255&&t.hdr.datatypeCode!==2&&(U.debug(`Resetting suspicious cal_min/max (0/255) for non-uint8 NIfTI: ${t.name}`),t.hdr.cal_min=0,t.hdr.cal_max=0),s=ch(t.hdr,i),s===null)throw new Error(`nifti-reader-js readImage returned null for ${t.name}`);return s}catch(r){return U.error(`Error processing NIfTI file ${t.name}:`,r),t.hdr=null,null}}var cl={};tr(cl,{readNrrd:()=>Pd});async function Pd(t,e,i=null){t.hdr||(U.warn("readNrrd called before nvImage.hdr was initialized. Creating default."),t.hdr=new ee);const s=t.hdr;s.pixDims=[1,1,1,1,1,0,0,0];const r=e.byteLength;let n=null;const a=new Uint8Array(e);for(let D=1;D<r;D++)if(a[D-1]===10&&a[D]===10){const b=e.slice(0,D-1);n=new TextDecoder().decode(b),s.vox_offset=D+1;break}if(n===null)return U.error("readNrrd: could not extract txt"),null;const o=n.split(`
`);if(!o[0].startsWith("NRRD"))return U.error("Invalid NRRD image (magic signature missing)"),null;const l=o.length;let c=!1,h=!1,d=!1;const f=Yt(NaN,0,0,0,1,0,0,0,1),u=H(0,0,0);let m=pc();for(let D=1;D<l;D++){let b=o[D];if((b.length===0||b[0]==="#")&&(b.startsWith("#")||b.trim().length===0))continue;b=b.toLowerCase();const C=b.split(":");if(C.length<2)continue;const I=C[0].trim();let M=C[1].trim();switch(M=M.replaceAll(")"," "),M=M.replaceAll("("," "),M=M.trim(),I){case"data file":d=!0;break;case"encoding":if(M.includes("raw"))c=!1;else if(M.includes("gz"))c=!0;else return U.error("Unsupported NRRD encoding"),null;break;case"type":switch(M){case"uchar":case"unsigned char":case"uint8":case"uint8_t":s.numBitsPerVoxel=8,s.datatypeCode=2;break;case"signed char":case"int8":case"int8_t":s.numBitsPerVoxel=8,s.datatypeCode=256;break;case"short":case"short int":case"signed short":case"signed short int":case"int16":case"int16_t":s.numBitsPerVoxel=16,s.datatypeCode=4;break;case"ushort":case"unsigned short":case"unsigned short int":case"uint16":case"uint16_t":s.numBitsPerVoxel=16,s.datatypeCode=512;break;case"int":case"signed int":case"int32":case"int32_t":s.numBitsPerVoxel=32,s.datatypeCode=8;break;case"uint":case"unsigned int":case"uint32":case"uint32_t":s.numBitsPerVoxel=32,s.datatypeCode=768;break;case"float":s.numBitsPerVoxel=32,s.datatypeCode=16;break;case"double":s.numBitsPerVoxel=64,s.datatypeCode=64;break;default:return U.error("Unsupported NRRD data type: "+M),null}break;case"spacings":{const T=M.split(/[ ,]+/);for(let S=0;S<T.length;S++)s.pixDims[S+1]=parseFloat(T[S])}break;case"sizes":{const T=M.split(/[ ,]+/);s.dims[0]=T.length;for(let S=0;S<T.length;S++)s.dims[S+1]=parseInt(T[S])}break;case"endian":M.includes("little")?s.littleEndian=!0:M.includes("big")&&(s.littleEndian=!1);break;case"space directions":{const T=M.split(/[ ,]+/);if(T.length===9)for(let S=0;S<9;S++)f[S]=parseFloat(T[S])}break;case"space origin":{const T=M.split(/[ ,]+/);T.length===3&&(u[0]=parseFloat(T[0]),u[1]=parseFloat(T[1]),u[2]=parseFloat(T[2]))}break;case"space units":M.includes("microns")&&(h=!0);break;case"space":M.includes("right-anterior-superior")||M.includes("ras")?m=Yt(1,0,0,0,1,0,0,0,1):M.includes("left-anterior-superior")||M.includes("las")?m=Yt(-1,0,0,0,1,0,0,0,1):M.includes("left-posterior-superior")||M.includes("lps")?m=Yt(-1,0,0,0,-1,0,0,0,1):U.warn("Unsupported NRRD space value:",M);break;default:U.warn("Unknown:",I);break}}if(!isNaN(f[0])){s.sform_code=2,h&&(yc(f,f,.001),u[0]*=.001,u[1]*=.001,u[2]*=.001),m[0]<0&&(u[0]=-u[0]),m[4]<0&&(u[1]=-u[1]),m[8]<0&&(u[2]=-u[2]),Do(f,m,f);const D=nt(f[0],f[3],f[6],u[0],f[1],f[4],f[7],u[1],f[2],f[5],f[8],u[2],0,0,0,1);if(!t.vox2mm)return null;const b=t.vox2mm([0,0,0],D),C=t.vox2mm([1,0,0],D);de(C,C,b);const I=t.vox2mm([0,1,0],D);de(I,I,b);const M=t.vox2mm([0,0,1],D);de(M,M,b),s.pixDims[1]=Lt(C),s.pixDims[2]=Lt(I),s.pixDims[3]=Lt(M),s.affine=[[D[0],D[1],D[2],D[3]],[D[4],D[5],D[6],D[7]],[D[8],D[9],D[10],D[11]],[0,0,0,1]]}let g=null;const p=d?i:e,A=d?0:s.vox_offset;if(d&&!p)return U.warn("Missing data: NRRD header describes detached data file but only one URL provided"),null;if(!p||A>=p.byteLength)return U.error(`NRRD data offset (${A}) invalid for buffer length (${(p==null?void 0:p.byteLength)??0})`),null;let w=p.slice(A);if(c)try{U.debug("Decompressing NRRD data..."),w=await Z.decompressToBuffer(new Uint8Array(w)),U.debug("Decompression complete.")}catch(D){return U.error("Failed to decompress NRRD data.",D),null}const x=s.numBitsPerVoxel/8,v=s.dims.slice(1,s.dims[0]+1).reduce((D,b)=>D*Math.max(1,b),1)*x;return w.byteLength<v?(U.error(`NRRD image data size mismatch: expected ${v}, found ${w.byteLength}`),null):(w.byteLength>v&&(U.warn(`NRRD has extra ${w.byteLength-v} bytes after expected image data. Truncating.`),w=w.slice(0,v)),g=w,s.datatypeCode?s.numBitsPerVoxel?g:(U.error("NRRD parsing failed to set numBitsPerVoxel."),null):(U.error("NRRD parsing failed to set datatypeCode."),null))}var Ke=class Fs{constructor(e=null,i="",s="gray",r=1,n=null,a=NaN,o=NaN,l=!0,c=.02,h=!1,d=!1,f="",u=0,m=$.UNKNOWN,g=NaN,p=NaN,A=!0,w=null,x=0){F(this,"name"),F(this,"id"),F(this,"url"),F(this,"headers"),F(this,"_colormap"),F(this,"_opacity"),F(this,"percentileFrac"),F(this,"ignoreZeroVoxels"),F(this,"trustCalMinMax"),F(this,"colormapNegative"),F(this,"colormapLabel"),F(this,"colormapInvert"),F(this,"nFrame4D"),F(this,"frame4D"),F(this,"nTotalFrame4D"),F(this,"cal_minNeg"),F(this,"cal_maxNeg"),F(this,"colorbarVisible",!0),F(this,"modulationImage",null),F(this,"modulateAlpha",0),F(this,"series",[]),F(this,"nVox3D"),F(this,"oblique_angle"),F(this,"maxShearDeg"),F(this,"useQFormNotSForm"),F(this,"colormapType"),F(this,"pixDims"),F(this,"matRAS"),F(this,"pixDimsRAS"),F(this,"obliqueRAS"),F(this,"dimsRAS"),F(this,"permRAS"),F(this,"img2RASstep"),F(this,"img2RASstart"),F(this,"toRAS"),F(this,"toRASvox"),F(this,"frac2mm"),F(this,"frac2mmOrtho"),F(this,"extentsMinOrtho"),F(this,"extentsMaxOrtho"),F(this,"mm2ortho"),F(this,"hdr",null),F(this,"imageType"),F(this,"img"),F(this,"imaginary"),F(this,"v1"),F(this,"fileObject"),F(this,"dims"),F(this,"onColormapChange",()=>{}),F(this,"onOpacityChange",()=>{}),F(this,"mm000"),F(this,"mm100"),F(this,"mm010"),F(this,"mm001"),F(this,"cal_min"),F(this,"cal_max"),F(this,"robust_min"),F(this,"robust_max"),F(this,"global_min"),F(this,"global_max"),F(this,"urlImgData"),F(this,"isManifest"),F(this,"limitFrames4D"),this.init(e,i,s,r,n,a,o,l,c,h,d,f,u,m,g,p,A,w,x)}init(e=null,i="",s="",r=1,n=null,a=NaN,o=NaN,l=!0,c=.02,h=!1,d=!1,f="",u=0,m=$.UNKNOWN,g=NaN,p=NaN,A=!0,w=null,x=0,y=null){const v=s==="";if(v&&(s="gray"),this.name=i,this.imageType=m,this.id=zr(),this._colormap=s,this._opacity=r>1?1:r,this.percentileFrac=c,this.ignoreZeroVoxels=h,this.trustCalMinMax=l,this.colormapNegative=f,this.colormapLabel=w,this.frame4D=u,this.cal_minNeg=g,this.cal_maxNeg=p,this.colorbarVisible=A,this.colormapType=x,this.useQFormNotSForm=d,!e)return;if(v&&this.hdr&&this.hdr.intent_code===1002&&(s="random",this._colormap=s),this.hdr&&typeof this.hdr.magic=="number"&&(this.hdr.magic="n+1"),this.nFrame4D=1,this.hdr)for(let I=4;I<7;I++)this.hdr.dims[I]>1&&(this.nFrame4D*=this.hdr.dims[I]);if(this.frame4D=Math.min(this.frame4D,this.nFrame4D-1),this.nTotalFrame4D=this.nFrame4D,!this.hdr||!y)return;this.nVox3D=this.hdr.dims[1]*this.hdr.dims[2]*this.hdr.dims[3];const D=this.nVox3D*(this.hdr.numBitsPerVoxel/8),b=y.byteLength/D;b!==this.nFrame4D&&(b>0&&b*D===y.byteLength?U.debug("Loading the first "+b+" of "+this.nFrame4D+" volumes"):U.warn("This header does not match voxel data",this.hdr,y.byteLength),this.nFrame4D=b),(this.hdr.intent_code===1007||this.hdr.intent_code===2003)&&this.nFrame4D===3&&this.hdr.datatypeCode===16&&(y=this.float32V1asRGBA(new Float32Array(y)).buffer),(this.hdr.pixDims[1]===0||this.hdr.pixDims[2]===0||this.hdr.pixDims[3]===0)&&U.error("pixDims not plausible",this.hdr),(isNaN(this.hdr.scl_slope)||this.hdr.scl_slope===0)&&(this.hdr.scl_slope=1),isNaN(this.hdr.scl_inter)&&(this.hdr.scl_inter=0);let C=Ta(this.hdr.affine);if(d||!C||this.hdr.qform_code>this.hdr.sform_code){U.debug("spatial transform based on QForm");const I=this.hdr.quatern_b,M=this.hdr.quatern_c,T=this.hdr.quatern_d,S=Math.sqrt(1-(Math.pow(I,2)+Math.pow(M,2)+Math.pow(T,2))),E=this.hdr.pixDims[0]===0?1:this.hdr.pixDims[0],B=[[S*S+I*I-M*M-T*T,2*I*M-2*S*T,2*I*T+2*S*M],[2*I*M+2*S*T,S*S+M*M-I*I-T*T,2*M*T-2*S*I],[2*I*T-2*S*M,2*M*T+2*S*I,S*S+T*T-M*M-I*I]],P=this.hdr.affine;for(let V=0;V<3;V+=1)for(let R=0;R<3;R+=1)P[V][R]=B[V][R]*this.hdr.pixDims[R+1],R===2&&(P[V][R]*=E);P[0][3]=this.hdr.qoffset_x,P[1][3]=this.hdr.qoffset_y,P[2][3]=this.hdr.qoffset_z,this.hdr.affine=P}if(C=Ta(this.hdr.affine),!C){U.debug("Defective NIfTI: spatial transform does not make sense");let I=this.hdr.pixDims[1],M=this.hdr.pixDims[2],T=this.hdr.pixDims[3];(isNaN(I)||I===0)&&(I=1),(isNaN(M)||M===0)&&(M=1),(isNaN(T)||T===0)&&(T=1),this.hdr.pixDims[1]=I,this.hdr.pixDims[2]=M,this.hdr.pixDims[3]=T;const S=[[I,0,0,0],[0,M,0,0],[0,0,T,0],[0,0,0,1]];this.hdr.affine=S}if(this.hdr.datatypeCode!==128&&this.hdr.datatypeCode!==2304&&this.hdr.littleEndian!==Cd()&&this.hdr.numBitsPerVoxel>8){if(this.hdr.numBitsPerVoxel===16){const I=new Uint16Array(y);for(let M=0;M<I.length;M++){const T=I[M];I[M]=((T&255)<<8|T>>8&255)<<16>>16}}else if(this.hdr.numBitsPerVoxel===32){const I=new Uint32Array(y);for(let M=0;M<I.length;M++){const T=I[M];I[M]=(T&255)<<24|(T&65280)<<8|T>>8&65280|T>>24&255}}else if(this.hdr.numBitsPerVoxel===64){const I=this.hdr.numBitsPerVoxel/8,M=new Uint8Array(y);for(let T=0;T<M.length;T+=I){let S=I-1;for(let E=0;E<S;E++){const B=M[T+E];M[T+E]=M[T+S],M[T+S]=B,S--}}}}switch(this.hdr.datatypeCode){case 2:this.img=new Uint8Array(y);break;case 4:this.img=new Int16Array(y);break;case 16:this.img=new Float32Array(y);break;case 64:this.img=new Float64Array(y);break;case 128:this.img=new Uint8Array(y);break;case 512:this.img=new Uint16Array(y);break;case 2304:this.img=new Uint8Array(y);break;case 256:{const I=new Int8Array(y),M=I.length;this.img=new Int16Array(M);for(let T=0;T<M;T++)this.img[T]=I[T];this.hdr.datatypeCode=4,this.hdr.numBitsPerVoxel=16;break}case 1:{const I=this.hdr.dims[1]*this.hdr.dims[2]*Math.max(1,this.hdr.dims[3])*Math.max(1,this.hdr.dims[4]),M=new Uint8Array(y);this.img=new Uint8Array(I);const T=new Uint8Array(8);for(let E=0;E<8;E++)T[E]=Math.pow(2,E);let S=-1;for(let E=0;E<I;E++){const B=E%8;B===0&&S++,M[S]&T[B]&&(this.img[E]=1)}this.hdr.datatypeCode=2,this.hdr.numBitsPerVoxel=8;break}case 768:{const I=new Uint32Array(y),M=I.length;this.img=new Float64Array(M);for(let T=0;T<M-1;T++)this.img[T]=I[T];this.hdr.datatypeCode=64;break}case 8:{const I=new Int32Array(y),M=I.length;this.img=new Float64Array(M);for(let T=0;T<M-1;T++)this.img[T]=I[T];this.hdr.datatypeCode=64;break}case 1024:{const I=new BigInt64Array(y),M=I.length;this.img=new Float64Array(M);for(let T=0;T<M-1;T++)this.img[T]=Number(I[T]);this.hdr.datatypeCode=64;break}case 32:{const I=new Float32Array(y),M=Math.floor(I.length/2);this.imaginary=new Float32Array(M),this.img=new Float32Array(M);let T=0;for(let S=0;S<M-1;S++)this.img[S]=I[T],this.imaginary[S]=I[T+1],T+=2;this.hdr.datatypeCode=16;break}default:throw new Error("datatype "+this.hdr.datatypeCode+" not supported")}this.calculateRAS(),isNaN(a)||(this.hdr.cal_min=a),isNaN(o)||(this.hdr.cal_max=o),this.calMinMax()}static async new(e=null,i="",s="",r=1,n=null,a=NaN,o=NaN,l=!0,c=.02,h=!1,d=!1,f="",u=0,m=$.UNKNOWN,g=NaN,p=NaN,A=!0,w=null,x=0,y){const v=new Fs,D=/(?:\.([^.]+))?$/;let b=D.exec(i)[1]||"";b=b.toUpperCase(),b==="GZ"&&(b=D.exec(i.slice(0,-3))[1],b=b.toUpperCase());let C=null;if(m===$.UNKNOWN&&(m=$.parse(b)),e instanceof ArrayBuffer&&e.byteLength>=2&&m===$.DCM){const I=new Uint8Array(e);(I[0]===92&&I[1]===1||I[1]===92&&I[0]===1)&&(m=$.NII)}switch(v.imageType=m,m){case $.DCM_FOLDER:case $.DCM_MANIFEST:case $.DCM:return;case $.FIB:[C,v.v1]=await v.readFIB(e);break;case $.MIH:case $.MIF:C=await v.readMIF(e,n);break;case $.NHDR:case $.NRRD:if(C=await cl.readNrrd(v,e),C===null)throw new Error(`Failed to parse NHDR/NRRD file ${i}`);break;case $.MHD:case $.MHA:C=await v.readMHA(e,n);break;case $.MGH:case $.MGZ:if(C=await ol.readMgh(v,e),C===null)throw new Error(`Failed to parse MGH/MGZ file ${i}`);break;case $.SRC:C=await v.readSRC(e);break;case $.V:C=v.readECAT(e);break;case $.V16:C=v.readV16(e);break;case $.VMR:C=v.readVMR(e);break;case $.HEAD:C=await v.readHEAD(e,n);break;case $.BMP:C=await v.readBMP(e);break;case $.NPY:C=await v.readNPY(e);break;case $.NPZ:C=await v.readNPZ(e);break;case $.ZARR:C=await v.readZARR(e,y);break;case $.NII:if(C=await ll.readNifti(v,e),C===null)throw new Error(`Failed to parse NIfTI file ${i}.`);break;default:throw new Error("Image type not supported")}return v.init(e,i,s,r,n,a,o,l,c,h,d,f,u,m,g,p,A,w,x,C),v}computeObliqueAngle(e){const i=be(e);rt(i,e);const s=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),r=Math.max(Math.max(Math.abs(i[0]),Math.abs(i[1])),Math.abs(i[2]))/s,n=Math.sqrt(i[4]*i[4]+i[5]*i[5]+i[6]*i[6]),a=Math.max(Math.max(Math.abs(i[4]),Math.abs(i[5])),Math.abs(i[6]))/n,o=Math.sqrt(i[8]*i[8]+i[9]*i[9]+i[10]*i[10]),l=Math.max(Math.max(Math.abs(i[8]),Math.abs(i[9])),Math.abs(i[10]))/o,c=Math.min(Math.min(r,a),l);let h=Math.abs(Math.acos(c)*180/3.141592653);return h>.01?U.warn("Warning voxels not aligned with world space: "+h+` degrees from plumb.
`):h=0,h}float32V1asRGBA(e){e.length!==this.nVox3D*3&&U.warn("float32V1asRGBA() expects "+this.nVox3D*3+"voxels, got ",+e.length);const i=e.slice();this.hdr.datatypeCode=2304,this.nFrame4D=1;for(let l=4;l<7;l++)this.hdr.dims[l]=1;this.hdr.dims[0]=3;const s=new Uint8Array(this.nVox3D*4);let r=1;for(let l=0;l<this.nVox3D*3;l++)isNaN(i[l])||(r=Math.max(r,Math.abs(i[l])));const n=255/r,a=this.nVox3D*2;let o=0;for(let l=0;l<this.nVox3D;l++){const c=i[l],h=i[l+this.nVox3D],d=i[l+a];s[o]=Math.abs(c*n),s[o+1]=Math.abs(h*n),s[o+2]=Math.abs(d*n);const f=+(c>0)*1,u=+(h>0)*2,m=+(d>0)*4;let g=248+f+u+m;Math.abs(c)+Math.abs(h)+Math.abs(d)<.1&&(g=0),s[o+3]=g,o+=4}return s}loadImgV1(e=!1,i=!1,s=!1){let r=this.v1;if(!r&&this.nFrame4D===3&&this.img.constructor===Float32Array&&(r=this.img.slice()),!r)return U.warn("Image does not have V1 data"),!1;if(e)for(let n=0;n<this.nVox3D;n++)r[n]=-r[n];if(i)for(let n=this.nVox3D;n<2*this.nVox3D;n++)r[n]=-r[n];if(s)for(let n=2*this.nVox3D;n<3*this.nVox3D;n++)r[n]=-r[n];return this.img=this.float32V1asRGBA(r),!0}calculateOblique(){if(!this.matRAS)throw new Error("matRAS not defined");if(this.pixDimsRAS===void 0)throw new Error("pixDimsRAS not defined");if(!this.dimsRAS)throw new Error("dimsRAS not defined");this.oblique_angle=this.computeObliqueAngle(this.matRAS);const e=this.vox2mm([0,0,0],this.matRAS),i=this.vox2mm([1/this.pixDimsRAS[1],0,0],this.matRAS),s=this.vox2mm([0,1/this.pixDimsRAS[2],0],this.matRAS),r=this.vox2mm([0,0,1/this.pixDimsRAS[3]],this.matRAS);de(i,i,e),de(s,s,e),de(r,r,e);const n=nt(i[0],i[1],i[2],0,s[0],s[1],s[2],0,r[0],r[1],r[2],0,0,0,0,1);this.obliqueRAS=be(n);const a=Math.abs(90-mr(i,s)*(180/Math.PI)),o=Math.abs(90-mr(i,r)*(180/Math.PI)),l=Math.abs(90-mr(s,r)*(180/Math.PI));this.maxShearDeg=Math.max(Math.max(a,o),l),this.maxShearDeg>.1&&U.warn("Warning: voxels are rhomboidal, maximum shear is %f degrees.",this.maxShearDeg);const c=ue(this.dimsRAS[1],this.dimsRAS[2],this.dimsRAS[3],1),h=be(this.matRAS);rt(h,h);const d=ue(-.5,-.5,-.5,0);ai(h,h,H(d[0],d[1],d[2])),h[0]*=c[0],h[1]*=c[0],h[2]*=c[0],h[4]*=c[1],h[5]*=c[1],h[6]*=c[1],h[8]*=c[2],h[9]*=c[2],h[10]*=c[2],this.frac2mm=be(h);const f=this.pixDimsRAS[1],u=this.pixDimsRAS[2],m=this.pixDimsRAS[3],g=be(h);g[0]=f*c[0],g[1]=0,g[2]=0,g[4]=0,g[5]=u*c[1],g[6]=0,g[8]=0,g[9]=0,g[10]=m*c[2];const p=this.mm2vox([0,0,0],!0);g[12]=(-p[0]-.5)*f,g[13]=(-p[1]-.5)*u,g[14]=(-p[2]-.5)*m,this.frac2mmOrtho=be(g),this.extentsMinOrtho=[g[12],g[13],g[14]],this.extentsMaxOrtho=[g[0]+g[12],g[5]+g[13],g[10]+g[14]],this.mm2ortho=se(),Je(this.mm2ortho,n)}THD_daxes_to_NIFTI(e,i,s){const r=this.hdr;if(r===null)throw new Error("HDR is not set");r.sform_code=2;const n="xxyyzzg";let a=-1,o=-1,l=-1;const c=["x","y","z"];c[0]=n[s[0]],c[1]=n[s[1]],c[2]=n[s[2]];const h=e.slice(0,3),d=i.slice(0,3);for(let f=0;f<3;f++)c[f]==="x"?a=f:c[f]==="y"?o=f:l=f;a<0||o<0||l<0||a===o||a===l||o===l||(r.pixDims[1]=Math.abs(h[0]),r.pixDims[2]=Math.abs(h[1]),r.pixDims[3]=Math.abs(h[2]),r.affine=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],r.affine[0][a]=-h[a],r.affine[1][o]=-h[o],r.affine[2][l]=h[l],r.affine[0][3]=-d[a],r.affine[1][3]=-d[o],r.affine[2][3]=d[l])}SetPixDimFromSForm(){if(!this.hdr)throw new Error("hdr not defined");const e=this.hdr.affine,i=nt(e[0][0],e[0][1],e[0][2],e[0][3],e[1][0],e[1][1],e[1][2],e[1][3],e[2][0],e[2][1],e[2][2],e[2][3],e[3][0],e[3][1],e[3][2],e[3][3]),s=this.vox2mm([0,0,0],i),r=this.vox2mm([1,0,0],i);de(r,r,s);const n=this.vox2mm([0,1,0],i);de(n,n,s);const a=this.vox2mm([0,0,1],i);de(a,a,s),this.hdr.pixDims[1]=Lt(r),this.hdr.pixDims[2]=Lt(n),this.hdr.pixDims[3]=Lt(a)}readECAT(e){this.hdr=new ee;const i=this.hdr;i.dims=[3,1,1,1,0,0,0,0],i.pixDims=[1,1,1,1,1,0,0,0];const s=new DataView(e),r=s.getInt32(0,!1),n=s.getInt16(50,!1);if(r!==1296127058||n<1||n>14)throw new Error("Not a valid ECAT file");let a=512,o=0;const l=[];let c=new Float32Array;for(;;){const h=s.getInt32(a,!1),d=s.getInt32(a+12,!1);if(h+d!==31)break;let f=a+20,u=0,m=0;for(;u<31&&(m=s.getInt32(f,!1),f+=16,m!==0);){u++;let g=m*512;const p=g-512,A=s.getUint16(p,!1);i.dims[1]=s.getUint16(p+4,!1),i.dims[2]=s.getUint16(p+6,!1),i.dims[3]=s.getUint16(p+8,!1);const w=s.getFloat32(p+26,!1);i.pixDims[1]=s.getFloat32(p+34,!1)*10,i.pixDims[2]=s.getFloat32(p+38,!1)*10,i.pixDims[3]=s.getFloat32(p+42,!1)*10,i.pixDims[4]=s.getUint32(p+46,!1)/1e3,l.push(i.pixDims[4]);const x=i.dims[1]*i.dims[2]*i.dims[3],y=new Float32Array(x);if(A===1)for(let D=0;D<x;D++)y[D]=s.getUint8(g)*w,g++;else if(A===6)for(let D=0;D<x;D++)y[D]=s.getUint16(g,!1)*w,g+=2;else if(A===7)for(let D=0;D<x;D++)y[D]=s.getUint32(g,!1)*w,g+=4;else U.warn("Unknown ECAT data type "+A);const v=c.slice(0);c=new Float32Array(v.length+y.length),c.set(v),c.set(y,v.length),o++}if(m===0)break;a+=512}if(i.dims[4]=o,i.pixDims[4]=l[0],o>1){i.dims[0]=4;let h=!1;for(let d=0;d<o;d++)l[d]!==l[0]&&(h=!0);h&&U.warn("Frame durations vary")}return i.sform_code=1,i.affine=[[-i.pixDims[1],0,0,(i.dims[1]-2)*.5*i.pixDims[1]],[0,-i.pixDims[2],0,(i.dims[2]-2)*.5*i.pixDims[2]],[0,0,-i.pixDims[3],(i.dims[3]-2)*.5*i.pixDims[3]],[0,0,0,1]],i.numBitsPerVoxel=32,i.datatypeCode=16,c.buffer}readV16(e){this.hdr=new ee;const i=this.hdr;i.dims=[3,1,1,1,0,0,0,0],i.pixDims=[1,1,1,1,1,0,0,0];const s=new DataView(e);return i.dims[1]=s.getUint16(0,!0),i.dims[2]=s.getUint16(2,!0),i.dims[3]=s.getUint16(4,!0),2*i.dims[1]*i.dims[2]*i.dims[3]+6!==e.byteLength&&U.warn("This does not look like a valid BrainVoyager V16 file"),i.numBitsPerVoxel=16,i.datatypeCode=512,U.warn("Warning: V16 files have no spatial transforms"),i.affine=[[0,0,-i.pixDims[1],(i.dims[1]-2)*.5*i.pixDims[1]],[-i.pixDims[2],0,0,(i.dims[2]-2)*.5*i.pixDims[2]],[0,-i.pixDims[3],0,(i.dims[3]-2)*.5*i.pixDims[3]],[0,0,0,1]],i.littleEndian=!0,e.slice(6)}async readNPY(e){function i(y){return{"|b1":1,"<i1":1,"<u1":1,"<i2":2,"<u2":2,"<i4":4,"<u4":4,"<f4":4,"<f8":8}[y]??1}function s(y){return{"|b1":2,"<i1":256,"<u1":2,"<i2":4,"<u2":512,"<i4":8,"<u4":768,"<f4":16,"<f8":64}[y]??16}const r=new DataView(e),n=[r.getUint8(0),r.getUint8(1),r.getUint8(2),r.getUint8(3),r.getUint8(4),r.getUint8(5)],a=[147,78,85,77,80,89];if(!n.every((y,v)=>y===a[v]))throw new Error("Not a valid NPY file: Magic number mismatch");const o=r.getUint16(8,!0),l=new TextDecoder("utf-8").decode(e.slice(10,10+o)),c=l.match(/'shape': \((.*?)\)/);if(!c)throw new Error("Invalid NPY header: Shape not found");const h=c[1].split(",").map(y=>y.trim()).filter(y=>y!=="").map(Number),d=l.match(/'descr': '([^']+)'/);if(!d)throw new Error("Invalid NPY header: Data type not found");const f=d[1],u=h.reduce((y,v)=>y*v,1),m=10+o,g=e.slice(m,m+u*i(f)),p=h.length>0?h[h.length-1]:1,A=h.length>1?h[h.length-2]:1,w=h.length>2?h[h.length-3]:1;this.hdr=new ee;const x=this.hdr;return x.dims=[3,p,A,w,0,0,0,0],x.pixDims=[1,1,1,1,1,0,0,0],x.affine=[[x.pixDims[1],0,0,-(x.dims[1]-2)*.5*x.pixDims[1]],[0,-x.pixDims[2],0,(x.dims[2]-2)*.5*x.pixDims[2]],[0,0,-x.pixDims[3],(x.dims[3]-2)*.5*x.pixDims[3]],[0,0,0,1]],x.numBitsPerVoxel=i(f)*8,x.datatypeCode=s(f),g}async readNPZ(e){const i=new il(e);for(let s=0;s<i.entries.length;s++){const r=i.entries[s];if(r.fileName.toLowerCase().endsWith(".npy")){const n=await r.extract();return await this.readNPY(n.buffer)}}}async imageDataFromArrayBuffer(e){return new Promise((i,s)=>{const r=new Blob([e]),n=URL.createObjectURL(r),a=new Image;a.crossOrigin="Anonymous",a.src=n,a.onload=()=>{URL.revokeObjectURL(n);const o=document.createElement("canvas");o.width=a.width,o.height=a.height;const l=o.getContext("2d");if(!l){s(new Error("Failed to get 2D context"));return}l.drawImage(a,0,0),i(l.getImageData(0,0,a.width,a.height))},a.onerror=o=>{URL.revokeObjectURL(n),s(o)}})}async readBMP(e){const i=await this.imageDataFromArrayBuffer(e),{width:s,height:r,data:n}=i;this.hdr=new ee;const a=this.hdr;a.dims=[3,s,r,1,0,0,0,0],a.pixDims=[1,1,1,1,1,0,0,0],a.affine=[[a.pixDims[1],0,0,-(a.dims[1]-2)*.5*a.pixDims[1]],[0,-a.pixDims[2],0,(a.dims[2]-2)*.5*a.pixDims[2]],[0,0,-a.pixDims[3],(a.dims[3]-2)*.5*a.pixDims[3]],[0,0,0,1]],a.numBitsPerVoxel=8,a.datatypeCode=2304;let o=!0;for(let l=0;l<n.length;l+=4)if(n[l]!==n[l+1]||n[l]!==n[l+2]){o=!1;break}if(o){a.datatypeCode=2;const l=new Uint8Array(s*r);for(let c=0,h=0;c<n.length;c+=4,h++)l[h]=n[c];return l.buffer}return n.buffer}async readZARR(e,i){let{width:s,height:r,depth:n=1,data:a}=i??{},o=s*r*n*3,l=o===a.length;if(l||(o=s*r*n,n===3&&(l=!0,n=1)),o!==a.length)throw new Error(`Expected RGB ${s}${r}${n}3 =  ${o}, but ZARR length ${a.length}`);this.hdr=new ee;const c=this.hdr;if(c.dims=[3,s,r,n,1,1,1,1],c.pixDims=[1,1,1,1,0,0,0,0],c.affine=[[c.pixDims[1],0,0,-(c.dims[1]-2)*.5*c.pixDims[1]],[0,-c.pixDims[2],0,(c.dims[2]-2)*.5*c.pixDims[2]],[0,0,-c.pixDims[3],(c.dims[3]-2)*.5*c.pixDims[3]],[0,0,0,1]],!l){if(c.numBitsPerVoxel=8,c.datatypeCode=2,a instanceof Uint8Array){const m=new ArrayBuffer(a.length);return new Uint8Array(m).set(a),m}return a}c.numBitsPerVoxel=24,c.datatypeCode=128;function h(m,g,p,A){const w=g*p,x=new Uint8Array(w*A*3),y=new Array(A);for(let b=0;b<A;b++)y[b]=w*3*b;let v=0,D=0;for(let b=0;b<w;b++){for(let C=0;C<A;C++)x[y[C]+D]=m[v++],x[y[C]+D+1]=m[v++],x[y[C]+D+2]=m[v++];D+=3}return x}const d=h(a,c.dims[1],c.dims[2],c.dims[3]),f=new ArrayBuffer(d.length);return new Uint8Array(f).set(d),f}readVMR(e){this.hdr=new ee;const i=this.hdr;i.dims=[3,1,1,1,0,0,0,0],i.pixDims=[1,1,1,1,1,0,0,0];const s=new DataView(e),r=s.getUint16(0,!0);r!==4&&U.warn("Not a valid version 4 VMR image"),i.dims[1]=s.getUint16(2,!0),i.dims[2]=s.getUint16(4,!0),i.dims[3]=s.getUint16(6,!0);const n=i.dims[1]*i.dims[2]*i.dims[3];if(r>=4){let a=8+n;const o=s.getUint32(a+88,!0);if(a=a+92,o>0){const l=e.byteLength;for(let c=0;c<o;c++){for(;a<l&&s.getUint8(a)!==0;)a++;for(a++,a+=4;a<l&&s.getUint8(a)!==0;)a++;a++;const h=s.getUint32(a,!0);a+=4;for(let d=0;d<h;d++)a+=4}}i.pixDims[1]=s.getFloat32(a+2,!0),i.pixDims[2]=s.getFloat32(a+6,!0),i.pixDims[3]=s.getFloat32(a+10,!0)}return U.warn("Warning: VMR spatial transform not implemented"),i.affine=[[0,0,-i.pixDims[1],(i.dims[1]-2)*.5*i.pixDims[1]],[-i.pixDims[2],0,0,(i.dims[2]-2)*.5*i.pixDims[2]],[0,-i.pixDims[3],0,(i.dims[3]-2)*.5*i.pixDims[3]],[0,0,0,1]],U.debug(i),i.numBitsPerVoxel=8,i.datatypeCode=2,e.slice(8,8+n)}async readFIB(e){this.hdr=new ee;const i=this.hdr;i.littleEndian=!1,i.dims=[3,1,1,1,0,0,0,0],i.pixDims=[1,1,1,1,1,0,0,0];const s=await Z.readMatV4(e,!0);if(!("dimension"in s)||!("dti_fa"in s))throw new Error("Not a valid DSIstudio FIB file");const r="index0"in s&&"index1"in s&&"index2"in s&&"odf_vertices"in s;i.numBitsPerVoxel=32,i.datatypeCode=16,i.dims[1]=s.dimension[0],i.dims[2]=s.dimension[1],i.dims[3]=s.dimension[2],i.dims[4]=1,i.pixDims[1]=s.voxel_size[0],i.pixDims[2]=s.voxel_size[1],i.pixDims[3]=s.voxel_size[2],i.sform_code=1;const n=(i.dims[1]-1)*.5*i.pixDims[1],a=(i.dims[2]-1)*.5*i.pixDims[2],o=(i.dims[3]-1)*.5*i.pixDims[3];i.affine=[[i.pixDims[1],0,0,-n],[0,-i.pixDims[2],0,a],[0,0,i.pixDims[2],-o],[0,0,0,1]],i.littleEndian=!0;const l=i.dims[1]*i.dims[2]*i.dims[3],c=l*Math.ceil(i.numBitsPerVoxel/8),h=c*i.dims[4],d=new Uint8Array(new ArrayBuffer(l*4*3));if(r){const g=i.dims[1]*i.dims[2]*i.dims[3],p=new Float32Array(g),A=new Float32Array(g),w=new Float32Array(g),x=s.index0,y=s.odf_vertices;for(let v=0;v<g;v++){const D=x[v]*3;p[v]=y[D+0],A[v]=y[D+1],w[v]=-y[D+2]}d.set(new Uint8Array(p.buffer,p.byteOffset,p.byteLength),0*c),d.set(new Uint8Array(A.buffer,A.byteOffset,A.byteLength),1*c),d.set(new Uint8Array(w.buffer,w.byteOffset,w.byteLength),2*c)}"report"in s&&(i.description=new TextDecoder().decode(s.report.subarray(0,Math.min(79,s.report.byteLength))));const f=new Uint8Array(new ArrayBuffer(h)),u=Float32Array.from(s.dti_fa);if("mask"in s){let g=1;"dti_fa_slope"in s&&(g=s.dti_fa_slope[0]);let p=1;"dti_fa_inter"in s&&(p=s.dti_fa_inter[0]);const A=i.dims[1]*i.dims[2]*i.dims[3],w=s.mask,x=new Float32Array(A);let y=0;for(let v=0;v<A;v++)w[v]!==0&&(x[v]=u[y]*g+p,y++);return[x.buffer,new Float32Array(d.buffer)]}const m=new Uint8Array(u.buffer,u.byteOffset,u.byteLength);return f.set(m,0),[f.buffer,new Float32Array(d.buffer)]}async readSRC(e){this.hdr=new ee;const i=this.hdr;i.littleEndian=!1,i.dims=[3,1,1,1,0,0,0,0],i.pixDims=[1,1,1,1,1,0,0,0];const s=await Z.readMatV4(e);if(!("dimension"in s)||!("image0"in s))throw new Error("Not a valid DSIstudio SRC file");let r=0,n=0;for(const[u,m]of Object.entries(s))if(u.startsWith("image")){if(r===0?n=m.length:n!==m.length&&(n=-1),m.constructor!==Uint16Array)throw new Error("DSIstudio SRC files always use Uint16 datatype");r++}if(n<1||r<1)throw new Error("SRC file not valid DSI Studio data. The image(s) should have the same length");i.numBitsPerVoxel=16,i.datatypeCode=512,i.dims[1]=s.dimension[0],i.dims[2]=s.dimension[1],i.dims[3]=s.dimension[2],i.dims[4]=r,i.dims[4]>1&&(i.dims[0]=4),i.pixDims[1]=s.voxel_size[0],i.pixDims[2]=s.voxel_size[1],i.pixDims[3]=s.voxel_size[2],i.sform_code=1;const a=(i.dims[1]-1)*.5*i.pixDims[1],o=(i.dims[2]-1)*.5*i.pixDims[2],l=(i.dims[3]-1)*.5*i.pixDims[3];i.affine=[[i.pixDims[1],0,0,-a],[0,-i.pixDims[2],0,o],[0,0,i.pixDims[2],-l],[0,0,0,1]],i.littleEndian=!0;const c=i.dims[1]*i.dims[2]*i.dims[3]*(i.numBitsPerVoxel/8),h=c*i.dims[4],d=new Uint8Array(new ArrayBuffer(h));let f=0;for(let u=0;u<r;u++){const m=s[`image${u}`],g=new Uint8Array(m.buffer,m.byteOffset,m.byteLength);d.set(g,f),f+=c}return"report"in s&&(i.description=new TextDecoder().decode(s.report.subarray(0,Math.min(79,s.report.byteLength)))),d.buffer}async readHEAD(e,i){this.hdr=new ee;const s=this.hdr;s.dims[0]=3,s.pixDims=[1,1,1,1,1,0,0,0];let r=[0,0,0],n=[0,0,0],a=[1,1,1];const l=new TextDecoder().decode(e).split(/\r?\n/),c=(e.byteLength+8)%16,h=e.byteLength+(16-c);U.debug(e.byteLength,"len",h);const d=new ArrayBuffer(h);new Uint8Array(d).set(new Uint8Array(e));const f=new zo(h+8,42,d,!0);s.addExtension(f),s.extensionCode=42,s.extensionFlag[0]=1,s.extensionSize=h+8;const u=l.length;let m=0,g=!1;for(;m<u;){let A=l[m];if(m++,!A.startsWith("type"))continue;const w=A.includes("integer-attribute"),x=A.includes("float-attribute");if(A=l[m],m++,!A.startsWith("name"))continue;let y=A.split("= ");const v=y[1];A=l[m],m++,y=A.split("= ");let D=parseInt(y[1]);if(!(D<1)){if(A=l[m],m++,y=A.trim().split(/\s+/),x||w){for(;y.length<D;){A=l[m],m++;const b=A.trim().split(/\s+/);y.push(...b)}for(let b=0;b<D;b++)y[b]=parseFloat(y[b])}switch(v){case"BYTEORDER_STRING":y[0].includes("LSB_FIRST")?s.littleEndian=!0:y[0].includes("MSB_FIRST")&&(s.littleEndian=!1);break;case"BRICK_TYPES":{s.dims[4]=D;const b=parseInt(y[0]);b===0?(s.numBitsPerVoxel=8,s.datatypeCode=2):b===1?(s.numBitsPerVoxel=16,s.datatypeCode=4):b===3?(s.numBitsPerVoxel=32,s.datatypeCode=16):U.warn("Unknown BRICK_TYPES ",b)}break;case"IJK_TO_DICOM_REAL":if(D<12)break;g=!0,s.sform_code=2,s.affine=[[-y[0],-y[1],-y[2],-y[3]],[-y[4],-y[5],-y[6],-y[7]],[y[8],y[9],y[10],y[11]],[0,0,0,1]];break;case"DATASET_DIMENSIONS":D=Math.max(D,3);for(let b=0;b<D;b++)s.dims[b+1]=y[b];break;case"ORIENT_SPECIFIC":r=y;break;case"ORIGIN":n=y;break;case"DELTA":a=y;break;case"TAXIS_FLOATS":s.pixDims[4]=y[0];break;default:U.warn("Unknown:",v)}}}g?this.SetPixDimFromSForm():this.THD_daxes_to_NIFTI(a,n,r);const p=s.numBitsPerVoxel/8*s.dims[1]*s.dims[2]*s.dims[3]*s.dims[4];if(!i)throw new Error("pairedImgData not set");return i.byteLength<p?await Z.decompressToBuffer(new Uint8Array(i)):i.slice(0)}async readMHA(e,i){const s=e.byteLength;if(s<20)throw new Error("File too small to be VTK: bytes = "+e.byteLength);const r=new Uint8Array(e);let n=0;function a(g){return g===10||g===13}function o(){for(;n<s&&a(r[n]);)n++;const g=n;for(;n<s&&!a(r[n]);)n++;return n-g<2?"":new TextDecoder().decode(e.slice(g,n))}let l=o();this.hdr=new ee;const c=this.hdr;c.pixDims=[1,1,1,1,1,0,0,0],c.dims=[1,1,1,1,1,1,1,1],c.littleEndian=!0;let h=!1,d=!1;const f=Yt(NaN,0,0,0,1,0,0,0,1),u=H(0,0,0);for(;l!=="";){let g=l.split(" ");if(g.length>2&&(g=g.slice(2)),l.startsWith("BinaryDataByteOrderMSB")&&g[0].includes("False")&&(c.littleEndian=!0),l.startsWith("BinaryDataByteOrderMSB")&&g[0].includes("True")&&(c.littleEndian=!1),l.startsWith("CompressedData")&&g[0].includes("True")&&(h=!0),l.startsWith("TransformMatrix"))for(let p=0;p<9;p++)f[p]=parseFloat(g[p]);if(l.startsWith("Offset"))for(let p=0;p<Math.min(g.length,3);p++)u[p]=parseFloat(g[p]);if(l.startsWith("ElementSpacing"))for(let p=0;p<g.length;p++)c.pixDims[p+1]=parseFloat(g[p]);if(l.startsWith("DimSize")){c.dims[0]=g.length;for(let p=0;p<g.length;p++)c.dims[p+1]=parseInt(g[p])}if(l.startsWith("ElementType"))switch(g[0]){case"MET_UCHAR":c.numBitsPerVoxel=8,c.datatypeCode=2;break;case"MET_CHAR":c.numBitsPerVoxel=8,c.datatypeCode=256;break;case"MET_SHORT":c.numBitsPerVoxel=16,c.datatypeCode=4;break;case"MET_USHORT":c.numBitsPerVoxel=16,c.datatypeCode=512;break;case"MET_INT":c.numBitsPerVoxel=32,c.datatypeCode=8;break;case"MET_UINT":c.numBitsPerVoxel=32,c.datatypeCode=768;break;case"MET_FLOAT":c.numBitsPerVoxel=32,c.datatypeCode=16;break;case"MET_DOUBLE":c.numBitsPerVoxel=64,c.datatypeCode=64;break;default:throw new Error("Unsupported MHA data type: "+g[0])}if(l.startsWith("ObjectType")&&!g[0].includes("Image")&&U.warn("Only able to read ObjectType = Image, not "+l),l.startsWith("ElementDataFile")){g[0]!=="LOCAL"&&(d=!0);break}l=o()}const m=Yt(c.pixDims[1],0,0,0,c.pixDims[2],0,0,0,c.pixDims[3]);for(Do(f,f,m),c.affine=[[-f[0],-f[3],-f[6],-u[0]],[-f[1],-f[4],-f[7],-u[1]],[f[2],f[5],f[8],u[2]],[0,0,0,1]];r[n]===10;)n++;return c.vox_offset=n,d&&i?h?await Z.decompressToBuffer(new Uint8Array(i.slice(0))):i.slice(0):h?await Z.decompressToBuffer(new Uint8Array(e.slice(c.vox_offset))):e.slice(c.vox_offset)}async readMIF(e,i){this.hdr=new ee;const s=this.hdr;s.pixDims=[1,1,1,1,1,0,0,0],s.dims=[1,1,1,1,1,1,1,1];let r=e.byteLength;if(r<20)throw new Error("File too small to be MIF: bytes = "+r);const n=new Uint8Array(e);n[0]===31&&n[1]===139&&(U.debug("MIF with GZ decompression"),e=await Z.decompressToBuffer(new Uint8Array(e)),r=e.byteLength);let a=0;function o(){for(;a<r&&n[a]===10;)a++;const S=a;for(;a<r&&n[a]!==10;)a++;return a++,a-S<1?"":new TextDecoder().decode(e.slice(S,a-1))}let l=o();if(!l.startsWith("mrtrix image"))throw new Error("Not a valid MIF file");const c=[];let h=!1,d=0,f=0,u=!1;for(l=o();a<r&&!l.startsWith("END");){let S=l.split(":");if(l=o(),S.length<2)break;const E=S[0];S=S[1].split(",");for(let B=0;B<S.length;B++)S[B]=S[B].trim();switch(E){case"dim":s.dims[0]=S.length;for(let B=0;B<S.length;B++)s.dims[B+1]=parseInt(S[B]);break;case"vox":for(let B=0;B<S.length;B++)s.pixDims[B+1]=parseFloat(S[B]),isNaN(s.pixDims[B+1])&&(s.pixDims[B+1]=0);break;case"layout":for(let B=0;B<S.length;B++)c.push(parseInt(S[B]));break;case"datatype":{const B=S[0];B.startsWith("Bit")?(h=!0,s.datatypeCode=2):B.startsWith("Int8")?s.datatypeCode=256:B.startsWith("UInt8")?s.datatypeCode=2:B.startsWith("Int16")?s.datatypeCode=4:B.startsWith("UInt16")?s.datatypeCode=512:B.startsWith("Int32")?s.datatypeCode=8:B.startsWith("UInt32")?s.datatypeCode=768:B.startsWith("Float32")?s.datatypeCode=16:B.startsWith("Float64")?s.datatypeCode=64:U.warn("Unsupported datatype "+B),B.includes("8")?s.numBitsPerVoxel=8:B.includes("16")?s.numBitsPerVoxel=16:B.includes("32")?s.numBitsPerVoxel=32:B.includes("64")&&(s.numBitsPerVoxel=64),s.littleEndian=!0,B.endsWith("LE")&&(s.littleEndian=!0),B.endsWith("BE")&&(s.littleEndian=!1)}break;case"transform":if(d>2||S.length!==4)break;s.affine[d][0]=parseFloat(S[0]),s.affine[d][1]=parseFloat(S[1]),s.affine[d][2]=parseFloat(S[2]),s.affine[d][3]=parseFloat(S[3]),d++;break;case"comments":s.description=S[0].substring(0,Math.min(79,S[0].length));break;case"RepetitionTime":f=parseFloat(S[0]);break;case"file":u=!S[0].startsWith(". "),u||(S=S[0].split(" "),s.vox_offset=parseInt(S[1]));break}}const m=s.dims[0];m>5&&U.warn("reader only designed for a maximum of 5 dimensions (XYZTD)");let g=1;for(let S=0;S<m;S++)g*=Math.max(s.dims[S+1],1);for(let S=0;S<3;S++)for(let E=0;E<3;E++)s.affine[S][E]*=s.pixDims[E+1];U.debug("mif affine:"+s.affine[0]),f>0&&(s.pixDims[4]=f),u&&!i&&U.warn("MIH header provided without paired image data");let p;if(i&&u)p=i.slice(0);else if(h){s.numBitsPerVoxel=8;const S=new Uint8Array(g),E=e.slice(s.vox_offset,s.vox_offset+Math.ceil(g/8)),B=new Uint8Array(E);let P=0;for(let V=0;V<g;V++){const R=V%8;S[V]=B[P]>>7-R&1,R===7&&P++}p=S.buffer}else p=e.slice(s.vox_offset,s.vox_offset+g*(s.numBitsPerVoxel/8));c.length!==s.dims[0]&&U.warn("dims does not match layout");let A=1;const w=[1,1,1,1,1],x=[!1,!1,!1,!1,!1];for(let S=0;S<c.length;S++)for(let E=0;E<c.length;E++)Math.abs(c[E])===S&&(w[E]=A,(c[E]<0||Object.is(c[E],-0))&&(x[E]=!0),A*=s.dims[E+1]);let y=Z.range(0,s.dims[1]-1,1);x[0]&&(y=Z.range(s.dims[1]-1,0,-1));for(let S=0;S<s.dims[1];S++)y[S]*=w[0];let v=Z.range(0,s.dims[2]-1,1);x[1]&&(v=Z.range(s.dims[2]-1,0,-1));for(let S=0;S<s.dims[2];S++)v[S]*=w[1];let D=Z.range(0,s.dims[3]-1,1);x[2]&&(D=Z.range(s.dims[3]-1,0,-1));for(let S=0;S<s.dims[3];S++)D[S]*=w[2];let b=Z.range(0,s.dims[4]-1,1);x[3]&&(b=Z.range(s.dims[4]-1,0,-1));for(let S=0;S<s.dims[4];S++)b[S]*=w[3];let C=Z.range(0,s.dims[5]-1,1);x[4]&&(C=Z.range(s.dims[5]-1,0,-1));for(let S=0;S<s.dims[5];S++)C[S]*=w[4];let I=0,M,T;switch(s.datatypeCode){case 256:M=new Int8Array(p),T=new Int8Array(g);break;case 2:M=new Uint8Array(p),T=new Uint8Array(g);break;case 4:M=new Int16Array(p),T=new Int16Array(g);break;case 512:M=new Uint16Array(p),T=new Uint16Array(g);break;case 8:M=new Int32Array(p),T=new Int32Array(g);break;case 768:M=new Uint32Array(p),T=new Uint32Array(g);break;case 16:M=new Float32Array(p),T=new Float32Array(g);break;case 64:M=new Float64Array(p),T=new Float64Array(g);break;default:throw new Error("unknown datatypeCode")}for(let S=0;S<s.dims[5];S++)for(let E=0;E<s.dims[4];E++)for(let B=0;B<s.dims[3];B++)for(let P=0;P<s.dims[2];P++)for(let V=0;V<s.dims[1];V++)T[I]=M[y[V]+v[P]+D[B]+b[E]+C[S]],I++;return T.buffer}calculateRAS(){if(!this.hdr)throw new Error("hdr not set");const e=this.hdr.affine,i=this.hdr,s=Yt(Math.abs(e[0][0]),Math.abs(e[0][1]),Math.abs(e[0][2]),Math.abs(e[1][0]),Math.abs(e[1][1]),Math.abs(e[1][2]),Math.abs(e[2][0]),Math.abs(e[2][1]),Math.abs(e[2][2])),r=[1,1,1];s[3]>s[0]&&(r[0]=2),s[6]>s[0]&&s[6]>s[3]&&(r[0]=3),r[1]=1,r[0]===1?s[4]>s[7]?r[1]=2:r[1]=3:r[0]===2?s[1]>s[7]?r[1]=1:r[1]=3:s[1]>s[4]?r[1]=1:r[1]=2,r[2]=6-r[1]-r[0];let n=[1,2,3];n[r[0]-1]=1,n[r[1]-1]=2,n[r[2]-1]=3;let a=nt(e[0][0],e[0][1],e[0][2],e[0][3],e[1][0],e[1][1],e[1][2],e[1][3],e[2][0],e[2][1],e[2][2],e[2][3],0,0,0,1);this.mm000=this.vox2mm([-.5,-.5,-.5],a),this.mm100=this.vox2mm([i.dims[1]-.5,-.5,-.5],a),this.mm010=this.vox2mm([-.5,i.dims[2]-.5,-.5],a),this.mm001=this.vox2mm([-.5,-.5,i.dims[3]-.5],a);const o=se();Ac(o,a);for(let p=0;p<3;p++)for(let A=0;A<3;A++)o[p*4+A]=a[p*4+n[A]-1];const l=[0,0,0];o[0]<0&&(l[0]=1),o[5]<0&&(l[1]=1),o[10]<0&&(l[2]=1),this.dimsRAS=[i.dims[0],i.dims[n[0]],i.dims[n[1]],i.dims[n[2]]],this.pixDimsRAS=[i.pixDims[0],i.pixDims[n[0]],i.pixDims[n[1]],i.pixDims[n[2]]],this.permRAS=n.slice();for(let p=0;p<3;p++)l[p]===1&&(this.permRAS[p]=-this.permRAS[p]);if(this.arrayEquals(n,[1,2,3])&&this.arrayEquals(l,[0,0,0])){this.toRAS=se(),this.matRAS=be(a),this.calculateOblique(),this.img2RASstep=[1,this.dimsRAS[1],this.dimsRAS[1]*this.dimsRAS[2]],this.img2RASstart=[0,0,0];return}To(a),a[0+0*4]=1-l[0]*2,a[1+1*4]=1-l[1]*2,a[2+2*4]=1-l[2]*2,a[3+0*4]=(i.dims[n[0]]-1)*l[0],a[3+1*4]=(i.dims[n[1]]-1)*l[1],a[3+2*4]=(i.dims[n[2]]-1)*l[2];const c=se();Je(c,a),Rt(c,c,o),this.matRAS=be(c),a=nt(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),a[n[0]-1+0*4]=-l[0]*2+1,a[n[1]-1+1*4]=-l[1]*2+1,a[n[2]-1+2*4]=-l[2]*2+1,a[3+0*4]=l[0],a[3+1*4]=l[1],a[3+2*4]=l[2],this.toRAS=be(a),a[3]=0,a[7]=0,a[11]=0,a[12]=0,(this.permRAS[0]===-1||this.permRAS[1]===-1||this.permRAS[2]===-1)&&(a[12]=i.dims[1]-1),a[13]=0,(this.permRAS[0]===-2||this.permRAS[1]===-2||this.permRAS[2]===-2)&&(a[13]=i.dims[2]-1),a[14]=0,(this.permRAS[0]===-3||this.permRAS[1]===-3||this.permRAS[2]===-3)&&(a[14]=i.dims[3]-1),this.toRASvox=be(a),U.debug(this.hdr.dims),U.debug(this.dimsRAS);const h=this.hdr;n=this.permRAS;const d=[Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2])],f=[h.dims[d[0]],h.dims[d[1]],h.dims[d[2]]],u=[1,h.dims[1],h.dims[1]*h.dims[2]],m=[u[d[0]-1],u[d[1]-1],u[d[2]-1]],g=[0,0,0];for(let p=0;p<3;p++)n[p]<0&&(g[p]=m[p]*(f[p]-1),m[p]=-m[p]);this.img2RASstep=m,this.img2RASstart=g,this.calculateOblique()}async hdr2RAS(e=1){if(!this.permRAS)throw new Error("permRAS undefined");if(!this.hdr)throw new Error("hdr undefined");const i=Ys({...this.hdr},!1),s=await Ti(i.buffer,!0);e===1?(s.dims[0]=3,s.dims[4]=1):e>1&&(s.dims[0]=4,s.dims[4]=e);const r=this.permRAS.slice();if(r[0]===1&&r[1]===2&&r[2]===3)return s;s.qform_code=0;for(let a=1;a<4;a++)s.dims[a]=this.dimsRAS[a];for(let a=0;a<this.pixDimsRAS.length;a++)s.pixDims[a]=this.pixDimsRAS[a];let n=0;for(let a=0;a<4;a++)for(let o=0;o<4;o++)s.affine[a][o]=this.matRAS[n],n++;return s}img2RAS(e=0){if(!this.permRAS)throw new Error("permRAS undefined");if(!this.img)throw new Error("img undefined");if(!this.hdr)throw new Error("hdr undefined");const i=this.permRAS.slice();if(i[0]===1&&i[1]===2&&i[2]===3)return this.img;const s=this.hdr,r=s.dims[1]*s.dims[2]*s.dims[3];let n=e*r;(n+r>this.img.length||n<0)&&(n=0,U.warn(`img2RAS nVolume (${e}) out of bounds (${e}+1)${r} > ${this.img.length}`));const a=this.img.slice(0,r),o=[Math.abs(i[0]),Math.abs(i[1]),Math.abs(i[2])],l=[s.dims[o[0]],s.dims[o[1]],s.dims[o[2]]],c=[1,s.dims[1],s.dims[1]*s.dims[2]],h=[c[o[0]-1],c[o[1]-1],c[o[2]-1]],d=[0,0,0];for(let u=0;u<3;u++)i[u]<0&&(d[u]=h[u]*(l[u]-1),h[u]=-h[u]);let f=0;for(let u=0;u<l[2];u++){const m=d[2]+u*h[2];for(let g=0;g<l[1];g++){const p=d[1]+g*h[1];for(let A=0;A<l[0];A++){const w=d[0]+A*h[0];a[f]=this.img[w+p+m+n],f++}}}return a}vox2mm(e,i){const s=be(i);rt(s,s);const r=ue(e[0],e[1],e[2],1);return Ve(r,r,s),H(r[0],r[1],r[2])}mm2vox(e,i=!1){if(!this.matRAS)throw new Error("matRAS undefined");const s=be(this.matRAS),r=be(s);rt(r,s),Je(r,r);const n=ue(e[0],e[1],e[2],1);Ve(n,n,r);const a=H(n[0],n[1],n[2]);return i?a:[Math.round(a[0]),Math.round(a[1]),Math.round(a[2])]}arrayEquals(e,i){return Array.isArray(e)&&Array.isArray(i)&&e.length===i.length&&e.every((s,r)=>s===i[r])}setColormap(e){this._colormap=e,this.calMinMax(),this.onColormapChange&&this.onColormapChange(this)}setColormapLabel(e){this.colormapLabel=ce.makeLabelLut(e)}async setColormapLabelFromUrl(e){this.colormapLabel=await ce.makeLabelLutFromUrl(e)}get colormap(){return this._colormap}get colorMap(){return this._colormap}set colormap(e){this.setColormap(e)}set colorMap(e){this.setColormap(e)}get opacity(){return this._opacity}set opacity(e){this._opacity=e,this.onOpacityChange&&this.onOpacityChange(this)}calMinMax(e=Number.POSITIVE_INFINITY,i=!0){if(!this.hdr)throw new Error("hdr undefined");if(!this.img)throw new Error("img undefined");let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,n=0,a=0,o=this.hdr.dims[1]*this.hdr.dims[2]*this.hdr.dims[3];const l=Math.floor(this.img.length/o);e>=l&&(e=this.frame4D),e=Math.min(e,l-1);const c=e*o;let h=[];if(i){const E=[Math.floor(.25*this.hdr.dims[1]),Math.floor(.25*this.hdr.dims[2]),Math.floor(.25*this.hdr.dims[3])],B=[this.hdr.dims[1]-2*E[0],this.hdr.dims[2]-2*E[1],this.hdr.dims[3]-2*E[2]],P=[B[0]+E[0],B[1]+E[1],B[2]+E[2]];o=B[0]*B[1]*B[2],h=new this.img.constructor(o);let V=-1,R=0;for(let k=0;k<this.hdr.dims[3];k++)for(let z=0;z<this.hdr.dims[2];z++)for(let W=0;W<this.hdr.dims[1];W++)V++,!(W<E[0]||z<E[1]||k<E[2])&&(W>=P[0]||z>=P[1]||k>=P[2]||(h[R]=this.img[V+c],R++))}else{h=new this.img.constructor(o);for(let S=0;S<o;S++)h[S]=this.img[S+c]}const d=h.constructor!==Float64Array&&h.constructor!==Float32Array&&this.ignoreZeroVoxels;if(d)for(let S=0;S<o;S++)s=Math.min(h[S],s),r=Math.max(h[S],r),h[S]===0&&n++;else for(let S=0;S<o;S++){if(isNaN(h[S])){a++;continue}h[S]===0&&(n++,this.ignoreZeroVoxels)||(s=Math.min(h[S],s),r=Math.max(h[S],r))}this.ignoreZeroVoxels&&s===r&&n>0&&(s=0);const f=this.intensityRaw2Scaled(s),u=this.intensityRaw2Scaled(r),m=ce.colormapFromKey(this._colormap);let g=0,p=0;if(m.min!==void 0&&(g=m.min),m.max!==void 0&&(p=m.max),g===p&&this.trustCalMinMax&&isFinite(this.hdr.cal_min)&&isFinite(this.hdr.cal_max)&&this.hdr.cal_max>this.hdr.cal_min)return this.cal_min=this.hdr.cal_min,this.cal_max=this.hdr.cal_max,this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=f,this.global_max=u,[this.hdr.cal_min,this.hdr.cal_max,this.hdr.cal_min,this.hdr.cal_max];if(g!==p)return this.cal_min=g,this.cal_max=p,this.robust_min=this.cal_min,this.robust_max=this.cal_max,[g,p,g,p];const A=100*n/(o-0);let w=!1;A>60&&!this.ignoreZeroVoxels&&(U.warn(`${Math.round(A)}% of voxels are zero: ignoring zeros for cal_max`),w=!0,this.ignoreZeroVoxels=!0),this.ignoreZeroVoxels||(n=0),n+=a;const x=Math.round((o-0-n)*this.percentileFrac);if(x<1||s===r)return U.debug("no variability in image intensity?"),this.cal_min=f,this.cal_max=u,this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=f,this.global_max=u,[f,u,f,u];const y=1001,v=(y-1)/(r-s),D=new Array(y);for(let S=0;S<y;S++)D[S]=0;if(d)for(let S=0;S<o;S++)D[Math.round((h[S]-s)*v)]++;else if(this.ignoreZeroVoxels)for(let S=0;S<o;S++)h[S]!==0&&(isNaN(h[S])||D[Math.round((h[S]-s)*v)]++);else for(let S=0;S<o;S++)isNaN(h[S])||D[Math.round((h[S]-s)*v)]++;let b=0,C=0;for(;b<x;)b+=D[C],C++;C--,b=0;let I=y;for(;b<x;)I--,b+=D[I];if(C===I){let S=-1;for(;S!==0;)C>0&&(C--,D[C]>0&&(S=0)),S!==0&&I<y-1&&(I++,D[I]>0&&(S=0)),C===0&&I===y-1&&(S=0)}let M=this.intensityRaw2Scaled(C/v+s),T=this.intensityRaw2Scaled(I/v+s);return this.hdr.cal_min<this.hdr.cal_max&&this.hdr.cal_min>=f&&this.hdr.cal_max<=u&&(M=this.hdr.cal_min,T=this.hdr.cal_max),w&&(M=Math.min(M,0)),this.cal_min=M,this.cal_max=T,this.hdr.intent_code===1002&&(this.cal_min=f,this.cal_max=u),this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=f,this.global_max=u,[M,T,f,u]}intensityRaw2Scaled(e){if(!this.hdr)throw new Error("hdr undefined");return this.hdr.scl_slope===0&&(this.hdr.scl_slope=1),e*this.hdr.scl_slope+this.hdr.scl_inter}intensityScaled2Raw(e){if(!this.hdr)throw new Error("hdr undefined");return this.hdr.scl_slope===0&&(this.hdr.scl_slope=1),(e-this.hdr.scl_inter)/this.hdr.scl_slope}async saveToUint8Array(e,i=null){return al(this,e,i)}async saveToDisk(e="",i=null){return Dd(this,e,i)}static async fetchDicomData(e,i={}){if(e==="")throw Error("url must not be empty");let r=/^(?:[a-z+]+:)?\/\//i.test(e)?e:new URL(e,window.location.href);/(?:.([^.]+))?$/.exec(r.pathname)||(r=new URL("niivue-manifest.txt",e));let o=await fetch(r,{headers:i});if(!o.ok)throw Error(o.statusText);const c=(await o.text()).split(`
`),d=/(.*\/).*/.exec(r)[0],f=[];for(const u of c){const m=new URL(u,d);if(o=await fetch(m,{headers:i}),!o.ok)throw Error(o.statusText);const g=await o.arrayBuffer();f.push({name:u,data:g})}return f}static async readFirstDecompressedBytes(e,i){const s=e.getReader(),r=new _c,n=[];let a=0,o=!1,l,c;const h=new Promise((f,u)=>{l=f,c=u});function d(){const f=new Uint8Array(a);let u=0;for(const m of n)f.set(m,u),u+=m.length;l(f)}return r.ondata=f=>{n.push(f),a+=f.length,a>=i&&(o=!0,s.cancel().catch(()=>{}),d())},(async()=>{try{for(;!o;){const{done:f,value:u}=await s.read();if(f){o=!0,r.push(new Uint8Array,!0);return}r.push(u,!1)}}catch(f){c(f)}})().catch(()=>{}),h}static extractFilenameFromUrl(e){const s=new URL(e).searchParams.get("response-content-disposition");if(s){const r=s.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/);if(r)return decodeURIComponent(r[1])}return e.split("/").pop().split("?")[0]}static async loadInitialVolumesGz(e="",i={},s=NaN){if(isNaN(s))return null;const r=await fetch(e,{headers:i,cache:"force-cache"});let n=352,a=await this.readFirstDecompressedBytes(r.body,n);const o=new DataView(a.buffer,a.byteOffset,a.byteLength),l=o.getUint16(0,!0),c=l===348;if(!c&&!(l===23553)||(a.length>111&&(n=o.getFloat32(108,c)),n>a.length&&(a=await this.readFirstDecompressedBytes(r.body,n)),!(a[0]===92&&a[1]===1||a[1]===92&&a[0]===1)))return null;const f=await Ti(a.buffer);if(!f)throw new Error("Could not read NIfTI header");const u=f.numBitsPerVoxel/8,m=[1,2,3].reduce((y,v)=>y*(f.dims[v]>1?f.dims[v]:1),1),g=[4,5,6].reduce((y,v)=>y*(f.dims[v]>1?f.dims[v]:1),1),p=Math.max(Math.min(s,g),1),A=f.vox_offset+p*m*u;if(p===g)return null;const w=await fetch(e,{headers:i,cache:"force-cache"});return(await this.readFirstDecompressedBytes(w.body,A)).buffer.slice(0,A)}static async loadInitialVolumes(e="",i={},s=NaN){if(isNaN(s))return null;const n=(await fetch(e,{headers:i,cache:"force-cache"})).body.getReader(),{value:a,done:o}=await n.read();let l=a;if(o||!l||l.length<2)throw new Error("Not enough data to determine compression");const c=new DataView(l.buffer,l.byteOffset,l.byteLength),h=c.getUint16(0,!0);if(h===35615)return await n.cancel(),this.loadInitialVolumesGz(e,i,s);const f=h===348;if(!f&&!(h===23553))return await n.cancel(),null;let m=352;for(l.length>111&&(m=c.getFloat32(108,f));l.length<m;){let C=function(T,S){const E=new Uint8Array(T.length+S.length);return E.set(T,0),E.set(S,T.length),E};const{value:I,done:M}=await n.read();if(M||!I)break;l=C(l,I)}const g=await Ti(l.buffer);if(!g)throw new Error("Could not read NIfTI header");const p=g.numBitsPerVoxel/8,A=[1,2,3].reduce((C,I)=>C*(g.dims[I]>1?g.dims[I]:1),1),w=[4,5,6].reduce((C,I)=>C*(g.dims[I]>1?g.dims[I]:1),1),x=Math.max(Math.min(s,w),1),y=g.vox_offset+x*A*p,v=new Uint8Array(y),D=Math.min(l.length,y);v.set(l.subarray(0,D),0);let b=D;for(;b<y;){const{value:C,done:I}=await n.read();if(I||!C)return await n.cancel(),null;const M=Math.min(C.length,y-b);v.set(C.subarray(0,M),b),b+=M}return await n.cancel(),v.buffer}static async loadFromUrl({url:e="",urlImgData:i="",headers:s={},name:r="",colormap:n="",opacity:a=1,cal_min:o=NaN,cal_max:l=NaN,trustCalMinMax:c=!0,percentileFrac:h=.02,ignoreZeroVoxels:d=!1,useQFormNotSForm:f=!1,colormapNegative:u="",frame4D:m=0,isManifest:g=!1,limitFrames4D:p=NaN,imageType:A=$.UNKNOWN,colorbarVisible:w=!0,buffer:x=new ArrayBuffer(0)}={}){if(e==="")throw Error("url must not be empty");let y=null,v=null,D=null;if(e instanceof Uint8Array&&(e=e.slice().buffer),x.byteLength>0&&(e=x),e instanceof ArrayBuffer)if(v=e,r!=="")e=r;else{const T=new Uint8Array(v);e=T[0]===31&&T[1]===139?"array.nii.gz":"array.nii"}function b(T){const S=T.match(/\.([^.]+)(?:\.gz|\.bz2|\.xz)?$/);return S?S[1]:""}let C="";if(r===""?C=b(e):C=b(r),A===$.UNKNOWN&&(A=$.parse(C)),A===$.UNKNOWN&&typeof e=="string"){const T=await fetch(e,{});if(T.redirected){const S=this.extractFilenameFromUrl(T.url);S&&S.length>0&&r===""&&(r=S,C=b(r),A=$.parse(C))}}if(A===$.ZARR){const T=new URL(e).searchParams,S=T.get("z"),E=T.get("y"),B=T.get("x"),P=S?ki(parseInt(S),parseInt(S)+1):null,V=E?ki(parseInt(E),parseInt(E)+1):null,R=B?ki(parseInt(B),parseInt(B)+1):null,k=e.split("?")[0],z=new i0(k),W=Ih(z);let j;try{j=await kt(W.resolve(e),{kind:"array"})}catch{j=await kt(W,{kind:"array"})}let Q;if(j.shape.length===4){const at=j.shape[2],dt=j.shape[1],ke=j.shape[0];P&&P[0]>=at&&(P[0]=at-1),V&&V[0]>=dt&&(V[0]=dt-1),R&&R[0]>=ke&&(R[0]=ke-1),Q=await wa(j,[R,V,P,null])}else Q=await wa(j,[R,V,P]);v=Q.data;const[pe,Ce,Me,Qe]=Q.shape;D={data:v,width:Ce,height:pe,depth:Me,channels:Qe}}const I=A===$.DCM||$.NII;if(!v&&I&&(v=await this.loadInitialVolumes(e,s,p)),!v)if(g)v=await Fs.fetchDicomData(e,s),A=$.DCM_MANIFEST;else{const T=await fetch(e,{headers:s});if(!T.ok)throw Error(T.statusText);if(!T.body)throw new Error("No readable stream available");const S=await Er(T.body),E=[],B=S.getReader();for(;;){const{done:k,value:z}=await B.read();if(k)break;E.push(z)}const P=E.reduce((k,z)=>k+z.length,0);v=new ArrayBuffer(P);const V=new Uint8Array(v);let R=0;for(const k of E)V.set(k,R),R+=k.length}C.toUpperCase()==="HEAD"&&i===""&&(i=e.substring(0,e.lastIndexOf("HEAD"))+"BRIK");let M=null;if(i)try{let T=await fetch(i,{headers:s});if(T.status===404&&i.includes("BRIK")&&(T=await fetch(`${i}.gz`,{headers:s})),T.ok&&T.body){const S=await Er(T.body),E=[],B=S.getReader();for(;;){const{done:k,value:z}=await B.read();if(k)break;E.push(z)}const P=E.reduce((k,z)=>k+z.length,0);M=new ArrayBuffer(P);const V=new Uint8Array(M);let R=0;for(const k of E)V.set(k,R),R+=k.length}}catch(T){console.error("Error loading paired image data:",T)}if(!v)throw new Error("Unable to load buffer properly from volume");if(!r){let T;try{T=new URL(e).pathname.split("/")}catch{T=e.split("/")}r=T.slice(-1)[0],r.indexOf("?")>-1&&(r=r.slice(0,r.indexOf("?")))}return y=await this.new(v,r,n,a,M,o,l,c,h,d,f,u,m,A,NaN,NaN,!0,null,0,D),y.url=e,y.colorbarVisible=w,y}static async readFileAsync(e,i=NaN){let s=e.stream();if(!isNaN(i)){let d=0;const f=new TransformStream({transform(u,m){if(d>=i){m.terminate();return}const g=i-d;u.length>g?(m.enqueue(u.slice(0,g)),m.terminate()):m.enqueue(u),d+=u.length}});s=s.pipeThrough(f)}const r=await Er(s),n=[],a=r.getReader();for(;;){const{done:d,value:f}=await a.read();if(d)break;n.push(f)}const o=n.reduce((d,f)=>d+f.length,0),l=new ArrayBuffer(o),c=new Uint8Array(l);let h=0;for(const d of n)c.set(d,h),h+=d.length;return l}static async loadFromFile({file:e,name:i="",colormap:s="",opacity:r=1,urlImgData:n=null,cal_min:a=NaN,cal_max:o=NaN,trustCalMinMax:l=!0,percentileFrac:c=.02,ignoreZeroVoxels:h=!1,useQFormNotSForm:d=!1,colormapNegative:f="",frame4D:u=0,limitFrames4D:m=NaN,imageType:g=$.UNKNOWN}){let p=null,A=[];try{if(Array.isArray(e))A=await Promise.all(e.map(x=>this.readFileAsync(x)));else{if(isNaN(m))A=await this.readFileAsync(e);else{const x=await this.readFileAsync(e,512),y=new Uint8Array(x);if(!(y[0]===92&&y[1]===1||y[1]===92&&y[0]===1))A=await this.readFileAsync(e);else{const D=await Ti(x);if(!D)throw new Error("could not read nifti header");const b=D.numBitsPerVoxel/8,C=[1,2,3].reduce((S,E)=>S*(D.dims[E]>1?D.dims[E]:1),1),I=[4,5,6].reduce((S,E)=>S*(D.dims[E]>1?D.dims[E]:1),1),M=Math.max(Math.min(m,I),1),T=D.vox_offset+M*C*b;A=await this.readFileAsync(e,T)}}i=e.name}let w=null;n&&(w=await this.readFileAsync(n)),p=await this.new(A,i,s,r,w,a,o,l,c,h,d,f,u,g,NaN,NaN,!0,null,0,null),p.fileObject=e}catch(w){throw U.error(w),new Error("could not build NVImage")}if(p===null)throw new Error("could not build NVImage");return p}static createNiftiArray(e=[256,256,256],i=[1,1,1],s=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1],r=2,n=new Uint8Array){return Ed(e,i,s,r,n)}static createNiftiHeader(e=[256,256,256],i=[1,1,1],s=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1],r=2){return rl(e,i,s,r)}getVolumeData(e=[-1,0,0],i=[0,0,0],s="same"){return Md(this,e,i,s)}setVolumeData(e=[-1,0,0],i=[0,0,0],s=new Uint8Array){Id(this,e,i,s)}static async loadFromBase64({base64:e,name:i="",colormap:s="",opacity:r=1,cal_min:n=NaN,cal_max:a=NaN,trustCalMinMax:o=!0,percentileFrac:l=.02,ignoreZeroVoxels:c=!1,useQFormNotSForm:h=!1,colormapNegative:d="",frame4D:f=0,imageType:u=$.UNKNOWN,cal_minNeg:m=NaN,cal_maxNeg:g=NaN,colorbarVisible:p=!0,colormapLabel:A=null}){function w(y){const v=window.atob(y),D=v.length,b=new Uint8Array(D);for(let C=0;C<D;C++)b[C]=v.charCodeAt(C);return b.buffer}let x=null;try{const y=w(e);x=await this.new(y,i,s,r,null,n,a,o,l,c,h,d,f,u,m,g,p,A,0,null)}catch(y){U.debug(y)}if(x===null)throw new Error("could not load NVImage");return x}clone(){const e=new Fs;return e.id=zr(),e.hdr=Object.assign({},this.hdr),e.img=this.img.slice(),e.calculateRAS(),e.calMinMax(),e}zeroImage(){this.img.fill(0)}getImageMetadata(){if(!this.hdr)throw new Error("hdr undefined");const e=this.id,i=this.hdr.datatypeCode,s=this.hdr.dims,r=s[1],n=s[2],a=s[3],o=Math.max(1,s[4]),l=this.hdr.pixDims,c=l[1],h=l[2],d=l[3],f=l[4],u=Math.floor(this.hdr.numBitsPerVoxel/8);return{id:e,datatypeCode:i,nx:r,ny:n,nz:a,nt:o,dx:c,dy:h,dz:d,dt:f,bpv:u}}static zerosLike(e,i="same"){const s=e.clone();return s.zeroImage(),i==="uint8"&&(s.img=Uint8Array.from(s.img),s.hdr.datatypeCode=2,s.hdr.numBitsPerVoxel=8),i==="float32"&&(s.img=Float32Array.from(s.img),s.hdr.datatypeCode=16,s.hdr.numBitsPerVoxel=32),s}getValue(e,i,s,r=0,n=!1){return Td(this,e,i,s,r,n)}applyOptionsUpdate(e){this.hdr.cal_min=e.cal_min,this.hdr.cal_max=e.cal_max,Object.assign(this,e)}getImageOptions(){return Is("","",this.name,this._colormap,this.opacity,this.hdr.cal_min,this.hdr.cal_max,this.trustCalMinMax,this.percentileFrac,this.ignoreZeroVoxels,this.useQFormNotSForm,this.colormapNegative,this.frame4D,this.imageType,this.colormapType)}toUint8Array(e=null){return nl(this,e)}convertVox2Frac(e){return H((e[0]+.5)/this.dimsRAS[1],(e[1]+.5)/this.dimsRAS[2],(e[2]+.5)/this.dimsRAS[3])}convertFrac2Vox(e){return H(Math.round(e[0]*this.dims[1]-.5),Math.round(e[1]*this.dims[2]-.5),Math.round(e[2]*this.dims[3]-.5))}convertFrac2MM(e,i=!1){const s=ue(e[0],e[1],e[2],1);return i?Ve(s,s,this.frac2mm):Ve(s,s,this.frac2mmOrtho),s}convertMM2Frac(e,i=!1){const s=ue(e[0],e[1],e[2],1),r=this.dimsRAS,n=H(0,0,0);if(typeof r>"u")return n;if(!i){const o=be(this.frac2mmOrtho);return Je(o,o),Ve(s,s,o),n[0]=s[0],n[1]=s[1],n[2]=s[2],n}if(r[1]<1||r[2]<1||r[3]<1)return n;const a=be(this.matRAS);return Je(a,a),rt(a,a),Ve(s,s,a),n[0]=(s[0]+.5)/r[1],n[1]=(s[1]+.5)/r[2],n[2]=(s[2]+.5)/r[3],n}},hl=(t=>(t[t.none=0]="none",t[t.contrast=1]="contrast",t[t.measurement=2]="measurement",t[t.pan=3]="pan",t[t.slicer3D=4]="slicer3D",t[t.callbackOnly=5]="callbackOnly",t[t.roiSelection=6]="roiSelection",t))(hl||{}),yt={textHeight:.06,colorbarHeight:.05,colorbarWidth:-1,showColorbarBorder:!0,crosshairWidth:1,crosshairWidthUnit:"voxels",crosshairGap:0,rulerWidth:4,show3Dcrosshair:!1,backColor:[0,0,0,1],crosshairColor:[1,0,0,1],fontColor:[.5,.5,.5,1],selectionBoxColor:[1,1,1,.5],clipPlaneColor:[.7,0,.7,.5],clipThick:2,clipVolumeLow:[0,0,0],clipVolumeHigh:[1,1,1],rulerColor:[1,0,0,.8],colorbarMargin:.05,trustCalMinMax:!0,clipPlaneHotKey:"KeyC",viewModeHotKey:"KeyV",doubleTouchTimeout:500,longTouchTimeout:1e3,keyDebounceTime:50,isNearestInterpolation:!1,isResizeCanvas:!0,atlasOutline:0,isRuler:!1,isColorbar:!1,isOrientCube:!1,tileMargin:0,multiplanarPadPixels:0,multiplanarForceRender:!1,multiplanarEqualSize:!1,multiplanarShowRender:2,isRadiologicalConvention:!1,meshThicknessOn2D:1/0,dragMode:1,dragModePrimary:0,yoke3Dto2DZoom:!1,isDepthPickMesh:!1,isCornerOrientationText:!1,isOrientationTextVisible:!0,heroImageFraction:0,heroSliceType:4,sagittalNoseLeft:!1,isSliceMM:!1,isV1SliceShader:!1,forceDevicePixelRatio:0,logLevel:"info",loadingText:"loading ...",isForceMouseClickToVoxelCenters:!1,dragAndDropEnabled:!0,drawingEnabled:!1,penValue:1,floodFillNeighbors:6,isFilledPen:!1,thumbnail:"",maxDrawUndoBitmaps:8,sliceType:3,meshXRay:0,isAntiAlias:null,limitFrames4D:NaN,isAdditiveBlend:!1,showLegend:!0,legendBackgroundColor:[.3,.3,.3,.5],legendTextColor:[1,1,1,1],multiplanarLayout:0,renderOverlayBlend:1,sliceMosaicString:"",centerMosaic:!1,penSize:1,interactive:!0,clickToSegment:!1,clickToSegmentRadius:3,clickToSegmentBright:!0,clickToSegmentAutoIntensity:!1,clickToSegmentIntensityMax:NaN,clickToSegmentIntensityMin:NaN,clickToSegmentPercent:0,clickToSegmentMaxDistanceMM:Number.POSITIVE_INFINITY,clickToSegmentIs2D:!1,selectionBoxLineThickness:4,selectionBoxIsOutline:!1,scrollRequiresFocus:!1,showMeasureUnits:!0,measureTextJustify:"center",measureTextColor:[1,0,0,1],measureLineColor:[1,0,0,1],measureTextHeight:.03,isAlphaClipDark:!1,gradientOrder:1,gradientOpacity:0,renderSilhouette:0,gradientAmount:0,invertScrollDirection:!1,is2DSliceShader:!1},Fi={gamma:1,azimuth:110,elevation:10,crosshairPos:H(.5,.5,.5),clipPlane:[0,0,0,0],clipPlaneDepthAziElev:[2,0,0],volScaleMultiplier:1,pan2Dxyzmm:ue(0,0,0,1),clipThick:2,clipVolumeLow:[0,0,0],clipVolumeHigh:[1,1,1]};function Vd(t,e){const i={};for(const s in t){const r=t[s],n=e[s],a=Array.isArray(r)&&Array.isArray(n);(a&&r.some((o,l)=>o!==n[l])||!a&&r!==n)&&(i[s]=r)}return i}var Dr=class Vt{constructor(){F(this,"data",{title:"Untitled document",imageOptionsArray:[],meshOptionsArray:[],opts:{...yt},previewImageDataURL:"",labels:[],encodedImageBlobs:[],encodedDrawingBlob:""}),F(this,"scene"),F(this,"volumes",[]),F(this,"meshDataObjects"),F(this,"meshes",[]),F(this,"drawBitmap",null),F(this,"imageOptionsMap",new Map),F(this,"meshOptionsMap",new Map),this.scene={onAzimuthElevationChange:()=>{},onZoom3DChange:()=>{},sceneData:{...Fi,pan2Dxyzmm:ue(0,0,0,1),crosshairPos:H(.5,.5,.5)},get renderAzimuth(){return this.sceneData.azimuth},set renderAzimuth(e){this.sceneData.azimuth=e,this.onAzimuthElevationChange&&this.onAzimuthElevationChange(this.sceneData.azimuth,this.sceneData.elevation)},get renderElevation(){return this.sceneData.elevation},set renderElevation(e){this.sceneData.elevation=e,this.onAzimuthElevationChange&&this.onAzimuthElevationChange(this.sceneData.azimuth,this.sceneData.elevation)},get volScaleMultiplier(){return this.sceneData.volScaleMultiplier},set volScaleMultiplier(e){this.sceneData.volScaleMultiplier=e,this.onZoom3DChange(e)},get crosshairPos(){return this.sceneData.crosshairPos},set crosshairPos(e){this.sceneData.crosshairPos=e},get clipPlane(){return this.sceneData.clipPlane},set clipPlane(e){this.sceneData.clipPlane=e},get clipPlaneDepthAziElev(){return this.sceneData.clipPlaneDepthAziElev},set clipPlaneDepthAziElev(e){this.sceneData.clipPlaneDepthAziElev=e},get pan2Dxyzmm(){return this.sceneData.pan2Dxyzmm},set pan2Dxyzmm(e){this.sceneData.pan2Dxyzmm=e},get gamma(){return this.sceneData.gamma},set gamma(e){this.sceneData.gamma=e}}}get title(){return this.data.title}get previewImageDataURL(){return this.data.previewImageDataURL}set previewImageDataURL(e){this.data.previewImageDataURL=e}set title(e){this.data.title=e}get imageOptionsArray(){return this.data.imageOptionsArray}get encodedImageBlobs(){return this.data.encodedImageBlobs}get encodedDrawingBlob(){return this.data.encodedDrawingBlob}get opts(){return this.data.opts}set opts(e){this.data.opts={...e}}get labels(){return this.data.labels}set labels(e){this.data.labels=e}get customData(){return this.data.customData}set customData(e){this.data.customData=e}hasImage(e){return this.volumes.find(i=>i.id===e.id)!==void 0}hasImageFromUrl(e){return this.data.imageOptionsArray.find(i=>i.url===e)!==void 0}addImageOptions(e,i){if(!this.hasImage(e)&&!i.name)if(i.url){const r=/^(?:[a-z+]+:)?\/\//i.test(i.url)?new URL(i.url):new URL(i.url,window.location.href);i.name=r.pathname.split("/").pop(),i.name.toLowerCase().endsWith(".gz")&&(i.name=i.name.slice(0,-3)),i.name.toLowerCase().endsWith(".nii")||(i.name+=".nii")}else i.name="untitled.nii";i.imageType=$.NII,this.data.imageOptionsArray.push(i),this.imageOptionsMap.set(e.id,this.data.imageOptionsArray.length-1)}removeImage(e){if(this.imageOptionsMap.has(e.id)){const i=this.imageOptionsMap.get(e.id);this.data.imageOptionsArray.length>i&&this.data.imageOptionsArray.splice(i,1),this.imageOptionsMap.delete(e.id)}this.volumes=this.volumes.filter(i=>i.id!==e.id)}async fetchLinkedData(){var e;if(this.data.encodedImageBlobs=[],!!((e=this.imageOptionsArray)!=null&&e.length)){for(const i of this.imageOptionsArray)if(i.url)try{const s=await fetch(i.url);if(!s.ok){console.warn("Failed to fetch image:",i.url);continue}const r=await s.arrayBuffer(),n=new Uint8Array(r),a=Z.uint8tob64(n);this.data.encodedImageBlobs.push(a),console.info("fetch linked data fetched from ",i.url)}catch(s){console.warn(`Failed to fetch/encode image from ${i.url}:`,s)}}}getImageOptions(e){return this.imageOptionsMap.has(e.id)?this.data.imageOptionsArray[this.imageOptionsMap.get(e.id)]:null}json(e=!0){const i={encodedImageBlobs:[],previewImageDataURL:this.data.previewImageDataURL,imageOptionsMap:new Map},s=[];i.sceneData={...this.scene.sceneData},i.opts=Vd(this.opts,yt),this.opts.meshThicknessOn2D===1/0&&(i.opts.meshThicknessOn2D="infinity"),this.opts.meshThicknessOn2D===1/0&&(i.opts.meshThicknessOn2D="infinity"),i.labels=[...this.data.labels];for(const n of i.labels)delete n.onClick;if(i.customData=this.customData,this.volumes.length)for(let n=0;n<this.volumes.length;n++){const a=this.volumes[n];let o=this.getImageOptions(a);if(o===null?(U.warn("no options found for image, using default"),o={name:"",colormap:"gray",opacity:1,pairedImgData:null,cal_min:NaN,cal_max:NaN,trustCalMinMax:!0,percentileFrac:.02,ignoreZeroVoxels:!1,useQFormNotSForm:!1,colormapNegative:"",colormapLabel:null,imageType:$.NII,frame4D:0,limitFrames4D:NaN,url:"",urlImageData:"",alphaThreshold:!1,cal_minNeg:NaN,cal_maxNeg:NaN,colorbarVisible:!0}):"imageType"in o||(o.imageType=$.NII),o.colormap=a.colormap,o.colormapLabel=a.colormapLabel,o.opacity=a.opacity,o.cal_max=a.cal_max||NaN,o.cal_min=a.cal_min||NaN,s.push(o),e){const l=Z.uint8tob64(a.toUint8Array());i.encodedImageBlobs.push(l)}i.imageOptionsMap.set(a.id,n)}i.imageOptionsArray=[...s];const r=[];i.connectomes=[];for(const n of this.meshes){if(n.type==="connectome"){i.connectomes.push(JSON.stringify(n.json()));continue}const a={pts:n.pts,tris:n.tris,name:n.name,rgba255:Uint8Array.from(n.rgba255),opacity:n.opacity,connectome:n.connectome,dpg:n.dpg,dps:n.dps,dpv:n.dpv,meshShaderIndex:n.meshShaderIndex,layers:n.layers.map(o=>({values:o.values,nFrame4D:o.nFrame4D,frame4D:0,outlineBorder:o.outlineBorder,global_min:o.global_min,global_max:o.global_max,cal_min:o.cal_min,cal_max:o.cal_max,opacity:o.opacity,colormap:o.colormap,colormapNegative:o.colormapNegative,colormapLabel:o.colormapLabel,useNegativeCmap:o.useNegativeCmap})),hasConnectome:n.hasConnectome,edgeColormap:n.edgeColormap,edgeColormapNegative:n.edgeColormapNegative,edgeMax:n.edgeMax,edgeMin:n.edgeMin,edges:n.edges&&Array.isArray(n.edges)?[...n.edges]:[],extentsMax:n.extentsMax,extentsMin:n.extentsMin,furthestVertexFromOrigin:n.furthestVertexFromOrigin,nodeColormap:n.nodeColormap,nodeColormapNegative:n.nodeColormapNegative,nodeMaxColor:n.nodeMaxColor,nodeMinColor:n.nodeMinColor,nodeScale:n.nodeScale,legendLineThickness:n.legendLineThickness,offsetPt0:n.offsetPt0,nodes:n.nodes};n.offsetPt0&&n.offsetPt0.length>0&&(a.offsetPt0=n.offsetPt0,a.fiberGroupColormap=n.fiberGroupColormap,a.fiberColor=n.fiberColor,a.fiberDither=n.fiberDither,a.fiberRadius=n.fiberRadius,a.colormap=n.colormap),r.push(a)}return i.meshesString=JSON.stringify(Oc(r)),this.drawBitmap&&(i.encodedDrawingBlob=Z.uint8tob64(this.drawBitmap)),i}async download(e,i,s={embedImages:!0}){const r=this.json(s.embedImages),n=JSON.stringify(r),a=i?"application/gzip":"application/json",o=i?await Z.compressStringToArrayBuffer(n):n;Z.download(o,e,a)}static deserializeMeshDataObjects(e){if(!e.data.meshesString||e.data.meshesString==="[]"){e.meshDataObjects=[];return}if(e.data.meshesString){e.meshDataObjects=Rc(JSON.parse(e.data.meshesString));for(const i of e.meshDataObjects)for(const s of i.layers)"colorMap"in s&&(s.colormap=s.colorMap,delete s.colorMap),"colorMapNegative"in s&&(s.colormapNegative=s.colorMapNegative,delete s.colorMapNegative)}}static async loadFromUrl(e){const s=await(await fetch(e)).arrayBuffer();let r;if(Z.isArrayBufferCompressed(s)){const n=await Z.decompressArrayBuffer(s);r=JSON.parse(n)}else{const n=new TextDecoder;r=JSON.parse(n.decode(s))}return Vt.loadFromJSON(r)}static async loadFromFile(e){const i=await Z.readFileAsync(e);let s;const r=new Vt;return Z.isArrayBufferCompressed(i)?s=await Z.decompressArrayBuffer(i):s=new TextDecoder().decode(i),r.data=JSON.parse(s),r.data.opts.meshThicknessOn2D==="infinity"&&(r.data.opts.meshThicknessOn2D=1/0),r.scene.sceneData={...Fi,...r.data.sceneData},Vt.deserializeMeshDataObjects(r),r}static loadFromJSON(e){const i=new Vt;return Object.assign(i.data,{...e,imageOptionsArray:e.imageOptionsArray??[],encodedImageBlobs:e.encodedImageBlobs??[],labels:e.labels??[],meshOptionsArray:e.meshOptionsArray??[],connectomes:e.connectomes??[],encodedDrawingBlob:e.encodedDrawingBlob??"",previewImageDataURL:e.previewImageDataURL??"",customData:e.customData??"",title:e.title??"untitled"}),i.data.opts={...yt,...e.opts||{}},i.data.opts.meshThicknessOn2D==="infinity"&&(i.data.opts.meshThicknessOn2D=1/0),i.scene.sceneData={...Fi,...e.sceneData||{}},i.data.meshesString&&Vt.deserializeMeshDataObjects(i),i}static oldloadFromJSON(e){const i=new Vt;return i.data=e,i.data.opts.meshThicknessOn2D==="infinity"&&(i.data.opts.meshThicknessOn2D=1/0),i.scene.sceneData={...Fi,...e.sceneData},Vt.deserializeMeshDataObjects(i),i}},Rd={colormap:"gray",opacity:0,nFrame4D:0,frame4D:0,outlineBorder:0,cal_min:0,cal_max:0,cal_minNeg:0,cal_maxNeg:0,colormapType:0,values:new Array,useNegativeCmap:!1,showLegend:!0},li=class wt{constructor(e,i,s="",r=new Uint8Array([255,255,255,255]),n=1,a=!0,o,l=null,c=null,h=null,d=null,f=!0,u=""){F(this,"id"),F(this,"name"),F(this,"anatomicalStructurePrimary"),F(this,"colorbarVisible"),F(this,"furthestVertexFromOrigin"),F(this,"extentsMin"),F(this,"extentsMax"),F(this,"opacity"),F(this,"visible"),F(this,"meshShaderIndex",0),F(this,"offsetPt0",null),F(this,"colormapInvert",!1),F(this,"fiberGroupColormap",null),F(this,"indexBuffer"),F(this,"vertexBuffer"),F(this,"vao"),F(this,"vaoFiber"),F(this,"pts"),F(this,"tris"),F(this,"layers"),F(this,"type","mesh"),F(this,"data_type"),F(this,"rgba255"),F(this,"fiberLength"),F(this,"fiberLengths"),F(this,"fiberDensity"),F(this,"fiberDither",.1),F(this,"fiberColor","Global"),F(this,"fiberDecimationStride",1),F(this,"fiberSides",5),F(this,"fiberRadius",0),F(this,"fiberOcclusion",0),F(this,"f32PerVertex",5),F(this,"fiberMask"),F(this,"colormap"),F(this,"dpg"),F(this,"dps"),F(this,"dpv"),F(this,"hasConnectome",!1),F(this,"connectome"),F(this,"indexCount"),F(this,"vertexCount",1),F(this,"nodeScale",4),F(this,"edgeScale",1),F(this,"legendLineThickness",0),F(this,"showLegend",!0),F(this,"nodeColormap","warm"),F(this,"edgeColormap","warm"),F(this,"nodeColormapNegative"),F(this,"edgeColormapNegative"),F(this,"nodeMinColor"),F(this,"nodeMaxColor"),F(this,"edgeMin"),F(this,"edgeMax"),F(this,"nodes"),F(this,"edges"),F(this,"points"),this.anatomicalStructurePrimary=u,this.name=s,this.colorbarVisible=f,this.id=zr();const m=bt.getExtents(e);if(this.furthestVertexFromOrigin=m.mxDx,this.extentsMin=m.extentsMin,this.extentsMax=m.extentsMax,this.opacity=n>1?1:n,this.visible=a,this.meshShaderIndex=0,this.indexBuffer=o.createBuffer(),this.vertexBuffer=o.createBuffer(),this.vao=o.createVertexArray(),o.bindVertexArray(this.vao),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,this.indexBuffer),o.bindBuffer(o.ARRAY_BUFFER,this.vertexBuffer),o.enableVertexAttribArray(0),o.enableVertexAttribArray(1),this.f32PerVertex!==7?(o.vertexAttribPointer(0,3,o.FLOAT,!1,20,0),o.vertexAttribPointer(1,4,o.BYTE,!0,20,12),o.enableVertexAttribArray(2),o.vertexAttribPointer(2,4,o.UNSIGNED_BYTE,!0,20,16)):(o.vertexAttribPointer(0,3,o.FLOAT,!1,28,0),o.vertexAttribPointer(1,3,o.FLOAT,!1,28,12),o.enableVertexAttribArray(2),o.vertexAttribPointer(2,4,o.UNSIGNED_BYTE,!0,28,24)),o.bindVertexArray(null),this.vaoFiber=o.createVertexArray(),this.offsetPt0=null,this.hasConnectome=!1,this.colormapInvert=!1,this.fiberGroupColormap=null,this.pts=e,this.layers=[],this.type="mesh",this.tris=i,r[3]<1){this.rgba255=r,this.fiberLength=2,this.fiberDither=.1,this.fiberColor="Global",this.fiberDecimationStride=1,this.fiberMask=[],this.colormap=l,this.dpg=c,this.dps=h,this.dpv=d,c&&this.initValuesArray(c),h&&this.initValuesArray(h),d&&this.initValuesArray(d),this.offsetPt0=new Uint32Array(i),this.tris=new Uint32Array(0),this.updateFibers(o),o.bindVertexArray(this.vaoFiber),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,this.indexBuffer),o.bindBuffer(o.ARRAY_BUFFER,this.vertexBuffer),o.enableVertexAttribArray(0),o.vertexAttribPointer(0,3,o.FLOAT,!1,16,0),o.enableVertexAttribArray(1),o.vertexAttribPointer(1,4,o.UNSIGNED_BYTE,!0,16,12),o.bindVertexArray(null);return}if(l){this.connectome=l,this.hasConnectome=!0;const p=Object.keys(l);for(let A=0,w=p.length;A<w;A++)this[p[A]]=l[p[A]]}this.rgba255=r,this.updateMesh(o)}initValuesArray(e){for(let i=0;i<e.length;i++){const s=e[i].vals.reduce((n,a)=>Math.min(n,a)),r=e[i].vals.reduce((n,a)=>Math.max(n,a));e[i].global_min=s,e[i].global_max=r,e[i].cal_min=s,e[i].cal_max=r}return e}linesToCylinders(e,i,s){function r(I){return H(I[0],I[1],I[2])}const n=Math.pow(2,32)-1,a=s.length;let o=0,l=0;for(let I=0;I<a;I++){if(s[I]===n){l++;continue}o++}const c=this.fiberSides,h=c*o,d=this.f32PerVertex;if(d!==5)throw Error("fiberSides > 1 requires f32PerVertex == 5");const f=new Float32Array(h*d),u=new Uint8Array(f.buffer);let m=0,g=Ct(),p=Ct(),A=Ct();const w=fe();let x=fe(),y=0;const v=this.fiberRadius;for(let I=0;I<a;I++){const M=s[I]===n;if(M&&y<1)continue;let T=s[I]*4;if(y++,y<=1){g=ue(i[T+0],i[T+1],i[T+2],i[T+3]),p=Tt(g),I+1<a&&s[I+1]!==n&&(T=s[I+1]*4,A=ue(i[T+0],i[T+1],i[T+2],i[T+3]),de(w,r(g),r(A)),ft(w,w),x=Zt.getFirstPerpVector(w));continue}M?A=Tt(p):A=ue(i[T+0],i[T+1],i[T+2],i[T+3]),de(w,r(g),r(A)),ft(w,w);const S=fe();bs(S,x,w);const E=fe();bs(E,w,S),x=Vi(x);const B=fe();bs(B,w,E),ft(B,B);const P=fe();for(let V=0;V<c;V++){const R=Math.cos(V/c*2*Math.PI),k=Math.sin(V/c*2*Math.PI);P[0]=v*(R*E[0]+k*B[0]),P[1]=v*(R*E[1]+k*B[1]),P[2]=v*(R*E[2]+k*B[2]),Ht(P,r(p),P);const z=m*d;f[z+0]=P[0],f[z+1]=P[1],f[z+2]=P[2];const W=fe();de(W,P,r(p)),ft(W,W);const j=(z+3)*4;u[j+0]=W[0]*127,u[j+1]=W[1]*127,u[j+2]=W[2]*127,f[z+4]=p[3],m++}g=Tt(p),p=Tt(A),M&&(y=0)}const D=(o-l)*c*2*3,b=new Uint32Array(D);let C=0;m=0;for(let I=1;I<a;I++){if(s[I]===n){m+=c;continue}if(s[I-1]===n)continue;let M=m,T=m+c;const S=T,E=T+c;for(let B=0;B<c;B++)b[C++]=M,b[C++]=T++,T===E&&(T=E-c),b[C++]=T,b[C++]=M++,M===S&&(M=S-c),b[C++]=T,b[C++]=M;m+=c}e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,Uint32Array.from(b),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,u,e.STATIC_DRAW),this.indexCount=D}createFiberDensityMap(){if(this.fiberDensity)return;const e=this.pts,i=e.length/3;let s=0;for(let w=0;w<3;w++){const x=this.extentsMax[w]-this.extentsMin[w];s=Math.max(s,x)}if(this.fiberDensity=new Float32Array(i),s===0)return;const r=64,a=s/(r-1)/2,o=(r-1)/s;let l=new Float32Array(r*r*r);const c=[this.extentsMin[0]-a,this.extentsMin[1]-a,this.extentsMin[2]-a],h=[0,0,0],d=-1,f=r*r;let u=0;for(let w=0;w<i;w++){h[0]=Math.round((e[u++]-c[0])*o),h[1]=Math.round((e[u++]-c[1])*o),h[2]=Math.round((e[u++]-c[2])*o);const x=h[0]+h[1]*r+h[2]*f;x!==d&&l[x]++}function m(w,x){let y=w.slice(),v=-1;const D=x-1;for(let C=0;C<x;C++)for(let I=0;I<x;I++)for(let M=0;M<x;M++)v++,!(M<1||M>=D)&&(w[v]=y[v-1]+y[v]+y[v]+y[v+1]);v=-1,y=w.slice();for(let C=0;C<x;C++)for(let I=0;I<x;I++)for(let M=0;M<x;M++)v++,!(I<1||I>=D)&&(w[v]=y[v-x]+y[v]+y[v]+y[v+x]);const b=x*x;v=-1,y=w.slice();for(let C=0;C<x;C++)for(let I=0;I<x;I++)for(let M=0;M<x;M++)v++,!(C<1||C>=D)&&(w[v]=y[v-b]+y[v]+y[v]+y[b]);return w}l=m(l,r),l=m(l,r);let g=0,p=1/0;const A=r*r*r;for(let w=0;w<A;w++)l[w]<=0||(g=Math.max(g,l[w]),p=Math.min(p,l[w]));if(!(g<=1||g<=p)){u=0;for(let w=0;w<A;w++)l[w]=Math.max(0,l[w]-p);g-=p;for(let w=0;w<i;w++){h[0]=Math.round((e[u++]-c[0])*o),h[1]=Math.round((e[u++]-c[1])*o),h[2]=Math.round((e[u++]-c[2])*o);const x=h[0]+h[1]*r+h[2]*f;this.fiberDensity[w]=l[x]/g}}}updateFibers(e){if(!this.offsetPt0||!this.fiberLength)return;const i=this.pts,s=this.offsetPt0,r=s.length-1,n=i.length/3;if(!this.fiberLengths){this.fiberLengths=new Uint32Array(r);for(let D=0;D<r;D++){const b=s[D]*3,C=(s[D+1]-1)*3;let I=0;for(let M=b;M<C;M+=3){const T=H(i[M+0]-i[M+3],i[M+1]-i[M+4],i[M+2]-i[M+5]);I+=Li(T)}this.fiberLengths[D]=I}}const a=new Float32Array(n*4),o=new Uint32Array(a.buffer);let l=0,c=0;for(let D=0;D<n;D++)a[c+0]=i[l+0],a[c+1]=i[l+1],a[c+2]=i[l+2],l+=3,c+=4;const h=this.fiberDither,d=h*.5;function f(D,b,C){const M=255*(h*Math.random()-d);return D=Math.max(Math.min(D+M,255),0),b=Math.max(Math.min(b+M,255),0),C=Math.max(Math.min(C+M,255),0),D+(b<<8)+(C<<16)}function u(D,b,C,I,M,T,S){const E=H(Math.abs(D-I),Math.abs(b-M),Math.abs(C-T));ft(E,E);const B=S-d;for(let P=0;P<3;P++)E[P]=255*Math.max(Math.min(Math.abs(E[P])+B,1),0);return E[0]+(E[1]<<8)+(E[2]<<16)}const m=this.fiberColor.toLowerCase();let g=null,p=null;if(m.startsWith("dps")&&this.dps&&this.dps.length>0){const D=parseInt(m.substring(3));D<this.dps.length&&this.dps[D].vals.length===r&&(g=this.dps[D].vals)}if(m.startsWith("dpv")&&this.dpv&&this.dpv.length>0){const D=parseInt(m.substring(3));D<this.dpv.length&&this.dpv[D].vals.length===n&&(p=this.dpv[D])}const A=new Int16Array(r);if(this.dpg&&this.fiberGroupColormap!==null){const D=new Uint8ClampedArray(this.dpg.length*4),b=new Array(this.dpg.length).fill(!1),C=this.fiberGroupColormap;C.A===void 0&&(C.A=Array.from(new Uint8ClampedArray(C.I.length).fill(255)));for(let I=0;I<C.I.length;I++){let M=C.I[I];M<0||M>=this.dpg.length||C.A[I]<1||(b[M]=!0,M*=4,D[M]=C.R[I],D[M+1]=C.G[I],D[M+2]=C.B[I],D[M+3]=255)}A.fill(-1);for(let I=0;I<this.dpg.length;I++)if(b[I])for(let M=0;M<this.dpg[I].vals.length;M++)A[this.dpg[I].vals[M]]=I;for(let I=0;I<r;I++){if(A[I]<0)continue;const M=A[I]%256*4,T=f(D[M],D[M+1],D[M+2]),S=s[I],E=s[I+1]-1,B=S*4+3,P=E*4+3;for(let V=B;V<=P;V+=4)o[V]=T}}else if(p){const D=ce.colormap(this.colormap,this.colormapInvert),b=p.cal_min,C=p.cal_max;let I=3;for(let M=0;M<n;M++){let T=Math.min(Math.max((p.vals[M]-b)/(C-b),0),1);T=Math.round(Math.max(Math.min(255,T*255)))*4;const S=D[T]+(D[T+1]<<8)+(D[T+2]<<16);o[I]=S,I+=4}}else if(g){const D=ce.colormap(this.colormap,this.colormapInvert);let b=g[0],C=g[0];for(let I=0;I<r;I++)b=Math.min(b,g[I]),C=Math.max(C,g[I]);C===b&&(b-=1);for(let I=0;I<r;I++){let M=(g[I]-b)/(C-b);M=Math.round(Math.max(Math.min(255,M*255)))*4;const T=D[M]+(D[M+1]<<8)+(D[M+2]<<16),S=s[I],E=s[I+1]-1,B=S*4+3,P=E*4+3;for(let V=B;V<=P;V+=4)o[V]=T}}else if(m.includes("fixed"))if(h===0){const D=this.rgba255[0]+(this.rgba255[1]<<8)+(this.rgba255[2]<<16);let b=3;for(let C=0;C<n;C++)o[b]=D,b+=4}else for(let D=0;D<r;D++){const b=f(this.rgba255[0],this.rgba255[1],this.rgba255[2]),C=s[D],I=s[D+1]-1,M=C*4+3,T=I*4+3;for(let S=M;S<=T;S+=4)o[S]=b}else if(m.includes("local"))for(let D=0;D<r;D++){const b=s[D],C=s[D+1]-1;let I=b*3;const M=C*3,T=h*Math.random();let S=u(i[I],i[I+1],i[I+2],i[I+4],i[I+5],i[I+6],T),E=b*4+3;for(;I<M;)o[E]=S,E+=4,I+=3,S=u(i[I-3],i[I-2],i[I-1],i[I+3],i[I+4],i[I+5],T);o[E]=o[E-4]}else for(let D=0;D<r;D++){const b=s[D],C=s[D+1]-1,I=b*3,M=C*3,T=u(i[I],i[I+1],i[I+2],i[M],i[M+1],i[M+2],h*Math.random()),S=b*4+3,E=C*4+3;for(let B=S;B<=E;B+=4)o[B]=T}if(this.fiberOcclusion>0){let D=function(b,C){const I=C*(b&255),M=C*(b>>8&255),T=C*(b>>16&255);return I+(M<<8)+(T<<16)};this.createFiberDensityMap();for(let b=0;b<r;b++){const C=s[b],I=s[b+1]-1,M=C*4+3,T=I*4+3;let S=C;const E=Math.min(this.fiberOcclusion,.99);for(let B=M;B<=T;B+=4){let P=this.fiberDensity[S++];if(P<=0)continue;P=P/((1/E-2)*(1-P)+1);const V=1-Math.min(P,.9);let R=o[B];R=D(R,V),o[B]=R}}}const w=this.fiberLength,x=Math.pow(2,32)-1,y=[];let v=-1;for(let D=0;D<r;D++)if(!(A[D]<0)&&!(this.fiberLengths[D]<w)&&(v++,v%this.fiberDecimationStride===0)){for(let b=s[D];b<s[D+1];b++)y.push(b);y.push(x)}this.fiberSides>2&&this.fiberRadius>0?this.linesToCylinders(e,a,y):(this.indexCount=y.length,e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,Uint32Array.from(o),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,Uint32Array.from(y),e.STATIC_DRAW))}indexNearestXYZmm(e,i,s){const r=this.pts,n=this.pts.length/3;let a=0,o=1/0,l=0;for(let c=0;c<n;c++){const h=Math.pow(r[a]-e,2)+Math.pow(r[a+1]-i,2)+Math.pow(r[a+2]-s,2);h<o&&(o=h,l=c),a+=3}return o=Math.sqrt(o),[l,o]}unloadMesh(e){if(e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.bindVertexArray(null),e.deleteBuffer(this.vertexBuffer),e.deleteBuffer(this.indexBuffer),e.deleteVertexArray(this.vao),e.deleteVertexArray(this.vaoFiber),this.offsetPt0=null,this.tris=null,this.pts=null,this.layers&&this.layers.length>0)for(let i=0;i<this.layers.length;i++)this.layers[i].values=null;if(this.dpg&&this.dpg.length>0)for(let i=0;i<this.dpg.length;i++)this.dpg[i].vals=null;if(this.dps&&this.dps.length>0)for(let i=0;i<this.dps.length;i++)this.dps[i].vals=null}scalars2RGBA(e,i,s,r=!1){const n=s.length;if(4*n<e.length)return U.error(`colormap2RGBA incorrectly specified ${n}*4 != ${e.length}`),e;const a=Math.round(i.opacity*255);let o=i.cal_min,l=i.cal_max,c=ce.colormap(i.colormap,this.colormapInvert),h=1;if(r){if(!i.useNegativeCmap)return e;h=-1,c=ce.colormap(i.colormapNegative,i.colormapInvert),o=i.cal_min,l=i.cal_max,isFinite(i.cal_minNeg)&&isFinite(i.cal_minNeg)&&(o=-i.cal_minNeg,l=-i.cal_maxNeg)}let d=o;i.isTransparentBelowCalMin||(d=Number.NEGATIVE_INFINITY);const f=i.colormapType===2;i.colormapType!==0&&(o=Math.min(o,0));const u=255/(l-o);for(let m=0;m<n;m++){let g=s[m]*h;if(isNaN(g))continue;let p=a;if(g<d)if(g>0&&f)p=Math.round(i.opacity*255*Math.pow(g/d,2));else continue;if(g=(g-o)*u,g<0&&i.isTransparentBelowCalMin)continue;g=Math.min(255,Math.max(0,Math.round(g)))*4;const A=m*4;e[A+0]=c[g+0],e[A+1]=c[g+1],e[A+2]=c[g+2],e[A+3]=p}return e}blendColormap(e,i,s,r,n,a,o=!1){const l=this.pts.length/3,c=Math.min(s.opacity,1);function h(x,y,v){return x*(1-v)+y*v}function d(x,y){return Math.min(x+y,255)}const f=o?-1:1,u=Math.min(Math.max(s.frame4D,0),s.nFrame4D-1),m=l*u;let g=r;s.isTransparentBelowCalMin||(g=Number.NEGATIVE_INFINITY),s.colormapType!==0&&(r=Math.min(r,0));const p=255/(n-r);let A=new Array(l).fill(!1);if(s.outlineBorder!==0){const x=new Uint8Array(l).fill(0);for(let y=0;y<l;y++)f*s.values[y+m]>=g&&(x[y]=1);A=bt.getClusterBoundaryU8(x,this.tris);for(let y=0;y<l;y++)f*s.values[y+m]<g&&(A[y]=!1)}const w=new Float32Array(256).fill(c);if(g>r&&s.colormapType===2){let x=Math.round((g-r)*p);x=Math.max(x,1);for(let y=1;y<x;y++)w[y]=c*Math.pow(y/x,2);w[0]=0,g=r+Number.EPSILON}for(let x=0;x<l;x++){const y=f*s.values[x+m];if(y<g)continue;let v=Math.round((y-r)*p);if(v<0&&s.isTransparentBelowCalMin)continue;v=Math.max(0,v),v=Math.min(255,v);let D=w[v];v*=4;let b=x*28+24;if(this.f32PerVertex!==7&&(b=x*20+16),s.isAdditiveBlend){const C=x*4;i[C+0]=d(i[C+0],a[v+0]),i[C+1]=d(i[C+1],a[v+1]),i[C+2]=d(i[C+2],a[v+2]),i[C+3]=d(i[C+3],255)}else{if(A[x]&&(D=s.outlineBorder,s.outlineBorder<0)){e[b+0]=0,e[b+1]=0,e[b+2]=0;continue}e[b+0]=h(e[b+0],a[v+0],D),e[b+1]=h(e[b+1],a[v+1],D),e[b+2]=h(e[b+2],a[v+2],D)}}}updateMesh(e){if(this.offsetPt0){this.updateFibers(e);return}if(this.hasConnectome)return;if(!this.pts||!this.tris||!this.rgba255){U.warn("underspecified mesh");return}function i(c,h,d){return c*(1-d)+h*d}const s=this.generatePosNormClr(this.pts,this.tris,this.rgba255),r=this.pts.length/3,n=new Uint8Array(s.buffer);let a=0;const o=new Uint8Array(r*4);let l=this.tris;if(this.layers&&this.layers.length>0)for(let c=0;c<this.layers.length;c++){const h=this.layers[c],d=h.opacity;if(d<=0||h.cal_min>h.cal_max)continue;if(h.outlineBorder===void 0&&(h.outlineBorder=0),h.isAdditiveBlend===void 0&&(h.isAdditiveBlend=!1),h.colormapLabel&&h.colormapLabel.R&&!h.colormapLabel.lut&&(h.colormapLabel=ce.makeLabelLut(h.colormapLabel)),h.colormapLabel&&h.colormapLabel.lut){const u=h.colormapLabel;let m=0;h.colormapLabel.min&&(m=h.colormapLabel.min);let g=u.lut;const p=Math.round(h.opacity*255);g[3]>0&&(g[3]=p);for(let b=7;b<g.length;b+=4)g[b]=p;const A=Math.floor(g.length/4);if(h.atlasValues&&A>0&&A===h.atlasValues.length&&h.colormap){const b=h.atlasValues;let C=!1,I=!0;for(let M=0;M<A;M++)isNaN(b[M])?C=!0:I=!1;if(I){U.debug("invisible mesh: all atlasValues are NaN.");return}if(C){U.debug("some vertices have NaN atlasValues (mesh will be decimated).");const M=new Array(r).fill(!1);for(let P=0;P<r;P++){const V=Math.round(h.values[P])-m;isNaN(b[V])&&(M[P]=!0)}const T=new Array(l.length).fill(!1);for(let P=0;P<l.length;P++)M[l[P]]&&(T[P]=!0);const S=this.tris;let E=0;for(let P=0;P<S.length;P+=3)!T[P]&&!T[P+1]&&!T[P+2]&&E++;E===0&&U.debug("invisible mesh: all triangles of a vertex with a NaN atlasValue."),l=new Uint32Array(E*3);let B=0;for(let P=0;P<S.length;P+=3)!T[P]&&!T[P+1]&&!T[P+2]&&(l[B++]=S[P],l[B++]=S[P+1],l[B++]=S[P+2])}g.fill(0),g=this.scalars2RGBA(g,h,b),h.useNegativeCmap&&(g=this.scalars2RGBA(g,h,b,!0))}else h.atlasValues&&U.warn(`Expected ${A} atlasValues but got ${h.atlasValues.length} for mesh layer`);if(h.showLegend&&A===h.colormapLabel.labels.length){h.labels=[];for(let b=0;b<A;b++){const C=Array.from(g.slice(b*4,b*4+4)).map(T=>T/255),I=h.colormapLabel.labels[b];if(C[3]===0||!I||I.startsWith("_"))continue;C[3]=1;const M=new Bn(I,{textColor:C,bulletScale:1,bulletColor:C,lineWidth:0,lineColor:C,textScale:1,textAlignment:"left",lineTerminator:"none"});h.labels.push(M),U.debug("label for mesh layer:",M)}}else delete h.labels;const w=Math.min(Math.max(h.frame4D,0),h.nFrame4D-1),x=r*w,y=new Uint8Array(r*4);let v=0;for(let b=0;b<r;b++){const C=h.values[b+x]-m,I=4*Math.min(Math.max(C,0),A-1);y[v+0]=g[I+0],y[v+1]=g[I+1],y[v+2]=g[I+2],y[v+3]=g[I+3],v+=4}let D=new Array(r).fill(!1);h.outlineBorder!==0&&(D=bt.getClusterBoundary(y,this.tris)),v=0;for(let b=0;b<r;b++){let C=b*28+24;this.f32PerVertex!==7&&(C=b*20+16);let I=y[v+3]/255;if(D[b]&&(I=h.outlineBorder,h.outlineBorder<0)){n[C+0]=0,n[C+1]=0,n[C+2]=0,v+=4;continue}n[C+0]=i(n[C+0],y[v+0],I),n[C+1]=i(n[C+1],y[v+1],I),n[C+2]=i(n[C+2],y[v+2],I),v+=4}continue}if(h.values instanceof Uint8Array){const u=new Uint8Array(h.values.buffer);let m=new Array(r).fill(!0);h.outlineBorder!==0&&(m=bt.getClusterBoundary(u,this.tris));let g=0;for(let p=0;p<h.values.length;p++){let A=p*28+24;this.f32PerVertex!==7&&(A=p*20+16);let w=d;if(m[p]&&(w=h.outlineBorder,h.outlineBorder<0)){n[A+0]=0,n[A+1]=0,n[A+2]=0,g+=4;continue}n[A+0]=i(n[A+0],u[g+0],w),n[A+1]=i(n[A+1],u[g+1],w),n[A+2]=i(n[A+2],u[g+2],w),g+=4}continue}h.useNegativeCmap&&(h.cal_min=Math.max(Number.EPSILON,h.cal_min),h.cal_max=Math.max(h.cal_min+1e-6,h.cal_max)),h.isTransparentBelowCalMin===void 0&&(h.isTransparentBelowCalMin=!0);const f=ce.colormap(h.colormap,h.colormapInvert);if(h.isAdditiveBlend&&a++,this.blendColormap(n,o,h,h.cal_min,h.cal_max,f),h.useNegativeCmap){const u=ce.colormap(h.colormapNegative,h.colormapInvert);let m=h.cal_min,g=h.cal_max;isFinite(h.cal_minNeg)&&isFinite(h.cal_minNeg)&&(m=-h.cal_minNeg,g=-h.cal_maxNeg),this.blendColormap(n,o,h,m,g,u,!0)}}if(a>0)for(let c=0;c<r;c++){let h=function(m,g){return Math.min(m*g*.00392156862745098,255)},d=c*28+24;this.f32PerVertex!==7&&(d=c*20+16);const f=c*4,u=Math.min(a,o[f+3]/255);u<=0||(n[d+0]=h(n[d+0],o[f+0]),n[d+1]=h(n[d+1],o[f+1]),n[d+2]=h(n[d+2],o[f+2]),n[d+0]=i(n[d+0],o[f+0],u),n[d+1]=i(n[d+1],o[f+1],u),n[d+2]=i(n[d+2],o[f+2],u))}e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,Uint32Array.from(l),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),this.indexCount=l.length,this.vertexCount=this.pts.length}reverseFaces(e){if(this.offsetPt0||this.hasConnectome)return;const i=this.tris||[];for(let s=0;s<i.length;s+=3){const r=i[s];i[s]=i[s+1],i[s+1]=r}this.updateMesh(e)}hierarchicalOrder(){const s=this.tris.length/3,r=Math.log(s/20)/Math.log(4);if(s!==Math.pow(4,r)*20)return NaN;if(this.pts.length/3!==Math.pow(4,r)*10+2)return NaN;for(let a=0;a<15;a+=3)if(this.tris[a]!==0)return NaN;for(let a=15;a<24;a+=3)if(this.tris[a]!==3)return NaN;for(let a=24;a<30;a+=3)if(this.tris[a]!==4)return NaN;return r}decimateFaces(e,i){let s=this.tris;const r=12,n=20;for(let a=e-1;a>=i;a--){const o=Math.pow(4,a+1)*(r-2)+2,l=Math.pow(4,a)*(r-2)+2,c=s.length/3,h=Math.pow(4,a)*n;console.log(`order ${a+1} -> ${a} vertices ${o} -> ${l} faces ${c} -> ${h}`);const d=Array.from({length:o},(u,m)=>m+1);for(let u=0;u<c;u++){const m=s[3*u],g=s[3*u+1],p=s[3*u+2];d[m-1]=Math.min(d[m-1],g,p)}const f=new Uint32Array(h*3);for(let u=0;u<h;u++)f[3*u]=d[s[3*u]-1],f[3*u+1]=d[s[3*u+1]-1],f[3*u+2]=d[s[3*u+2]-1];s=f}this.tris=new Uint32Array(s)}decimateHierarchicalMesh(e,i=4){const s=this.hierarchicalOrder();if(isNaN(s))return U.warn("Unable to decimate mesh: it does not have a hierarchical structure"),!1;if(i>=s)return U.warn(`Unable to decimate mesh: input order (${s}) must be larger than downsampled order (${i})`),!1;const r=this.pts.length/3,a=Math.pow(4,i)*(12-2)+2;if(this.pts=new Float32Array(this.pts.slice(0,a*3)),this.decimateFaces(s,i),this.layers&&this.layers.length>0)for(let o=0;o<this.layers.length;o++){const l=this.layers[o];l.values instanceof Float32Array||l.values.length!==r?l.values=new Float32Array(l.values.slice(0,a)):U.warn("decimation logic needs to be updated")}return this.updateMesh(e),!0}async setLayerProperty(e,i,s,r){const n=this.layers[e];if(!n||!(i in n)){U.warn("mesh does not have property ",i," for layer ",n);return}if(i==="colormapLabel")if(typeof s=="object")n[i]=ce.makeLabelLut(s);else if(typeof s=="string"){const a=await ce.makeLabelLutFromUrl(s);n[i]=a,this.updateMesh(r);return}else U.error("colormapLabel requires a string or object");else n[i]=s;this.updateMesh(r)}setProperty(e,i,s){if(!(e in this)){console.warn("Mesh does not have property:",e,this);return}this[e]=i,this.updateMesh(s)}generatePosNormClr(e,i,s){(e.length<3||s.length<4)&&(U.error("Catastrophic failure generatePosNormClr()"),U.debug("this",this),U.debug("pts",e),U.debug("rgba",s));const r=bt.generateNormals(e,i),n=e.length/3,a=n===s.length/4,o=this.f32PerVertex,l=new Float32Array(n*o),c=new Uint8Array(l.buffer);let h=0,d=0,f=0,u=(o-1)*4;for(let m=0;m<n;m++)l[f+0]=e[h+0],l[f+1]=e[h+1],l[f+2]=e[h+2],o!==7?(c[u-4]=r[h+0]*127,c[u-3]=r[h+1]*127,c[u-2]=r[h+2]*127):(l[f+3]=r[h+0],l[f+4]=r[h+1],l[f+5]=r[h+2]),c[u]=s[d+0],c[u+1]=s[d+1],c[u+2]=s[d+2],c[u+3]=s[d+3],a&&(d+=4),h+=3,f+=o,u+=o*4;return l}static async readMesh(e,i,s,r=1,n=new Uint8Array([255,255,255,255]),a=!0){let o=new Uint32Array([]),l=new Float32Array([]),c="",h;const d=/(?:\.([^.]+))?$/;let f=d.exec(i)[1];if(f=f.toUpperCase(),f==="GZ"&&(f=d.exec(i.slice(0,-3))[1],f=f.toUpperCase()),f==="JCON"&&U.error("you should never see this message: load using nvconnectome not nvmesh"),f==="JSON"&&U.error("you should never see this message: load using nvconnectome not nvmesh"),n[3]=Math.max(1,n[3]),f==="TCK"||f==="TRK"||f==="TT"||f==="TRX"||f==="TRACT"){if(f==="TCK"?h=Ae.readTCK(e):f==="TRACT"?h=Ae.readTRACT(e):f==="TT"?h=await Ae.readTT(e):f==="TRX"?h=await Ae.readTRX(e):h=await Ae.readTRK(e),typeof h>"u"){const p=new Float32Array([0,0,0,0,0,0]),A=new Uint32Array([0]);h={pts:p,offsetPt0:A},U.error("Creating empty tracts")}return n[3]=0,new wt(h.pts,h.offsetPt0,i,n,r,a,s,"inferno",h.dpg||null,h.dps||null,h.dpv||null)}if(f==="GII")h=await Ae.readGII(e);else if(f==="MZ3")h=await Ae.readMZ3(e),"positions"in h||U.warn("MZ3 does not have positions (statistical overlay?)");else if(f==="ASC")h=Ae.readASC(e);else if(f==="DFS")h=Ae.readDFS(e);else if(f==="BYU"||f==="G")h=Ae.readGEO(e);else if(f==="GEO")h=Ae.readGEO(e,!0);else if(f==="ICO"||f==="TRI")h=Ae.readICO(e);else if(f==="OFF")h=Ae.readOFF(e);else if(f==="NV")h=Ae.readNV(e);else if(f==="OBJ")h=await Ae.readOBJ(e);else if(f==="PLY")h=Ae.readPLY(e);else if(f==="WRL")h=Ae.readWRL(e);else if(f==="X3D")h=Ae.readX3D(e);else if(f==="FIB"||f==="VTK"){if(h=Ae.readVTK(e),"offsetPt0"in h)return n[3]=0,new wt(h.pts,h.offsetPt0,i,n,r,a,s,"inferno")}else f==="SRF"?h=await Ae.readSRF(e):f==="STL"?h=Ae.readSTL(e):h=Ae.readFreeSurfer(e);if(h.anatomicalStructurePrimary&&(c=h.anatomicalStructurePrimary),h instanceof Float32Array)throw new Error("fatal: unknown mesh type loaded");if(!("positions"in h))throw new Error("positions not loaded");if(!h.indices)throw new Error("indices not loaded");if(l=h.positions,o=h.indices,"rgba255"in h&&h.rgba255.length>0&&(n=h.rgba255),"colors"in h&&h.colors&&h.colors.length===l.length){const p=l.length/3;n=new Uint8Array(p*4);let A=0,w=0;for(let x=0;x<p;x++)n[w++]=h.colors[A]*255,n[w++]=h.colors[A+1]*255,n[w++]=h.colors[A+2]*255,n[w++]=255,A+=3}const u=l.length/3;if(o.length/3<1||u<3)throw new Error("Mesh should have at least one triangle and three vertices");n[3]=Math.max(1,n[3]);const g=new wt(l,o,i,n,r,a,s,null,null,null,null,!0,c);if("scalars"in h&&h.scalars.length>0){const p=await Ae.readLayer(i,e,g,r,"gray");typeof p>"u"?U.warn("readLayer() failed to convert scalars"):(g.layers.push(p),g.updateMesh(s))}return g}static async loadLayer(e,i){let s=new Uint8Array().buffer;function r(m){const g=window.atob(m),p=g.length,A=new Uint8Array(p);for(let w=0;w<p;w++)A[w]=g.charCodeAt(w);return A.buffer}if(e.base64!==void 0)s=r(e.base64);else{if(!e.url)throw new Error("layer: missing url");const m=await fetch(e.url,{headers:e.headers});if(!m.ok)throw Error(m.statusText);s=await m.arrayBuffer()}let n,a=[];if(e.name&&e.name!=="")n=e.name;else{if(!e.url)throw new Error("layer: missing url");try{a=new URL(e.url).pathname.split("/")}catch{a=e.url.split("/")}finally{n=a.slice(-1)[0]}}n.indexOf("?")>-1&&(n=n.slice(0,n.indexOf("?")));let o=.5;"opacity"in e&&(o=e.opacity);let l="warm";"colormap"in e&&(l=e.colormap);let c="winter";"colormapNegative"in e&&(c=e.colormapNegative);let h=!1;"useNegativeCmap"in e&&(h=e.useNegativeCmap);let d=null;"cal_min"in e&&(d=e.cal_min);let f=null;"cal_max"in e&&(f=e.cal_max);const u=await Ae.readLayer(n,s,i,o,l,c,h,d,f);u&&i.layers.push(u)}static async loadFromUrl({url:e="",headers:i={},gl:s,name:r="",opacity:n=1,rgba255:a=[255,255,255,255],visible:o=!0,layers:l=[],buffer:c=new ArrayBuffer(0)}={}){let h=e.split("/");if(r===""){try{h=new URL(e).pathname.split("/")}catch{h=e.split("/")}r=h.slice(-1)[0],r.indexOf("?")>-1&&(r=r.slice(0,r.indexOf("?")))}if(e==="")throw Error("url must not be empty");if(!s)throw Error("gl context is null");let d;if(c.byteLength>0)d=c;else{const u=await fetch(e,{headers:i});if(!u.ok)throw Error(u.statusText);d=await u.arrayBuffer()}const f=await this.readMesh(d,r,s,n,new Uint8Array(a),o);if(!l||l.length<1)return f;for(let u=0;u<l.length;u++)await wt.loadLayer(l[u],f);return f.updateMesh(s),f}static async readFileAsync(e){return new Promise((i,s)=>{const r=new FileReader;r.onload=()=>{i(r.result)},r.onerror=s,r.readAsArrayBuffer(e)})}static async loadFromFile({file:e,gl:i,name:s="",opacity:r=1,rgba255:n=[255,255,255,255],visible:a=!0,layers:o=[]}={}){if(!e)throw new Error("file must be set");if(!i)throw new Error("rendering context must be set");const l=await wt.readFileAsync(e),c=await wt.readMesh(l,s,i,r,new Uint8Array(n),a);if(!o||o.length<1)return c;for(let h=0;h<o.length;h++)await wt.loadLayer(o[h],c);return c.updateMesh(i),c}async loadFromBase64({base64:e,gl:i,name:s="",opacity:r=1,rgba255:n=[255,255,255,255],visible:a=!0,layers:o=[]}={}){if(!e)throw new Error("base64 must bet set");if(!i)throw new Error("rendering context must be set");function l(d){const f=window.atob(d),u=f.length,m=new Uint8Array(u);for(let g=0;g<u;g++)m[g]=f.charCodeAt(g);return m.buffer}const c=l(e),h=await wt.readMesh(c,s,i,r,new Uint8Array(n),a);if(!o||o.length<1)return h;for(let d=0;d<o.length;d++)await wt.loadLayer(o[d],h);return h.updateMesh(i),h}},Nd="data:image/jpeg;base64,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ZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAABOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAAMjhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAACAAAAAgAAAAAEAG0AYwA2ADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAIAAAAAAFJnaHRsb25nAAACAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAA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bnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMTJUMjA6MDc6NDcrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0OGNjMGI3YS1iYTJkLWZmNDAtYmNkNC1jNGQzMzIyZjBiNzQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYzFjM2NhNS1hYTg4LWI5NGMtOGE4MS05YmU4MjA3ZGZiODciPiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YThjMGNhZTYtODNjYy1hYzQ4LWI2YzAtN2FiODNlOWJkMGM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWMxYzNjYTUtYWE4OC1iOTRjLThhODEtOWJlODIwN2RmYjg3IiBzdEV2dDp3aGVuPSIyMDE4LTA3LTEyVDIwOjA3OjQ3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmI3MzZlZC0zOTRhLTM2NDgtYThiOC02Mzk1MmY0NDcxMjIiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTY6MTM6NTgrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0xM1QxNzo1NDoyNyswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTc6NTQ6MjcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg3NjM1NDk5LWZiMTItYWU0MC04NWEzLThkMWFiN2NkZGVhOSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFjMWMzY2E1LWFhODgtYjk0Yy04YTgxLTliZTgyMDdkZmI4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAEAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1Q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",Ma="data:image/png;base64,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",Ia={atlas:{type:"msdf",distanceRange:2,size:59.65625,width:512,height:256,yOrigin:"bottom"},metrics:{emSize:1,lineHeight:1.171875,ascender:.927734375,descender:-.244140625,underlineY:-.09765625,underlineThickness:.048828125},glyphs:[{unicode:32,advance:.24755859375},{unicode:33,advance:.25732421875,planeBounds:{left:.056159633438645884,bottom:-.02437761405677056,right:.20702396031135412,top:.7299440203067705},atlasBounds:{left:488.5,bottom:145.5,right:497.5,top:190.5}},{unicode:34,advance:.31982421875,planeBounds:{left:.049409125974004715,bottom:.48691155587022,right:.2840869677759953,top:.77187750662978},atlasBounds:{left:486.5,bottom:213.5,right:500.5,top:230.5}},{unicode:35,advance:.61572265625,planeBounds:{left:.037219103997511785,bottom:-.02169206718177056,right:.6239137085024882,top:.7326295671817705},atlasBounds:{left:66.5,bottom:51.5,right:101.5,top:96.5}},{unicode:36,advance:.5615234375,planeBounds:{left:.02956531458715296,bottom:-.12381369908983761,right:.5324464041628472,top:.8484230740898377},atlasBounds:{left:109.5,bottom:197.5,right:139.5,top:255.5}},{unicode:37,advance:.732421875,planeBounds:{left:.026481776289942378,bottom:-.030073418674698794,right:.7137525987100576,top:.7410109186746989},atlasBounds:{left:88.5,bottom:144.5,right:129.5,top:190.5}},{unicode:38,advance:.62158203125,planeBounds:{left:.03225572125458355,bottom:-.030073418674698794,right:.6357130287454166,top:.7410109186746989},atlasBounds:{left:130.5,bottom:144.5,right:166.5,top:190.5}},{unicode:39,advance:.17431640625,planeBounds:{left:.028244602049502358,bottom:.49895501673814824,right:.14558352295049765,top:.7671582645118518},atlasBounds:{left:498.5,bottom:62.5,right:505.5,top:78.5}},{unicode:40,advance:.341796875,planeBounds:{left:.042983329377291775,bottom:-.250029542422407,right:.34471198312270823,top:.8227834486724072},atlasBounds:{left:.5,bottom:191.5,right:18.5,top:255.5}},{unicode:41,advance:.34765625,planeBounds:{left:-.003159248747708225,bottom:-.250029542422407,right:.29856940499770823,top:.8227834486724072},atlasBounds:{left:19.5,bottom:191.5,right:37.5,top:255.5}},{unicode:42,advance:.4306640625,planeBounds:{left:-.011208599684062338,bottom:.27785390031593765,right:.44138438093406235,top:.7304468809340623},atlasBounds:{left:449.5,bottom:23.5,right:476.5,top:50.5}},{unicode:43,advance:.56689453125,planeBounds:{left:.01353503347629649,bottom:.053493525733368255,right:.5499415290237036,top:.6066627242666317},atlasBounds:{left:361.5,bottom:17.5,right:393.5,top:50.5}},{unicode:44,advance:.1962890625,planeBounds:{left:-.009919475797210583,bottom:-.15981695975478,right:.1744702570472106,top:.12514899100478},atlasBounds:{left:498.5,bottom:79.5,right:509.5,top:96.5}},{unicode:45,advance:.27587890625,planeBounds:{left:-.00527594412977999,bottom:.24333249267450235,right:.27969000662978,top:.36067141357549765},atlasBounds:{left:52.5,bottom:7.5,right:69.5,top:14.5}},{unicode:46,advance:.26318359375,planeBounds:{left:.051032680313645884,bottom:-.027092319686354116,right:.20189700718635412,top:.12377200718635412},atlasBounds:{left:501.5,bottom:221.5,right:510.5,top:230.5}},{unicode:47,advance:.412109375,planeBounds:{left:-.013733006073205867,bottom:-.08573505127848349,right:.4053345685732059,top:.7356373950284835},atlasBounds:{left:252.5,bottom:206.5,right:277.5,top:255.5}},{unicode:48,advance:.5615234375,planeBounds:{left:.037458384830081196,bottom:-.030073418674698794,right:.5235767714199189,top:.7410109186746989},atlasBounds:{left:167.5,bottom:144.5,right:196.5,top:190.5}},{unicode:49,advance:.5615234375,planeBounds:{left:.06023674350936354,bottom:-.01998308280677056,right:.37872810024063647,top:.7343385515567705},atlasBounds:{left:488.5,bottom:97.5,right:507.5,top:142.5}},{unicode:50,advance:.5615234375,planeBounds:{left:.025334353719224725,bottom:-.01680925468177056,right:.5449781462807752,top:.7375123796817705},atlasBounds:{left:278.5,bottom:51.5,right:309.5,top:96.5}},{unicode:51,advance:.5615234375,planeBounds:{left:.028181041080081196,bottom:-.030073418674698794,right:.5142994276699189,top:.7410109186746989},atlasBounds:{left:197.5,bottom:144.5,right:226.5,top:190.5}},{unicode:52,advance:.5615234375,planeBounds:{left:.005886103858368255,bottom:-.02169206718177056,right:.5590553023916317,top:.7326295671817705},atlasBounds:{left:310.5,bottom:51.5,right:343.5,top:96.5}},{unicode:53,advance:.5615234375,planeBounds:{left:.055524791080081196,bottom:-.02657487968177056,right:.5416431776699189,top:.7277467546817705},atlasBounds:{left:344.5,bottom:51.5,right:373.5,top:96.5}},{unicode:54,advance:.5615234375,planeBounds:{left:.046003306705081196,bottom:-.034712090549698794,right:.5321216932949189,top:.7363722467996989},atlasBounds:{left:227.5,bottom:144.5,right:256.5,top:190.5}},{unicode:55,advance:.5615234375,planeBounds:{left:.018010134969224725,bottom:-.02169206718177056,right:.5376539275307752,top:.7326295671817705},atlasBounds:{left:374.5,bottom:51.5,right:405.5,top:96.5}},{unicode:56,advance:.5615234375,planeBounds:{left:.037702525455081196,bottom:-.030073418674698794,right:.5238209120449189,top:.7410109186746989},atlasBounds:{left:257.5,bottom:144.5,right:286.5,top:190.5}},{unicode:57,advance:.5615234375,planeBounds:{left:.029401744205081196,bottom:-.025434746799698794,right:.5155201307949189,top:.7456495905496989},atlasBounds:{left:287.5,bottom:144.5,right:316.5,top:190.5}},{unicode:58,advance:.2421875,planeBounds:{left:.046394008438645884,bottom:-.029431286627488215,right:.19725833531135412,top:.5572633178774882},atlasBounds:{left:439.5,bottom:61.5,right:448.5,top:96.5}},{unicode:59,advance:.21142578125,planeBounds:{left:.001066852327789419,bottom:-.16459733294591408,right:.1854565851722106,top:.556198895445914},atlasBounds:{left:406.5,bottom:53.5,right:417.5,top:96.5}},{unicode:60,advance:.50830078125,planeBounds:{left:.016948142433865897,bottom:.0726146348300812,right:.4527784200661341,top:.5587330214199189},atlasBounds:{left:394.5,bottom:21.5,right:420.5,top:50.5}},{unicode:61,advance:.548828125,planeBounds:{left:.051535540940937666,bottom:.17620354038436353,right:.5041285215590624,top:.49469489711563647},atlasBounds:{left:477.5,bottom:31.5,right:504.5,top:50.5}},{unicode:62,advance:.5224609375,planeBounds:{left:.047629290940937666,bottom:.0731029160800812,right:.5002222715590624,top:.5592213026699189},atlasBounds:{left:421.5,bottom:21.5,right:448.5,top:50.5}},{unicode:63,advance:.47216796875,planeBounds:{left:.016704001808865897,bottom:-.027876153049698794,right:.4525342794411341,top:.7432081842996989},atlasBounds:{left:317.5,bottom:144.5,right:343.5,top:190.5}},{unicode:64,advance:.89794921875,planeBounds:{left:.034064457306783605,bottom:-.23896750384690937,right:.8721996065996072,top:.7165065663469093},atlasBounds:{left:155.5,bottom:198.5,right:205.5,top:255.5}},{unicode:65,advance:.65234375,planeBounds:{left:-.008838044092129387,bottom:-.02169206718177056,right:.6616700753421295,top:.7326295671817705},atlasBounds:{left:237.5,bottom:51.5,right:277.5,top:96.5}},{unicode:66,advance:.62255859375,planeBounds:{left:.06464099434422473,bottom:-.02169206718177056,right:.5842847869057752,top:.7326295671817705},atlasBounds:{left:205.5,bottom:51.5,right:236.5,top:96.5}},{unicode:67,advance:.65087890625,planeBounds:{left:.038439807122511785,bottom:-.030073418674698794,right:.6251344116274882,top:.7410109186746989},atlasBounds:{left:344.5,bottom:144.5,right:379.5,top:190.5}},{unicode:68,advance:.65576171875,planeBounds:{left:.06301501010836826,bottom:-.02169206718177056,right:.6161842086416317,top:.7326295671817705},atlasBounds:{left:162.5,bottom:51.5,right:195.5,top:96.5}},{unicode:69,advance:.568359375,planeBounds:{left:.0652904160800812,bottom:-.02169206718177056,right:.5514088026699189,top:.7326295671817705},atlasBounds:{left:132.5,bottom:51.5,right:161.5,top:96.5}},{unicode:70,advance:.552734375,planeBounds:{left:.059675181705081196,bottom:-.02169206718177056,right:.5457935682949189,top:.7326295671817705},atlasBounds:{left:102.5,bottom:51.5,right:131.5,top:96.5}},{unicode:71,advance:.68115234375,planeBounds:{left:.040148791497511785,bottom:-.030073418674698794,right:.6268433960024882,top:.7410109186746989},atlasBounds:{left:380.5,bottom:144.5,right:415.5,top:190.5}},{unicode:72,advance:.712890625,planeBounds:{left:.062365588372511785,bottom:-.02169206718177056,right:.6490601928774882,top:.7326295671817705},atlasBounds:{left:30.5,bottom:51.5,right:65.5,top:96.5}},{unicode:73,advance:.27197265625,planeBounds:{left:.06917965680657412,bottom:-.02169206718177056,right:.20328128069342588,top:.7326295671817705},atlasBounds:{left:196.5,bottom:51.5,right:204.5,top:96.5}},{unicode:74,advance:.5517578125,planeBounds:{left:.007184947330081194,bottom:-.02657487968177056,right:.4933033339199188,top:.7277467546817705},atlasBounds:{left:.5,bottom:51.5,right:29.5,top:96.5}},{unicode:75,advance:.626953125,planeBounds:{left:.061633166497511785,bottom:-.02169206718177056,right:.6483277710024882,top:.7326295671817705},atlasBounds:{left:452.5,bottom:97.5,right:487.5,top:142.5}},{unicode:76,advance:.5380859375,planeBounds:{left:.06341786132300943,bottom:-.02169206718177056,right:.5327735449269906,top:.7326295671817705},atlasBounds:{left:423.5,bottom:97.5,right:451.5,top:142.5}},{unicode:77,advance:.873046875,planeBounds:{left:.05911847969322944,bottom:-.02169206718177056,right:.8134401140567705,top:.7326295671817705},atlasBounds:{left:377.5,bottom:97.5,right:422.5,top:142.5}},{unicode:78,advance:.712890625,planeBounds:{left:.062365588372511785,bottom:-.02169206718177056,right:.6490601928774882,top:.7326295671817705},atlasBounds:{left:341.5,bottom:97.5,right:376.5,top:142.5}},{unicode:79,advance:.6875,planeBounds:{left:.033395854136655315,bottom:-.030073418674698794,right:.6536158646133446,top:.7410109186746989},atlasBounds:{left:416.5,bottom:144.5,right:453.5,top:190.5}},{unicode:80,advance:.630859375,planeBounds:{left:.061550166358368255,bottom:-.02169206718177056,right:.6147193648916317,top:.7326295671817705},atlasBounds:{left:273.5,bottom:97.5,right:306.5,top:142.5}},{unicode:81,advance:.6875,planeBounds:{left:.030466166636655315,bottom:-.14391866037519643,right:.6506861771133446,top:.7445045978751964},atlasBounds:{left:214.5,bottom:202.5,right:251.5,top:255.5}},{unicode:82,advance:.61572265625,planeBounds:{left:.06350329135836826,bottom:-.02169206718177056,right:.6166724898916317,top:.7326295671817705},atlasBounds:{left:186.5,bottom:97.5,right:219.5,top:142.5}},{unicode:83,advance:.59326171875,planeBounds:{left:.020778681983368255,bottom:-.030073418674698794,right:.5739478805166317,top:.7410109186746989},atlasBounds:{left:454.5,bottom:144.5,right:487.5,top:190.5}},{unicode:84,advance:.5966796875,planeBounds:{left:.005480822747511787,bottom:-.02169206718177056,right:.5921754272524882,top:.7326295671817705},atlasBounds:{left:112.5,bottom:97.5,right:147.5,top:142.5}},{unicode:85,advance:.6484375,planeBounds:{left:.049098994483368255,bottom:-.02657487968177056,right:.6022681930166317,top:.7277467546817705},atlasBounds:{left:78.5,bottom:97.5,right:111.5,top:142.5}},{unicode:86,advance:.63623046875,planeBounds:{left:-.008269192599201152,bottom:-.02169206718177056,right:.6454762238492011,top:.7326295671817705},atlasBounds:{left:38.5,bottom:97.5,right:77.5,top:142.5}},{unicode:87,advance:.88720703125,planeBounds:{left:.011923628617731797,bottom:-.02169206718177056,right:.8835841838822683,top:.7326295671817705},atlasBounds:{left:220.5,bottom:97.5,right:272.5,top:142.5}},{unicode:88,advance:.626953125,planeBounds:{left:.004098979136655316,bottom:-.02169206718177056,right:.6243189896133446,top:.7326295671817705},atlasBounds:{left:.5,bottom:97.5,right:37.5,top:142.5}},{unicode:89,advance:.6005859375,planeBounds:{left:-.010793598988344685,bottom:-.02169206718177056,right:.6094264114883446,top:.7326295671817705},atlasBounds:{left:148.5,bottom:97.5,right:185.5,top:142.5}},{unicode:90,advance:.5986328125,planeBounds:{left:.024196650733368255,bottom:-.02169206718177056,right:.5773658492666317,top:.7326295671817705},atlasBounds:{left:307.5,bottom:97.5,right:340.5,top:142.5}},{unicode:91,advance:.26513671875,planeBounds:{left:.05437250871693295,bottom:-.17280296457569408,right:.27228764753306706,top:.8329592145756942},atlasBounds:{left:59.5,bottom:195.5,right:72.5,top:255.5}},{unicode:92,advance:.41015625,planeBounds:{left:.0014037126767941326,bottom:-.08573505127848349,right:.4204712873232059,top:.7356373950284835},atlasBounds:{left:278.5,bottom:206.5,right:303.5,top:255.5}},{unicode:93,advance:.26513671875,planeBounds:{left:-.020659233400995285,bottom:-.17280296457569408,right:.2140186084009953,top:.8329592145756942},atlasBounds:{left:94.5,bottom:195.5,right:108.5,top:255.5}},{unicode:94,advance:.41796875,planeBounds:{left:.006855376669722368,bottom:.33229482979472236,right:.40916024833027764,top:.7345997014552776},atlasBounds:{left:486.5,bottom:231.5,right:510.5,top:255.5}},{unicode:95,advance:.451171875,planeBounds:{left:-.017473255794918804,bottom:-.09553469482549765,right:.4686451307949188,top:.021804226075497646},atlasBounds:{left:70.5,bottom:7.5,right:99.5,top:14.5}},{unicode:96,advance:.30908203125,planeBounds:{left:.00391839948107648,bottom:.5860277898277895,right:.2553589442689235,top:.7704175226722105},atlasBounds:{left:36.5,bottom:3.5,right:51.5,top:14.5}},{unicode:97,advance:.5439453125,planeBounds:{left:.028181041080081196,bottom:-.029187146002488215,right:.5142994276699189,top:.5575074585024882},atlasBounds:{left:30.5,bottom:15.5,right:59.5,top:50.5}},{unicode:98,advance:.56103515625,planeBounds:{left:.048932994205081196,bottom:-.032187684160555265,right:.5350513807949189,top:.7724220591605554},atlasBounds:{left:304.5,bottom:207.5,right:333.5,top:255.5}},{unicode:99,advance:.5234375,planeBounds:{left:.024518931705081196,bottom:-.029187146002488215,right:.5106373182949189,top:.5575074585024882},atlasBounds:{left:.5,bottom:15.5,right:29.5,top:50.5}},{unicode:100,advance:.56396484375,planeBounds:{left:.026227916080081196,bottom:-.032187684160555265,right:.5123463026699189,top:.7724220591605554},atlasBounds:{left:334.5,bottom:207.5,right:363.5,top:255.5}},{unicode:101,advance:.52978515625,planeBounds:{left:.026472056705081196,bottom:-.029187146002488215,right:.5125904432949189,top:.5575074585024882},atlasBounds:{left:468.5,bottom:61.5,right:497.5,top:96.5}},{unicode:102,advance:.34716796875,planeBounds:{left:.004575110905578838,bottom:-.022177918535555265,right:.3733545765944212,top:.7824318247855554},atlasBounds:{left:364.5,bottom:207.5,right:386.5,top:255.5}},{unicode:103,advance:.56103515625,planeBounds:{left:.026960337955081196,bottom:-.22888445766762702,right:.5130787245449189,top:.558962582667627},atlasBounds:{left:28.5,bottom:143.5,right:57.5,top:190.5}},{unicode:104,advance:.55078125,planeBounds:{left:.049826556565937666,bottom:-.01892352016762703,right:.5024195371840624,top:.768923520167627},atlasBounds:{left:.5,bottom:143.5,right:27.5,top:190.5}},{unicode:105,advance:.24267578125,planeBounds:{left:.046882289688645884,bottom:-.01680925468177056,right:.19774661656135412,top:.7375123796817705},atlasBounds:{left:498.5,bottom:145.5,right:507.5,top:190.5}},{unicode:106,advance:.23876953125,planeBounds:{left:-.048979545900995285,bottom:-.2324562772148376,right:.1856982959009953,top:.7397804959648377},atlasBounds:{left:140.5,bottom:197.5,right:154.5,top:255.5}},{unicode:107,advance:.5068359375,planeBounds:{left:.044294322330081196,bottom:-.01892352016762703,right:.5304127089199189,top:.768923520167627},atlasBounds:{left:58.5,bottom:143.5,right:87.5,top:190.5}},{unicode:108,advance:.24267578125,planeBounds:{left:.05428707868157412,bottom:-.01892352016762703,right:.18838870256842588,top:.768923520167627},atlasBounds:{left:477.5,bottom:208.5,right:485.5,top:255.5}},{unicode:109,advance:.87646484375,planeBounds:{left:.04430890170737297,bottom:-.024304333502488215,right:.832155942042627,top:.5623902710024882},atlasBounds:{left:116.5,bottom:15.5,right:163.5,top:50.5}},{unicode:110,advance:.5517578125,planeBounds:{left:.049826556565937666,bottom:-.024304333502488215,right:.5024195371840624,top:.5623902710024882},atlasBounds:{left:60.5,bottom:15.5,right:87.5,top:50.5}},{unicode:111,advance:.5703125,planeBounds:{left:.025090213094224725,bottom:-.029187146002488215,right:.5447340056557752,top:.5575074585024882},atlasBounds:{left:193.5,bottom:15.5,right:224.5,top:50.5}},{unicode:112,advance:.56103515625,planeBounds:{left:.048444712955081196,bottom:-.22644305141762702,right:.5345630995449189,top:.561403988917627},atlasBounds:{left:447.5,bottom:208.5,right:476.5,top:255.5}},{unicode:113,advance:.568359375,planeBounds:{left:.025983775455081196,bottom:-.22644305141762702,right:.5121021620449189,top:.561403988917627},atlasBounds:{left:417.5,bottom:208.5,right:446.5,top:255.5}},{unicode:114,advance:.33837890625,planeBounds:{left:.045180595002291775,bottom:-.024304333502488215,right:.34690924874770823,top:.5623902710024882},atlasBounds:{left:449.5,bottom:61.5,right:467.5,top:96.5}},{unicode:115,advance:.515625,planeBounds:{left:.021669814448009427,bottom:-.029187146002488215,right:.4910254980519906,top:.5575074585024882},atlasBounds:{left:164.5,bottom:15.5,right:192.5,top:50.5}},{unicode:116,advance:.32666015625,planeBounds:{left:-.019433670483564695,bottom:-.02877457520298586,right:.3158203892335647,top:.675258950202986},atlasBounds:{left:418.5,bottom:54.5,right:438.5,top:96.5}},{unicode:117,advance:.55126953125,planeBounds:{left:.048117572190937666,bottom:-.034069958502488215,right:.5007105528090624,top:.5526246460024882},atlasBounds:{left:88.5,bottom:15.5,right:115.5,top:50.5}},{unicode:118,advance:.484375,planeBounds:{left:-.002092396419918806,bottom:-.02080579450955998,right:.4840259901699188,top:.5491261070095601},atlasBounds:{left:331.5,bottom:16.5,right:360.5,top:50.5}},{unicode:119,advance:.75146484375,planeBounds:{left:-.002649098431770561,bottom:-.02080579450955998,right:.7516725359317705,top:.5491261070095601},atlasBounds:{left:225.5,bottom:16.5,right:270.5,top:50.5}},{unicode:120,advance:.49560546875,planeBounds:{left:-.0046143729128470395,bottom:-.02080579450955998,right:.4982667166628471,top:.5491261070095601},atlasBounds:{left:300.5,bottom:16.5,right:330.5,top:50.5}},{unicode:121,advance:.47314453125,planeBounds:{left:-.007219349544918806,bottom:-.23645281704262702,right:.4788990370449188,top:.551394223292627},atlasBounds:{left:387.5,bottom:208.5,right:416.5,top:255.5}},{unicode:122,advance:.49560546875,planeBounds:{left:.018007705073009427,bottom:-.02080579450955998,right:.4873633886769906,top:.5491261070095601},atlasBounds:{left:271.5,bottom:16.5,right:299.5,top:50.5}},{unicode:123,advance:.33837890625,planeBounds:{left:.011572188891435306,bottom:-.20234398020069408,right:.3468262486085647,top:.8034181989506942},atlasBounds:{left:73.5,bottom:195.5,right:93.5,top:255.5}},{unicode:124,advance:.24365234375,planeBounds:{left:.06315671142450235,bottom:-.15466084787519643,right:.18049563232549765,top:.7337624103751964},atlasBounds:{left:206.5,bottom:202.5,right:213.5,top:255.5}},{unicode:125,advance:.33837890625,planeBounds:{left:-.010156326733564695,bottom:-.20234398020069408,right:.3250977329835647,top:.8034181989506942},atlasBounds:{left:38.5,bottom:195.5,right:58.5,top:255.5}},{unicode:126,advance:.68017578125,planeBounds:{left:.046984728997511785,bottom:.1766063915990047,right:.6336793335024882,top:.4112842334009953},atlasBounds:{left:.5,bottom:.5,right:35.5,top:14.5}}],kerning:[]},gs={name:"untitled connectome",nodeColormap:"warm",nodeColormapNegative:"winter",nodeMinColor:0,nodeMaxColor:4,nodeScale:3,edgeColormap:"warm",edgeColormapNegative:"winter",edgeMin:2,edgeMax:6,edgeScale:1,legendLineThickness:0,showLegend:!0},ps=class fl extends li{constructor(e,i){super(new Float32Array([]),new Uint32Array([]),i.name,new Uint8Array([]),1,!0,e,i),F(this,"gl"),F(this,"nodesChanged"),this.gl=e,this.type="connectome",this.nodes&&this.updateLabels(),this.nodesChanged=new EventTarget}static convertLegacyConnectome(e){const i={nodes:[],edges:[],...gs};for(const r in e)if(r in gs){const n=r;i[n]=e[n]}const s=e.nodes;for(let r=0;r<s.names.length;r++)i.nodes.push({name:s.names[r],x:s.X[r],y:s.Y[r],z:s.Z[r],colorValue:s.Color[r],sizeValue:s.Size[r]});for(let r=0;r<s.names.length-1;r++)for(let n=r+1;n<s.names.length;n++){const a=e.edges[r*s.names.length+n];i.edges.push({first:r,second:n,colorValue:a})}return i}static convertFreeSurferConnectome(e,i="warm"){let s=!0;if("data_type"in e?e.data_type!=="fs_pointset"&&(s=!1):s=!1,"points"in e||(s=!1),!s)throw Error("not a valid FreeSurfer json pointset");const r=e.points.map(a=>({name:Array.isArray(a.comments)&&a.comments.length>0&&"text"in a.comments[0]?a.comments[0].text:"",x:a.coordinates.x,y:a.coordinates.y,z:a.coordinates.z,colorValue:1,sizeValue:1,metadata:a.comments}));return{...gs,nodeColormap:i,edgeColormap:i,nodes:r,edges:[]}}updateLabels(){const e=this.nodes;if(e&&e.length>0){const i=e.reduce((c,h)=>c.sizeValue>h.sizeValue?c:h).sizeValue;let s,r;if(typeof this.nodeMinColor<"u"&&isFinite(this.nodeMinColor))s=this.nodeMinColor;else{s=e[0].colorValue;for(let c=1;c<e.length;c++)e[c].colorValue<s&&(s=e[c].colorValue)}if(typeof this.nodeMaxColor<"u"&&isFinite(this.nodeMaxColor))r=this.nodeMaxColor;else{r=e[0].colorValue;for(let c=1;c<e.length;c++)e[c].colorValue>r&&(r=e[c].colorValue)}const n=ce.colormap(this.nodeColormap,this.colormapInvert),a=ce.colormap(this.nodeColormapNegative,this.colormapInvert),o="nodeColormapNegative"in this;let l=this.legendLineThickness?this.legendLineThickness:0;this.showLegend===!1&&(l=0);for(let c=0;c<e.length;c++){let h=e[c].colorValue,d=!1;if(o&&h<0&&(d=!0,h=-h),s<r){if(h<s){U.warn("color value lower than min");continue}h=(h-s)/(r-s)}else h=1;h=Math.round(Math.max(Math.min(255,h*255)))*4;let f=[n[h],n[h+1],n[h+2],255];d&&(f=[a[h],a[h+1],a[h+2],255]),f=f.map(u=>u/255),U.debug("adding label for ",e[c]),e[c].label=new Bn(e[c].name,{textColor:f,bulletScale:e[c].sizeValue/i,bulletColor:f,lineWidth:l,lineColor:f,textScale:1,textAlignment:"left",lineTerminator:"none"},[e[c].x,e[c].y,e[c].z]),U.debug("label for node:",e[c].label)}}}addConnectomeNode(e){if(U.debug("adding node",e),!this.nodes)throw new Error("nodes not defined");this.nodes.push(e),this.updateLabels(),this.nodesChanged.dispatchEvent(new CustomEvent("nodeAdded",{detail:{node:e}}))}deleteConnectomeNode(e){const i=this.nodes.indexOf(e),s=this.edges;s&&(this.edges=s.filter(r=>r.first!==i&&r.second!==i)),this.nodes=this.nodes.filter(r=>r!==e),this.updateLabels(),this.updateConnectome(this.gl),this.nodesChanged.dispatchEvent(new CustomEvent("nodeDeleted",{detail:{node:e}}))}updateConnectomeNodeByIndex(e,i){this.nodes[e]=i,this.updateLabels(),this.updateConnectome(this.gl),this.nodesChanged.dispatchEvent(new CustomEvent("nodeChanged",{detail:{node:i}}))}updateConnectomeNodeByPoint(e,i){const s=this.nodes;if(!s)throw new Error("Node to update does not exist");const r=s.find(a=>Z.arraysAreEqual([a.x,a.y,a.z],e));if(!r)throw new Error(`Node with point ${e} to update does not exist`);const n=s.findIndex(a=>a===r);this.updateConnectomeNodeByIndex(n,i)}addConnectomeEdge(e,i,s){const r=this.edges;let n=r.find(a=>(a.first===e||a.second===e)&&a.first+a.second===e+i);return n||(n={first:e,second:i,colorValue:s},r.push(n),this.updateConnectome(this.gl),n)}deleteConnectomeEdge(e,i){const s=this.edges,r=s.find(n=>(n.first===e||n.first===i)&&n.first+n.second===e+i);if(r)this.edges=s.filter(n=>n!==r);else throw new Error(`edge between ${e} and ${i} not found`);return this.updateConnectome(this.gl),r}findClosestConnectomeNode(e,i){const s=this.nodes;if(!s||s.length===0)return null;const r=s.map((n,a)=>({node:n,distance:Math.sqrt(Math.pow(n.x-e[0],2)+Math.pow(n.y-e[1],2)+Math.pow(n.z-e[2],2)),index:a})).filter(n=>n.distance<i).sort((n,a)=>n.distance-a.distance);return r.length>0?r[0].node:null}updateConnectome(e){const i=[],s=[],r=[];let n=ce.colormap(this.nodeColormap,this.colormapInvert),a=ce.colormap(this.nodeColormapNegative,this.colormapInvert),o="nodeColormapNegative"in this;this.nodeMinColor===void 0&&(this.nodeMinColor=NaN),this.nodeMaxColor===void 0&&(this.nodeMaxColor=NaN),this.edgeMin===void 0&&(this.edgeMin=NaN),this.edgeMax===void 0&&(this.edgeMax=NaN);let l=this.nodeMinColor,c=this.nodeMaxColor;if(!isFinite(l)||!isFinite(l)){const A=this.nodes;l=A[0].colorValue,c=A[0].colorValue;for(let w=0;w<A.length;w++)l=Math.min(l,A[w].colorValue),c=Math.max(c,A[w].colorValue)}const h=this.nodes,d=h.length;for(let A=0;A<d;A++){const w=h[A].sizeValue*this.nodeScale;if(w<=0)continue;let x=h[A].colorValue,y=!1;if(o&&x<0&&(y=!0,x=-x),l<c){if(x<l)continue;x=(x-l)/(c-l)}else x=1;x=Math.round(Math.max(Math.min(255,x*255)))*4;let v=[n[x],n[x+1],n[x+2],255];y&&(v=[a[x],a[x+1],a[x+2],255]);const D=H(h[A].x,h[A].y,h[A].z);Zt.makeColoredSphere(s,i,r,w,D,v)}n=ce.colormap(this.edgeColormap,this.colormapInvert),a=ce.colormap(this.edgeColormapNegative,this.colormapInvert),o="edgeColormapNegative"in this;const f=this.edges;if(f!==void 0&&f.length>0){if(l=this.edgeMin,c=this.edgeMax,!isFinite(l)||!isFinite(l)){l=f[0].colorValue,c=f[0].colorValue;for(let A=0;A<f.length;A++)l=Math.min(l,f[A].colorValue),c=Math.max(c,f[A].colorValue)}for(const A of f){let w=A.colorValue;const x=o&&w<0;x&&(w=-w);const y=w*this.edgeScale;if(y<=0)continue;if(l<c){if(w<l)continue;w=(w-l)/(c-l)}else w=1;w=Math.round(Math.max(Math.min(255,w*255)))*4;let v=[n[w],n[w+1],n[w+2],255];x&&(v=[a[w],a[w+1],a[w+2],255]);const D=H(h[A.first].x,h[A.first].y,h[A.first].z),b=H(h[A.second].x,h[A.second].y,h[A.second].z);Zt.makeColoredCylinder(s,i,r,D,b,y,v)}}const u=new Float32Array(s),m=new Uint32Array(i),g=bt.getExtents(u);this.furthestVertexFromOrigin=g.mxDx,this.extentsMin=g.extentsMin,this.extentsMax=g.extentsMax;const p=this.generatePosNormClr(u,m,new Uint8Array(r));e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,Uint32Array.from(m),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,Float32Array.from(p),e.STATIC_DRAW),this.indexCount=i.length}updateMesh(e){this.updateConnectome(e),this.updateLabels()}json(){const e={};for(const i in this)(i in gs||i==="nodes"||i==="edges")&&(e[i]=this[i]);return e}static async loadConnectomeFromUrl(e,i){const r=await(await fetch(i)).json();return new fl(e,r)}};function kd(t,e,i){if(!t.dimsRAS||!t.matRAS||!t.pixDimsRAS||!t.vox2mm)throw new Error("Cannot create NiivueObject3D: Missing required RAS properties or vox2mm access on NVImage.");const s=t.dimsRAS,r=t.matRAS,n=t.pixDimsRAS,a=-.5,o=-.5,l=-.5,c=s[1]-1+.5,h=s[2]-1+.5,d=s[3]-1+.5,f=t.vox2mm,u=f.call(t,[a,o,l],r),m=f.call(t,[a,h,l],r),g=f.call(t,[a,o,d],r),p=f.call(t,[a,h,d],r),A=f.call(t,[c,o,l],r),w=f.call(t,[c,h,l],r),x=f.call(t,[c,o,d],r),y=f.call(t,[c,h,d],r),v=[...g,0,0,1,...x,1,0,1,...y,1,1,1,...p,0,1,1,...u,0,0,0,...m,0,1,0,...w,1,1,0,...A,1,0,0],D=i.createBuffer();if(!D)throw new Error("Failed to create GL index buffer");i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,D);const b=[0,3,2,2,1,0,4,7,6,6,5,4,5,6,2,2,3,5,4,0,1,1,7,4,7,1,2,2,6,7,4,5,3,3,0,4];i.bufferData(i.ELEMENT_ARRAY_BUFFER,new Uint16Array(b),i.STATIC_DRAW);const C=i.createBuffer();if(!C)throw new Error("Failed to create GL vertex buffer");i.bindBuffer(i.ARRAY_BUFFER,C),i.bufferData(i.ARRAY_BUFFER,new Float32Array(v),i.STATIC_DRAW);const I=i.createVertexArray();if(!I)throw new Error("Failed to create GL VAO");i.bindVertexArray(I),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,D),i.bindBuffer(i.ARRAY_BUFFER,C);const M=24;i.enableVertexAttribArray(0),i.vertexAttribPointer(0,3,i.FLOAT,!1,M,0),i.enableVertexAttribArray(1),i.vertexAttribPointer(1,3,i.FLOAT,!1,M,12),i.bindVertexArray(null);const T=new Zt(e,C,i.TRIANGLES,b.length,D,I),S=[...g,...x,...y,...p,...u,...m,...w,...A],E=Sd(S);return T.extentsMin=E.min.slice(),T.extentsMax=E.max.slice(),T.furthestVertexFromOrigin=E.furthestVertexFromOrigin,T.originNegate=Vi(E.origin),bc(T.originNegate,T.originNegate),T.fieldOfViewDeObliqueMM=[s[1]*n[1],s[2]*n[2],s[3]*n[3]],T}function Ld(t){return new Promise((e,i)=>{let s;t instanceof File?s=Promise.resolve(t):s=new Promise((r,n)=>{t.file(r,n)}),s.then(r=>{const n=new FileReader;n.onload=()=>{typeof n.result=="string"?e(n.result):i(new Error("Expected a string from FileReader.result"))},n.onerror=()=>{i(n.error??new Error("Unknown FileReader error"))},n.readAsDataURL(r)}).catch(r=>i(r))})}function Od(t){const e=t.hdr.dims,i=t.permRAS,s=e[1]*e[2]*e[3],r=new Int16Array(s),n=[0,0,0];for(let u=0;u<3;u++)for(let m=0;m<3;m++)Math.abs(i[u])-1===m&&(n[m]=u*Math.sign(i[u]));let a=1;const o=[1,1,1],l=[!1,!1,!1];for(let u=0;u<n.length;u++)for(let m=0;m<n.length;m++)Math.abs(n[m])===u&&(o[m]=a,(n[m]<0||Object.is(n[m],-0))&&(l[m]=!0),a*=e[m+1]);let c=Z.range(0,e[1]-1,1);l[0]&&(c=Z.range(e[1]-1,0,-1));for(let u=0;u<e[1];u++)c[u]*=o[0];let h=Z.range(0,e[2]-1,1);l[1]&&(h=Z.range(e[2]-1,0,-1));for(let u=0;u<e[2];u++)h[u]*=o[1];let d=Z.range(0,e[3]-1,1);l[2]&&(d=Z.range(e[3]-1,0,-1));for(let u=0;u<e[3];u++)d[u]*=o[2];let f=0;for(let u=0;u<e[3];u++)for(let m=0;m<e[2];m++)for(let g=0;g<e[1];g++)r[c[g]+h[m]+d[u]]=t.img[f],f++;return r}function Fa(t,e){const i=Math.floor(Math.log(t)/Math.log(10)),s=t/Math.pow(10,i);let r;return e?s<1.5?r=1:s<3?r=2:s<7?r=5:r=10:s<=1?r=1:s<=2?r=2:s<=5?r=5:r=10,r*Math.pow(10,i)}function bi(t,e,i=4){const s=Fa(e-t,!1),r=Fa(s/(i-1),!0),n=Math.floor(t/r)*r,a=Math.ceil(e/r)*r;return[r,n,a,n===t&&a===e]}function Ba(t,e){let i=bi(t,e,3);return i[3]||(i=bi(t,e,5)),i[3]||(i=bi(t,e,4)),i[3]||(i=bi(t,e,3)),i[3]||(i=bi(t,e,5)),[i[0],i[1],i[2]]}function It(t){return t*(Math.PI/180)}function Tr(t,e,i,s){let r=-t,n=-e;return isFinite(i)&&isFinite(s)&&(r=i,n=s),r>n&&([r,n]=[n,r]),[r,n]}function Ge(t,e=[0,1,2]){const i=fe();return i[0]=t[e[0]],i[1]=t[e[1]],i[2]=t[e[2]],i}function Ua(t){const e=ue(1,0,0,0),i=Ct();return Ve(i,e,t),i[0]}function zd(t,e,i,s){const r=ue(t,e,i,1),n=be(s);Je(n,n),r[0]=r[0]*2-1,r[1]=r[1]*2-1,r[2]=r[2]*2-1;const a=Ct();return Ve(a,r,n),a[3]===0||(a[0]/=a[3],a[1]/=a[3],a[2]/=a[3]),a}function Gd(t){const e=[5960464477539063e-23,152587890625e-16,.00390625,1];return(t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3])/255}function Mr(t,e,i){return Math.min(Math.max(t,e),i)}function Yd(t){const e=t.length;let i=0;const s=new Uint8Array(e+Math.ceil(.01*e)),r=new Int8Array(s.buffer);let n=0;for(;i<e;){let a=t[i];i++;let o=1;for(;o<129&&i<e&&t[i]===a;)i++,o++;if(o>1){r[n]=-o+1,n++,s[n]=a,n++;continue}for(;i<e&&!(o>127||i+2<e&&a!==t[i]&&t[i+2]===t[i]&&t[i+1]===t[i]);)a=t[i],i++,o++;s[n]=o-1,n++;for(let l=0;l<o;l++)s[n]=t[i-o+l],n++}return U.info("PackBits "+e+" -> "+n+" bytes (x"+e/n+")"),s.slice(0,n)}function Pa(t,e){const i=new Uint8Array(t.buffer),s=new Int8Array(i.buffer);let r=0;const n=new Uint8Array(e);let a=0;for(;r<i.length;){const o=s[r];if(r++,o<0){const l=s[r];r++;for(let c=0;c<1-o;c++)n[a]=l,a++}else for(let l=0;l<o+1;l++)n[a]=s[r],r++,a++}return n}function Va(t,e){return t.scl_slope===0&&(t.scl_slope=1),e*t.scl_slope+t.scl_inter}var Ot=["ASC","BYU","DFS","FSM","PIAL","ORIG","INFLATED","SMOOTHWM","SPHERE","WHITE","G","GEO","GII","ICO","MZ3","NV","OBJ","OFF","PLY","SRF","STL","TCK","TRACT","TRI","TRK","TT","TRX","VTK","WRL","X3D","JCON","JSON"],Ra=0,Wd=1,Kd=2,si=33984,As=33985,Ir=33986,jd=33987,Hd=33988,Na=33989,ka=33990,Ft=33991,La=33992,qd=33993,Oa=33994,Qd=33995,Xd=33996,Zd=33997,Jd=33998,_d=33999,za={filename:"",isSaveDrawing:!1,volumeByIndex:0},$d=class{constructor(t=yt){F(this,"loaders",{}),F(this,"dicomLoader",null),F(this,"canvas",null),F(this,"_gl",null),F(this,"isBusy",!1),F(this,"needsRefresh",!1),F(this,"colormapTexture",null),F(this,"colormapLists",[]),F(this,"volumeTexture",null),F(this,"gradientTexture",null),F(this,"gradientTextureAmount",0),F(this,"renderGradientValues",!1),F(this,"drawTexture",null),F(this,"drawUndoBitmaps",[]),F(this,"drawLut",ce.makeDrawLut("$itksnap")),F(this,"drawOpacity",.8),F(this,"clickToSegmentIsGrowing",!1),F(this,"clickToSegmentGrowingBitmap",null),F(this,"clickToSegmentXY",[0,0]),F(this,"renderDrawAmbientOcclusion",.4),F(this,"colorbarHeight",0),F(this,"drawPenLocation",[NaN,NaN,NaN]),F(this,"drawPenAxCorSag",-1),F(this,"drawFillOverwrites",!0),F(this,"drawPenFillPts",[]),F(this,"overlayTexture",null),F(this,"overlayTextureID",null),F(this,"sliceMMShader"),F(this,"slice2DShader"),F(this,"sliceV1Shader"),F(this,"orientCubeShader"),F(this,"orientCubeShaderVAO",null),F(this,"rectShader"),F(this,"rectOutlineShader"),F(this,"renderShader"),F(this,"lineShader"),F(this,"line3DShader"),F(this,"passThroughShader"),F(this,"renderGradientShader"),F(this,"renderGradientValuesShader"),F(this,"renderSliceShader"),F(this,"renderVolumeShader"),F(this,"pickingMeshShader"),F(this,"pickingImageShader"),F(this,"colorbarShader"),F(this,"fontShader",null),F(this,"fiberShader"),F(this,"fontTexture",null),F(this,"circleShader"),F(this,"matCapTexture",null),F(this,"bmpShader",null),F(this,"bmpTexture",null),F(this,"thumbnailVisible",!1),F(this,"bmpTextureWH",1),F(this,"growCutShader"),F(this,"orientShaderAtlasU",null),F(this,"orientShaderAtlasI",null),F(this,"orientShaderU",null),F(this,"orientShaderI",null),F(this,"orientShaderF",null),F(this,"orientShaderRGBU",null),F(this,"surfaceShader",null),F(this,"blurShader",null),F(this,"sobelBlurShader",null),F(this,"sobelFirstOrderShader",null),F(this,"sobelSecondOrderShader",null),F(this,"genericVAO",null),F(this,"unusedVAO",null),F(this,"crosshairs3D",null),F(this,"DEFAULT_FONT_GLYPH_SHEET",Ma),F(this,"DEFAULT_FONT_METRICS",Ia),F(this,"fontMetrics"),F(this,"fontMets",null),F(this,"backgroundMasksOverlays",0),F(this,"overlayOutlineWidth",0),F(this,"overlayAlphaShader",1),F(this,"position"),F(this,"extentsMin"),F(this,"extentsMax"),F(this,"resizeObserver",null),F(this,"resizeEventListener",null),F(this,"canvasObserver",null),F(this,"syncOpts",{"3d":!1,"2d":!1,zoomPan:!1,cal_min:!1,cal_max:!1,clipPlane:!1,gamma:!1,sliceType:!1,crosshair:!1}),F(this,"readyForSync",!1),F(this,"uiData",{mousedown:!1,touchdown:!1,mouseButtonLeftDown:!1,mouseButtonCenterDown:!1,mouseButtonRightDown:!1,mouseDepthPicker:!1,clickedTile:-1,pan2DxyzmmAtMouseDown:[0,0,0,1],prevX:0,prevY:0,currX:0,currY:0,currentTouchTime:0,lastTouchTime:0,touchTimer:null,doubleTouch:!1,isDragging:!1,dragStart:[0,0],dragEnd:[0,0],dragClipPlaneStartDepthAziElev:[0,0,0],lastTwoTouchDistance:0,multiTouchGesture:!1,windowX:0,windowY:0}),F(this,"back",null),F(this,"overlays",[]),F(this,"deferredVolumes",[]),F(this,"deferredMeshes",[]),F(this,"furthestVertexFromOrigin",100),F(this,"volScale",[]),F(this,"vox",[]),F(this,"mousePos",[0,0]),F(this,"screenSlices",[]),F(this,"cuboidVertexBuffer"),F(this,"otherNV",null),F(this,"volumeObject3D",null),F(this,"pivot3D",[0,0,0]),F(this,"furthestFromPivot",10),F(this,"currentClipPlaneIndex",0),F(this,"lastCalled",new Date().getTime()),F(this,"selectedObjectId",-1),F(this,"CLIP_PLANE_ID",1),F(this,"VOLUME_ID",254),F(this,"DISTANCE_FROM_CAMERA",-.54),F(this,"graph",{LTWH:[0,0,640,480],opacity:0,vols:[0],autoSizeMultiplanar:!1,normalizeValues:!1,isRangeCalMinMax:!1}),F(this,"customLayout",[]),F(this,"meshShaders",[{Name:"Phong",Frag:G0},{Name:"Matte",Frag:W0},{Name:"Harmonic",Frag:j0},{Name:"Hemispheric",Frag:K0},{Name:"Crevice",Frag:z0},{Name:"Edge",Frag:k0},{Name:"Diffuse",Frag:L0},{Name:"Outline",Frag:V0},{Name:"Specular",Frag:O0},{Name:"Toon",Frag:P0},{Name:"Flat",Frag:Ea},{Name:"Matcap",Frag:Y0},{Name:"Rim",Frag:R0},{Name:"Silhouette",Frag:N0}]),F(this,"dragModes",{contrast:1,measurement:2,none:0,pan:3,slicer3D:4,callbackOnly:5}),F(this,"sliceTypeAxial",0),F(this,"sliceTypeCoronal",1),F(this,"sliceTypeSagittal",2),F(this,"sliceTypeMultiplanar",3),F(this,"sliceTypeRender",4),F(this,"onDragRelease",()=>{}),F(this,"onMouseUp",()=>{}),F(this,"onLocationChange",()=>{}),F(this,"onIntensityChange",()=>{}),F(this,"onClickToSegment",()=>{}),F(this,"onImageLoaded",()=>{}),F(this,"onMeshLoaded",()=>{}),F(this,"onFrameChange",()=>{}),F(this,"onError",()=>{}),F(this,"onColormapChange",()=>{}),F(this,"onInfo",()=>{}),F(this,"onWarn",()=>{}),F(this,"onDebug",()=>{}),F(this,"onVolumeAddedFromUrl",()=>{}),F(this,"onVolumeWithUrlRemoved",()=>{}),F(this,"onVolumeUpdated",()=>{}),F(this,"onMeshAddedFromUrl",()=>{}),F(this,"onMeshAdded",()=>{}),F(this,"onMeshWithUrlRemoved",()=>{}),F(this,"onZoom3DChange",()=>{}),F(this,"onAzimuthElevationChange",()=>{}),F(this,"onClipPlaneChange",()=>{}),F(this,"onCustomMeshShaderAdded",()=>{}),F(this,"onMeshShaderChanged",()=>{}),F(this,"onMeshPropertyChanged",()=>{}),F(this,"onDicomLoaderFinishedWithImages",()=>{}),F(this,"onDocumentLoaded",()=>{}),F(this,"document",new Dr),F(this,"mediaUrlMap",new Map),F(this,"initialized",!1),F(this,"currentDrawUndoBitmap");for(const e in t)typeof t[e]=="function"?this[e]=t[e]:this.opts[e]=yt[e]===void 0?yt[e]:t[e];this.opts.forceDevicePixelRatio===0?this.uiData.dpr=window.devicePixelRatio||1:this.opts.forceDevicePixelRatio<0?this.uiData.dpr=1:this.uiData.dpr=this.opts.forceDevicePixelRatio,this.currentDrawUndoBitmap=this.opts.maxDrawUndoBitmaps,this.opts.drawingEnabled&&this.createEmptyDrawing(),this.opts.thumbnail.length>0&&(this.thumbnailVisible=!0),U.setLogLevel(this.opts.logLevel)}get scene(){return this.document.scene}get opts(){return this.document.opts}get sliceMosaicString(){return this.document.opts.sliceMosaicString||""}set sliceMosaicString(t){this.document.opts.sliceMosaicString=t}get isAlphaClipDark(){return this.document.opts.isAlphaClipDark}set isAlphaClipDark(t){this.document.opts.isAlphaClipDark=t}cleanup(){this.resizeEventListener&&(window.removeEventListener("resize",this.resizeEventListener),this.resizeEventListener=null),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),this.canvasObserver&&(this.canvasObserver.disconnect(),this.canvasObserver=null),this.canvas&&this.opts.interactive&&(this.canvas.removeEventListener("mousedown",this.mouseDownListener.bind(this)),this.canvas.removeEventListener("mouseup",this.mouseUpListener.bind(this)),this.canvas.removeEventListener("mousemove",this.mouseMoveListener.bind(this)),this.canvas.removeEventListener("touchstart",this.touchStartListener.bind(this)),this.canvas.removeEventListener("touchend",this.touchEndListener.bind(this)),this.canvas.removeEventListener("touchmove",this.touchMoveListener.bind(this)),this.canvas.removeEventListener("wheel",this.wheelListener.bind(this)),this.canvas.removeEventListener("contextmenu",this.mouseContextMenuListener.bind(this)),this.canvas.removeEventListener("dblclick",this.resetBriCon.bind(this)),this.canvas.removeEventListener("dragenter",this.dragEnterListener.bind(this)),this.canvas.removeEventListener("dragover",this.dragOverListener.bind(this)),this.canvas.removeEventListener("drop",this.dropListener.bind(this)),this.canvas.removeEventListener("keyup",this.keyUpListener.bind(this)),this.canvas.removeEventListener("keydown",this.keyDownListener.bind(this)))}get volumes(){return this.document.volumes}set volumes(t){this.document.volumes=t}get meshes(){return this.document.meshes}set meshes(t){this.document.meshes=t}get drawBitmap(){return this.document.drawBitmap}set drawBitmap(t){this.document.drawBitmap=t}get volScaleMultiplier(){return this.scene.volScaleMultiplier}set volScaleMultiplier(t){this.setScale(t)}async saveScene(t="niivue.png"){function e(s,r){const n=document.createElement("a");document.body.appendChild(n),n.style.display="none";const a=window.URL.createObjectURL(s);n.href=a,n.download=r,n.click(),n.remove()}const i=this.canvas;if(!i)throw new Error("canvas not defined");this.drawScene(),i.toBlob(s=>{s&&(t===""&&(t=`niivue-screenshot-${new Date().toString()}.png`,t=t.replace(/\s/g,"_")),e(s,t))})}async attachTo(t,e=null){return await this.attachToCanvas(document.getElementById(t),e),U.debug("attached to element with id: ",t),this}async attachToCanvas(t,e=null){return this.canvas=t,e===null&&(e=navigator.hardwareConcurrency>6,U.debug("AntiAlias ",e," Threads ",navigator.hardwareConcurrency)),this.gl=this.canvas.getContext("webgl2",{alpha:!0,antialias:e}),this.uiData.max2D=this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE),this.uiData.max3D=this.gl.getParameter(this.gl.MAX_3D_TEXTURE_SIZE),U.info("NIIVUE VERSION ",va),U.debug(`Max texture size 2D: ${this.uiData.max2D} 3D: ${this.uiData.max3D}`),this.canvas.parentElement.style.backgroundColor="black",this.opts.isResizeCanvas&&(this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.display="block",this.canvas.width=this.canvas.offsetWidth,this.canvas.height=this.canvas.offsetHeight,this.resizeEventListener=()=>{requestAnimationFrame(()=>{this.resizeListener()})},window.addEventListener("resize",this.resizeEventListener),this.resizeObserver=new ResizeObserver(()=>{requestAnimationFrame(()=>{this.resizeListener()})}),this.resizeObserver.observe(this.canvas.parentElement),this.canvasObserver=new MutationObserver(i=>{for(const s of i)if(s.type==="childList"&&s.removedNodes.length>0&&Array.from(s.removedNodes).includes(this.canvas)){this.cleanup();break}}),this.canvasObserver.observe(this.canvas.parentElement,{childList:!0})),this.opts.interactive&&this.registerInteractions(),await this.init(),this.drawScene(),this}syncWith(t,e={"2d":!0,"3d":!0}){t instanceof Array||(t=[t]),this.otherNV=t,this.syncOpts={...e}}broadcastTo(t,e={"2d":!0,"3d":!0}){t instanceof Array||(t=[t]),this.otherNV=t,this.syncOpts=e}doSync3d(t){t.scene.renderAzimuth=this.scene.renderAzimuth,t.scene.renderElevation=this.scene.renderElevation,t.scene.volScaleMultiplier=this.scene.volScaleMultiplier}doSync2d(t){const e=this.frac2mm(this.scene.crosshairPos);t.scene.crosshairPos=t.mm2frac(e),t.scene.pan2Dxyzmm=Tt(this.scene.pan2Dxyzmm)}doSyncGamma(t){const e=this.scene.gamma,i=t.scene.gamma;e!==i&&t.setGamma(e)}doSyncZoomPan(t){t.scene.pan2Dxyzmm=Tt(this.scene.pan2Dxyzmm)}doSyncCrosshair(t){const e=this.frac2mm(this.scene.crosshairPos);t.scene.crosshairPos=t.mm2frac(e)}doSyncCalMin(t){this.volumes[0].cal_min!==t.volumes[0].cal_min&&(t.volumes[0].cal_min=this.volumes[0].cal_min,t.updateGLVolume())}doSyncCalMax(t){this.volumes[0].cal_max!==t.volumes[0].cal_max&&(t.volumes[0].cal_max=this.volumes[0].cal_max,t.updateGLVolume())}doSyncSliceType(t){t.setSliceType(this.opts.sliceType)}doSyncClipPlane(t){t.setClipPlane(this.scene.clipPlaneDepthAziElev)}sync(){if(!(!this.gl||!this.otherNV||typeof this.otherNV>"u")&&this.gl.canvas.matches(":focus"))for(let t=0;t<this.otherNV.length;t++)this.otherNV[t]!==this&&(this.syncOpts.gamma&&this.doSyncGamma(this.otherNV[t]),this.syncOpts.crosshair&&this.doSyncCrosshair(this.otherNV[t]),this.syncOpts.zoomPan&&this.doSyncZoomPan(this.otherNV[t]),this.syncOpts.sliceType&&this.doSyncSliceType(this.otherNV[t]),this.syncOpts.cal_min&&this.doSyncCalMin(this.otherNV[t]),this.syncOpts.cal_max&&this.doSyncCalMax(this.otherNV[t]),this.syncOpts.clipPlane&&this.doSyncClipPlane(this.otherNV[t]),this.syncOpts["2d"]&&this.doSync2d(this.otherNV[t]),this.syncOpts["3d"]&&this.doSync3d(this.otherNV[t]),this.otherNV[t].drawScene(),this.otherNV[t].createOnLocationChange())}arrayEquals(t,e){return Array.isArray(t)&&Array.isArray(e)&&t.length===e.length&&t.every((i,s)=>i===e[s])}resizeListener(){if(!(!this.canvas||!this.gl)){if(!this.opts.isResizeCanvas){this.opts.forceDevicePixelRatio>=0&&U.warn("this.opts.forceDevicePixelRatio requires isResizeCanvas"),this.drawScene();return}this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.display="block",this.opts.forceDevicePixelRatio===0?this.uiData.dpr=window.devicePixelRatio||1:this.opts.forceDevicePixelRatio<0?this.uiData.dpr=1:this.uiData.dpr=this.opts.forceDevicePixelRatio,U.debug("devicePixelRatio: "+this.uiData.dpr),"width"in this.canvas.parentElement?(this.canvas.width=this.canvas.parentElement.width*this.uiData.dpr,this.canvas.height=this.canvas.parentElement.height*this.uiData.dpr):(this.canvas.width=this.canvas.offsetWidth*this.uiData.dpr,this.canvas.height=this.canvas.offsetHeight*this.uiData.dpr),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.drawScene()}}getRelativeMousePosition(t,e){if(e=e||t.target,!e)return;const i=e.getBoundingClientRect();return{x:t.clientX-i.left,y:t.clientY-i.top}}getNoPaddingNoBorderCanvasRelativeMousePosition(t,e){return e=e||t.target,this.getRelativeMousePosition(t,e)}mouseContextMenuListener(t){t.preventDefault()}mouseDownListener(t){t.preventDefault(),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.uiData.mousedown=!0,this.setDragStart(0,0),this.setDragEnd(0,0),U.debug("mouse down"),U.debug(t);const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(!e)return;const[i,s]=[e.x*this.uiData.dpr,e.y*this.uiData.dpr];this.opts.clickToSegment&&(this.clickToSegmentXY=[i,s]);const r=this.getLabelAtPoint([i,s]);if(r){if(r.onClick){r.onClick(r,t);return}for(const n of this.meshes)if(n.type==="connectome")for(const a of n.nodes)a.label===r&&(this.scene.crosshairPos=this.mm2frac([a.x,a.y,a.z]),this.updateGLVolume(),this.drawScene())}this.uiData.clickedTile=this.tileIndex(i,s),t.button===Ra&&t.shiftKey?(this.uiData.mouseButtonCenterDown=!0,this.mouseCenterButtonHandler(t)):t.button===Ra?(this.uiData.mouseButtonLeftDown=!0,this.mouseLeftButtonHandler(t)):t.button===Kd?(this.uiData.mouseButtonRightDown=!0,this.mouseRightButtonHandler(t)):t.button===Wd&&(this.uiData.mouseButtonCenterDown=!0,this.mouseCenterButtonHandler(t))}mouseLeftButtonHandler(t){if(t.ctrlKey||this.opts.dragModePrimary===0){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);this.mouseDown(e.x,e.y),this.mouseClick(e.x,e.y)}else this.opts.dragModePrimary===1&&(this.uiData.windowX=t.x,this.uiData.windowY=t.y)}mouseCenterButtonHandler(t){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);this.mousePos=[e.x*this.uiData.dpr,e.y*this.uiData.dpr],this.opts.dragMode!==0&&(this.setDragStart(e.x,e.y),this.uiData.isDragging||(this.uiData.pan2DxyzmmAtMouseDown=Tt(this.scene.pan2Dxyzmm)),this.uiData.isDragging=!0,this.uiData.dragClipPlaneStartDepthAziElev=this.scene.clipPlaneDepthAziElev)}mouseRightButtonHandler(t){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);this.mousePos=[e.x*this.uiData.dpr,e.y*this.uiData.dpr],this.opts.dragMode!==0&&(this.setDragStart(e.x,e.y),this.uiData.isDragging||(this.uiData.pan2DxyzmmAtMouseDown=Tt(this.scene.pan2Dxyzmm)),this.uiData.isDragging=!0,this.uiData.dragClipPlaneStartDepthAziElev=this.scene.clipPlaneDepthAziElev)}calculateMinMaxVoxIdx(t){if(t.length>2)throw new Error("array must not contain more than two values");return[Math.floor(Math.min(t[0],t[1])),Math.floor(Math.max(t[0],t[1]))]}calculateNewRange({volIdx:t=0}={}){if(this.opts.sliceType===4&&this.sliceMosaicString.length<1||this.uiData.dragStart[0]===this.uiData.dragEnd[0]&&this.uiData.dragStart[1]===this.uiData.dragEnd[1])return;let e=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]);if(e[0]<0)return;const i=this.frac2vox(e,t);if(e=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]),e[0]<0)return;const s=this.frac2vox(e,t);let r=-Number.MAX_VALUE,n=Number.MAX_VALUE;const a=this.calculateMinMaxVoxIdx([i[0],s[0]]),o=this.calculateMinMaxVoxIdx([i[1],s[1]]),l=this.calculateMinMaxVoxIdx([i[2],s[2]]);i[0]-s[0]===0?a[1]=i[0]+1:i[1]-s[1]===0?o[1]=i[1]+1:i[2]-s[2]===0&&(l[1]=i[2]+1);const c=this.volumes[t].hdr,h=this.volumes[t].img;if(!c||!h)return;const d=c.dims[1],f=c.dims[2];for(let g=l[0];g<l[1];g++){const p=g*d*f;for(let A=o[0];A<o[1];A++){const w=A*d;for(let x=a[0];x<a[1];x++){const y=p+w+x;n>h[y]&&(n=h[y]),r<h[y]&&(r=h[y])}}}if(n>=r)return;const u=Va(c,n),m=Va(c,r);this.volumes[t].cal_min=u,this.volumes[t].cal_max=m,this.onIntensityChange(this.volumes[t])}generateMouseUpCallback(t,e){const i=this.tileIndex(this.uiData.dragStart[0],this.uiData.dragStart[1]),s=this.tileIndex(this.uiData.dragEnd[0],this.uiData.dragEnd[1]);let r=-1;i===s&&(r=s);let n=-1;r>=0&&(n=this.screenSlices[r].axCorSag);const a=this.frac2mm(t),o=this.frac2mm(e),l=fe();ta(l,H(a[0],a[1],a[2]),H(o[0],o[1],o[2]));const c=Li(l),h=this.frac2vox(t),d=this.frac2vox(e);this.onDragRelease({fracStart:t,fracEnd:e,voxStart:h,voxEnd:d,mmStart:a,mmEnd:o,mmLength:c,tileIdx:r,axCorSag:n})}mouseUpListener(){function t(s){return Object.prototype.toString.call(s).indexOf("Function")>-1}const e={mouseButtonRightDown:this.uiData.mouseButtonRightDown,mouseButtonCenterDown:this.uiData.mouseButtonCenterDown,isDragging:this.uiData.isDragging,mousePos:this.mousePos,fracPos:this.canvasPos2frac(this.mousePos)};this.uiData.mousedown=!1,this.uiData.mouseButtonRightDown=!1;const i=this.uiData.mouseButtonCenterDown;if(this.uiData.mouseButtonCenterDown=!1,this.uiData.mouseButtonLeftDown=!1,this.drawPenFillPts.length>0&&this.drawPenFilled(),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,t(this.onMouseUp)&&this.onMouseUp(e),this.uiData.isDragging){this.uiData.isDragging=!1,this.opts.dragMode===5&&this.drawScene();const s=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]),r=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(this.generateMouseUpCallback(s,r),this.opts.dragMode===6||this.opts.dragMode!==1||i||this.uiData.dragStart[0]===this.uiData.dragEnd[0]&&this.uiData.dragStart[1]===this.uiData.dragEnd[1])return;this.calculateNewRange({volIdx:0}),this.refreshLayers(this.volumes[0],0)}this.drawScene()}checkMultitouch(t){if(this.uiData.touchdown&&!this.uiData.multiTouchGesture){const e=this.canvas.getBoundingClientRect();this.mouseDown(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top),this.mouseClick(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top)}}touchStartListener(t){t.preventDefault(),this.uiData.touchTimer||(this.uiData.touchTimer=setTimeout(()=>{this.resetBriCon(t)},this.opts.longTouchTimeout)),this.uiData.touchdown=!0,this.uiData.currentTouchTime=new Date().getTime();const e=this.uiData.currentTouchTime-this.uiData.lastTouchTime;if(e<this.opts.doubleTouchTimeout&&e>0){this.uiData.doubleTouch=!0,this.setDragStart(t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,t.targetTouches[0].clientY-t.target.getBoundingClientRect().top),this.resetBriCon(t),this.uiData.lastTouchTime=this.uiData.currentTouchTime;return}else this.uiData.doubleTouch=!1,this.setDragStart(0,0),this.setDragEnd(0,0),this.uiData.lastTouchTime=this.uiData.currentTouchTime;this.uiData.touchdown&&t.touches.length<2?this.uiData.multiTouchGesture=!1:this.uiData.multiTouchGesture=!0,setTimeout(this.checkMultitouch.bind(this),1,t)}touchEndListener(t){if(t.preventDefault(),this.uiData.touchdown=!1,this.uiData.lastTwoTouchDistance=0,this.uiData.multiTouchGesture=!1,this.uiData.touchTimer&&(clearTimeout(this.uiData.touchTimer),this.uiData.touchTimer=null),this.uiData.isDragging){this.uiData.isDragging=!1,this.opts.dragMode===1&&(this.calculateNewRange(),this.refreshLayers(this.volumes[0],0));const e=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]),i=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);this.generateMouseUpCallback(e,i)}this.mouseUpListener()}windowingHandler(t,e,i=0){const s=this.uiData.windowX,r=this.uiData.windowY;let n=this.volumes[0].cal_min,a=this.volumes[0].cal_max;const o=this.volumes[0].global_min,l=this.volumes[0].global_max;e<r?(n+=1,a+=1):e>r&&(n-=1,a-=1),t>s?(n-=1,a+=1):t<s&&(n+=1,a-=1),a-n<1&&(a=n+1),n<o&&(n=o),a>l&&(a=l),n>a&&(n=a-1),this.volumes[i].cal_min=n,this.volumes[i].cal_max=a,this.refreshLayers(this.volumes[i],0),this.uiData.windowX=t,this.uiData.windowY=e}mouseLeaveListener(){this.clickToSegmentIsGrowing&&(U.debug("Mouse left canvas, stopping clickToSegment preview."),this.clickToSegmentIsGrowing=!1,this.refreshDrawing(!0,!1)),this.opts.drawingEnabled&&!isNaN(this.drawPenLocation[0])&&(U.debug("Mouse left canvas during drawing, resetting pen state."),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawPenFillPts=[]),this.uiData.isDragging&&(U.debug("Mouse left canvas during drag, resetting drag state."),this.uiData.isDragging=!1,this.uiData.mouseButtonLeftDown=!1,this.uiData.mouseButtonCenterDown=!1,this.uiData.mouseButtonRightDown=!1,this.uiData.mousedown=!1,this.drawScene())}mouseMoveListener(t){if(this.uiData.mousedown){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(!e)return;const i=e.x*this.uiData.dpr,s=e.y*this.uiData.dpr;if(this.tileIndex(i,s)!==this.uiData.clickedTile)return;if(this.uiData.mouseButtonLeftDown){const n=this.opts.dragModePrimary===0,a=this.opts.dragModePrimary===1;t.ctrlKey||n?(this.mouseMove(e.x,e.y),this.mouseClick(e.x,e.y)):a&&this.windowingHandler(t.x,t.y)}else(this.uiData.mouseButtonRightDown||this.uiData.mouseButtonCenterDown)&&this.setDragEnd(e.x,e.y);this.drawScene(),this.uiData.prevX=this.uiData.currX,this.uiData.prevY=this.uiData.currY}else if(!this.uiData.mousedown&&this.opts.clickToSegment){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(!e)return;const i=e.x*this.uiData.dpr,s=e.y*this.uiData.dpr;this.mousePos=[i,s];const r=this.tileIndex(i,s);r>=0&&this.opts.drawingEnabled&&this.screenSlices[r].axCorSag<=2&&(this.clickToSegmentXY=[i,s],this.clickToSegmentIsGrowing=!0,this.doClickToSegment({x:i,y:s,tileIndex:r}))}}resetBriCon(t=null){if(this.uiData.isDragging)return;let e=!1;this.opts.sliceType===4&&(e=!0);let i=0,s=0;if(t!==null&&("targetTouches"in t?(i=t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,s=t.targetTouches[0].clientY-t.target.getBoundingClientRect().top):(i=t.offsetX,s=t.offsetY),i*=this.uiData.dpr,s*=this.uiData.dpr,this.inRenderTile(i,s)>=0&&(e=!0)),e){this.uiData.mouseDepthPicker=!0,this.drawScene(),this.drawScene();return}this.opts.dragMode!==4&&(this.volumes.length<1||this.uiData.doubleTouch||(this.volumes[0].cal_min=this.volumes[0].robust_min,this.volumes[0].cal_max=this.volumes[0].robust_max,this.onIntensityChange(this.volumes[0]),this.refreshLayers(this.volumes[0],0),this.drawScene()))}setDragStart(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.uiData.dragStart[0]=t,this.uiData.dragStart[1]=e}setDragEnd(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.uiData.dragEnd[0]=t,this.uiData.dragEnd[1]=e}touchMoveListener(t){if(this.uiData.touchdown&&t.touches.length<2){const e=this.canvas.getBoundingClientRect();if(this.uiData.isDragging||(this.uiData.pan2DxyzmmAtMouseDown=Tt(this.scene.pan2Dxyzmm)),this.uiData.isDragging=!0,this.uiData.doubleTouch&&this.uiData.isDragging){this.setDragEnd(t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,t.targetTouches[0].clientY-t.target.getBoundingClientRect().top),this.drawScene();return}const i=this.opts.dragModePrimary===0,s=this.opts.dragModePrimary===1;i?(this.mouseClick(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top),this.mouseMove(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top)):s&&(this.windowingHandler(t.touches[0].pageX,t.touches[0].pageY),this.drawScene())}else this.handlePinchZoom(t)}handlePinchZoom(t){if(t.targetTouches.length===2&&t.changedTouches.length===2){const e=Math.hypot(t.touches[0].pageX-t.touches[1].pageX,t.touches[0].pageY-t.touches[1].pageY),i=this.canvas.getBoundingClientRect();this.mousePos=[t.touches[0].clientX-i.left,t.touches[0].clientY-i.top],e<this.uiData.lastTwoTouchDistance?this.sliceScroll2D(-.01,t.touches[0].clientX-i.left,t.touches[0].clientY-i.top):this.sliceScroll2D(.01,t.touches[0].clientX-i.left,t.touches[0].clientY-i.top),this.uiData.lastTwoTouchDistance=e}}keyUpListener(t){if(t.code===this.opts.clipPlaneHotKey){const e=new Date().getTime();if(e-this.lastCalled>this.opts.keyDebounceTime){switch(this.currentClipPlaneIndex=(this.currentClipPlaneIndex+1)%7,this.currentClipPlaneIndex){case 0:this.scene.clipPlaneDepthAziElev=[2,0,0];break;case 1:this.scene.clipPlaneDepthAziElev=[0,270,0];break;case 2:this.scene.clipPlaneDepthAziElev=[0,90,0];break;case 3:this.scene.clipPlaneDepthAziElev=[0,0,0];break;case 4:this.scene.clipPlaneDepthAziElev=[0,180,0];break;case 5:this.scene.clipPlaneDepthAziElev=[0,0,-90];break;case 6:this.scene.clipPlaneDepthAziElev=[0,0,90];break}this.setClipPlane(this.scene.clipPlaneDepthAziElev)}this.lastCalled=e}else if(t.code===this.opts.viewModeHotKey){const e=new Date().getTime();e-this.lastCalled>this.opts.keyDebounceTime&&(this.setSliceType((this.opts.sliceType+1)%5),this.lastCalled=e)}}keyDownListener(t){t.code==="KeyH"&&this.opts.sliceType===4?this.setRenderAzimuthElevation(this.scene.renderAzimuth-1,this.scene.renderElevation):t.code==="KeyL"&&this.opts.sliceType===4?this.setRenderAzimuthElevation(this.scene.renderAzimuth+1,this.scene.renderElevation):t.code==="KeyJ"&&this.opts.sliceType===4?this.setRenderAzimuthElevation(this.scene.renderAzimuth,this.scene.renderElevation+1):t.code==="KeyK"&&this.opts.sliceType===4?this.setRenderAzimuthElevation(this.scene.renderAzimuth,this.scene.renderElevation-1):t.code==="KeyH"&&this.opts.sliceType!==4?this.moveCrosshairInVox(-1,0,0):t.code==="KeyL"&&this.opts.sliceType!==4?this.moveCrosshairInVox(1,0,0):t.code==="KeyU"&&this.opts.sliceType!==4&&t.ctrlKey?this.moveCrosshairInVox(0,0,1):t.code==="KeyD"&&this.opts.sliceType!==4&&t.ctrlKey?this.moveCrosshairInVox(0,0,-1):t.code==="KeyJ"&&this.opts.sliceType!==4?this.moveCrosshairInVox(0,-1,0):t.code==="KeyK"&&this.opts.sliceType!==4?this.moveCrosshairInVox(0,1,0):t.code==="KeyM"&&this.opts.sliceType!==4?(this.opts.dragMode++,this.opts.dragMode>=4&&(this.opts.dragMode=0),U.info("drag mode changed to ",hl[this.opts.dragMode])):t.code==="ArrowLeft"?this.setFrame4D(this.volumes[0].id,this.volumes[0].frame4D-1):t.code==="ArrowRight"?this.setFrame4D(this.volumes[0].id,this.volumes[0].frame4D+1):t.code==="Slash"&&t.shiftKey&&alert(`NIIVUE VERSION: ${va}`)}wheelListener(t){if(this.thumbnailVisible||this.opts.sliceMosaicString.length>0)return;t.preventDefault(),t.stopPropagation();const e=this.uiData.dragStart.reduce((l,c)=>l+c,0),i=this.uiData.dragEnd.reduce((l,c)=>l+c,0),s=e>0&&i>0;if(this.opts.dragMode===6&&s){const l=t.deltaY>0?1:-1;this.uiData.dragStart[0]<this.uiData.dragEnd[0]?(this.uiData.dragStart[0]-=l,this.uiData.dragEnd[0]+=l):(this.uiData.dragStart[0]+=l,this.uiData.dragEnd[0]-=l),this.uiData.dragStart[1]<this.uiData.dragEnd[1]?(this.uiData.dragStart[1]-=l,this.uiData.dragEnd[1]+=l):(this.uiData.dragStart[1]+=l,this.uiData.dragEnd[1]-=l),this.uiData.isDragging=!0,this.drawScene(),this.uiData.isDragging=!1;const c=this.tileIndex(this.uiData.dragStart[0],this.uiData.dragStart[1]);c>=0?this.generateMouseUpCallback(this.screenXY2TextureFrac(this.uiData.dragStart[0],this.uiData.dragStart[1],c),this.screenXY2TextureFrac(this.uiData.dragEnd[0],this.uiData.dragEnd[1],c)):U.warn("Could not generate drag release callback for ROI selection: Invalid tile index.");return}let r=t.deltaY<0?-.01:.01;if(this.opts.invertScrollDirection&&(r=-r),this.opts.clickToSegment){r<0?(this.opts.clickToSegmentPercent-=.01,this.opts.clickToSegmentPercent=Math.max(this.opts.clickToSegmentPercent,0)):(this.opts.clickToSegmentPercent+=.01,this.opts.clickToSegmentPercent=Math.min(this.opts.clickToSegmentPercent,1));const l=this.clickToSegmentXY[0],c=this.clickToSegmentXY[1],h=this.tileIndex(l,c);h>=0&&this.screenSlices[h].axCorSag<=2&&(U.debug(`Adjusting clickToSegment threshold: ${this.opts.clickToSegmentPercent.toFixed(3)}`),this.clickToSegmentIsGrowing=!0,this.doClickToSegment({x:l,y:c,tileIndex:h}));return}const n=this.canvas.getBoundingClientRect(),a=t.clientX-n.left,o=t.clientY-n.top;if(this.opts.dragMode===3&&this.inRenderTile(this.uiData.dpr*a,this.uiData.dpr*o)===-1){const l=r<0?1:-1;let c=this.scene.pan2Dxyzmm[3]*(1+10*(.01*l));c=Math.round(c*10)/10;const h=this.scene.pan2Dxyzmm[3]-c;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=c),this.scene.pan2Dxyzmm[3]=c;const d=this.frac2mm(this.scene.crosshairPos);this.scene.pan2Dxyzmm[0]+=h*d[0],this.scene.pan2Dxyzmm[1]+=h*d[1],this.scene.pan2Dxyzmm[2]+=h*d[2],this.drawScene(),this.canvas.focus(),this.sync();return}this.sliceScroll2D(r,a,o)}registerInteractions(){if(!this.canvas)throw new Error("canvas undefined");this.canvas.addEventListener("mousedown",this.mouseDownListener.bind(this)),this.canvas.addEventListener("mouseup",this.mouseUpListener.bind(this)),this.canvas.addEventListener("mousemove",this.mouseMoveListener.bind(this)),this.canvas.addEventListener("mouseleave",this.mouseLeaveListener.bind(this)),this.canvas.addEventListener("touchstart",this.touchStartListener.bind(this)),this.canvas.addEventListener("touchend",this.touchEndListener.bind(this)),this.canvas.addEventListener("touchmove",this.touchMoveListener.bind(this)),this.canvas.addEventListener("wheel",this.wheelListener.bind(this)),this.canvas.addEventListener("contextmenu",this.mouseContextMenuListener.bind(this)),this.canvas.addEventListener("dblclick",this.resetBriCon.bind(this)),this.canvas.addEventListener("dragenter",this.dragEnterListener.bind(this),!1),this.canvas.addEventListener("dragover",this.dragOverListener.bind(this),!1),this.canvas.addEventListener("drop",t=>{this.dropListener(t).catch(console.error)},!1),this.canvas.setAttribute("tabindex","0"),this.canvas.addEventListener("keyup",this.keyUpListener.bind(this),!1),this.canvas.addEventListener("keydown",this.keyDownListener.bind(this),!1)}dragEnterListener(t){t.stopPropagation(),t.preventDefault()}dragOverListener(t){t.stopPropagation(),t.preventDefault()}getFileExt(t,e=!0){U.debug("fullname: ",t);const i=/(?:\.([^.]+))?$/;let s=i.exec(t)[1];if(s=s.toUpperCase(),s==="GZ")s=i.exec(t.slice(0,-3))[1],s=s.toUpperCase();else if(s==="CBOR"){const r=s;s=i.exec(t.slice(0,-5))[1],s=s.toUpperCase(),s=`${s}.${r}`}return e?s:s.toLowerCase()}async addVolumeFromUrl(t){const e=await Ke.loadFromUrl(t);return this.document.addImageOptions(e,t),e.onColormapChange=this.onColormapChange,this.mediaUrlMap.set(e,t.url),this.onVolumeAddedFromUrl&&this.onVolumeAddedFromUrl(t,e),this.addVolume(e),e}async addVolumesFromUrl(t){const e=t.map(async s=>{const r=this.getFileExt(s.name||s.url);if(r==="DCM")throw new Error("DICOM files must be loaded using useDicomLoader");if(this.loaders[r]){let o=s.url;const l=this.loaders[r].toExt;let c=s.name||s.url;if(c=c.split("/").pop(),typeof s.url=="string"){const d=s.url;try{const f=await fetch(d);if(!f.ok)throw new Error(`Failed to load file: ${f.statusText}`);o=await f.arrayBuffer()}catch(f){throw new Error(`Failed to load url ${d}: ${f}`)}}const h=await this.loaders[r].loader(o);s.url=h,s.name=`${c}.${l}`}const n={url:s.url,headers:s.headers,name:s.name,colormap:s.colormap?s.colormap:s.colorMap,colormapNegative:s.colormapNegative?s.colormapNegative:s.colorMapNegative,opacity:s.opacity,urlImgData:s.urlImgData,cal_min:s.cal_min,cal_max:s.cal_max,trustCalMinMax:this.opts.trustCalMinMax,isManifest:s.isManifest,frame4D:s.frame4D,limitFrames4D:s.limitFrames4D||this.opts.limitFrames4D,colorbarVisible:s.colorbarVisible},a=await Ke.loadFromUrl(n);return this.document.addImageOptions(a,n),a.onColormapChange=this.onColormapChange,this.mediaUrlMap.set(a,n.url),this.onVolumeAddedFromUrl&&this.onVolumeAddedFromUrl(n,a),a}),i=await Promise.all(e);for(let s=0;s<i.length;s++)this.addVolume(i[s]);return i}getMediaByUrl(t){return[...this.mediaUrlMap.entries()].filter(e=>e[1]===t).map(e=>e[0]).pop()}removeVolumeByUrl(t){const e=this.getMediaByUrl(t);if(e)this.removeVolume(e);else throw new Error("No volume with URL present")}async traverseFileTree(t,e="",i){return new Promise(s=>{if(t.isFile)t.file(r=>{r.fullPath=e+r.name,r._webkitRelativePath=e+r.name,i.push(r),s(i)});else if(t.isDirectory){const r=t.createReader(),n=()=>{r.readEntries(a=>{if(a.length>0){const o=[];for(const l of a)o.push(this.traverseFileTree(l,e+t.name+"/",i));Promise.all(o).then(n).catch(l=>{throw l})}else s(i)})};n()}})}readDirectory(t){const e=t.createReader();let i=[];const s=async n=>{const a=[],o=async l=>new Promise((c,h)=>l.file(c,h));for(let l=0;l<n.length;l++)a.push(await o(n[l])),console.log(a);return a},r=()=>{e.readEntries(n=>{n.length?(i=i.concat(n),r()):s(i).then(async a=>{console.log(a)}).catch(a=>{throw a})})};return r(),i}isMeshExt(t){const e=this.getFileExt(t);return U.debug("dropped ext"),U.debug(e),Ot.includes(e)}async loadFromArrayBuffer(t,e){const i=this.getFileExt(e);if(Ot.includes(i)){await this.addMeshFromUrl({url:e,buffer:t});return}const s=Is(e);s.buffer=t,s.name=e,await this.addVolumeFromUrl(s)}async loadFromFile(t){const e=this.getFileExt(t.name);if(Ot.includes(e)){await li.loadFromFile({file:t,gl:this.gl,name:t.name}).then(i=>{this.addMesh(i)});return}await Ke.loadFromFile({file:t,name:t.name}).then(i=>{this.addVolume(i)})}useLoader(t,e,i){this.loaders={...this.loaders,[e.toUpperCase()]:{loader:t,toExt:i}}}useDicomLoader(t){this.dicomLoader=t}getDicomLoader(){return this.dicomLoader}async dropListener(t){if(t.stopPropagation(),t.preventDefault(),!this.opts.dragAndDropEnabled)return;const e=[],i=t.dataTransfer;if(!i)return;const s=i.getData("text/uri-list");if(s){const r=Is(s),n=this.getFileExt(s);U.debug("dropped ext"),U.debug(n),Ot.includes(n)?this.addMeshFromUrl({url:s}).catch(a=>{throw a}):n==="NVD"?this.loadDocumentFromUrl(s).catch(a=>{throw a}):this.addVolumeFromUrl(r).catch(a=>{throw a})}else{const r=i.items;if(r.length>0){!t.shiftKey&&!t.altKey&&(this.volumes=[],this.overlays=[],this.meshes=[]),this.closeDrawing();for(const n of Array.from(r)){const a=n.webkitGetAsEntry();if(U.debug(a),!a)throw new Error("could not get entry from file");if(a.isFile){const o=this.getFileExt(a.name);let l;if(a.name.lastIndexOf("HEAD")!==-1)for(const c of Array.from(r)){const h=c.webkitGetAsEntry();if(!h)throw new Error("could not get paired entry");const d=a.name.substring(0,a.name.lastIndexOf("HEAD")),f=h.name.substring(0,h.name.lastIndexOf("BRIK"));d===f&&(l=h)}if(a.name.lastIndexOf("BRIK")!==-1)continue;if(this.loaders[o]){const c=await Ld(a);await this.loadImages([{url:c,name:`${a.name}`}]);continue}if(Ot.includes(o)){a.file(c=>{(async()=>{try{const h=await li.loadFromFile({file:c,gl:this.gl,name:c.name});this.addMesh(h)}catch(h){console.error("Error loading mesh:",h)}})().catch(h=>console.error(h))});continue}else if(o==="NVD"){a.file(c=>{(async()=>{try{const h=await Dr.loadFromFile(c);await this.loadDocument(h),U.debug("loaded document")}catch(h){console.error(h)}})().catch(h=>console.error(h))});break}a.file(c=>{(async()=>{try{if(l)l.file(h=>{(async()=>{try{const d=await Ke.loadFromFile({file:c,urlImgData:h,limitFrames4D:this.opts.limitFrames4D});this.addVolume(d)}catch(d){console.error(d)}})().catch(console.error)});else{const h=await Ke.loadFromFile({file:c,urlImgData:l,limitFrames4D:this.opts.limitFrames4D});t.altKey?(U.debug("alt key detected: assuming this is a drawing overlay"),this.drawClearAllUndoBitmaps(),this.loadDrawing(h)):this.addVolume(h)}}catch(h){console.error(h)}})().catch(console.error)})}else a.isDirectory&&this.traverseFileTree(a,"",e).then(o=>{const l=this.getDicomLoader().loader;if(!l)throw new Error("No loader for DICOM files");l(o).then(async c=>{console.log(c);const h=c.map(d=>Ke.loadFromUrl({url:d.data,name:d.name,limitFrames4D:this.opts.limitFrames4D}));Promise.all(h).then(async d=>{console.log("from dicom loader"),console.log(d),await this.onDicomLoaderFinishedWithImages(d)}).catch(d=>{throw d})}).catch(c=>{console.error("Error loading DICOM files:",c)})}).catch(o=>{throw o})}}}this.drawScene()}setMultiplanarPadPixels(t){this.opts.multiplanarPadPixels=t,this.drawScene()}setMultiplanarLayout(t){typeof t=="string"&&(t=parseInt(t)),this.opts.multiplanarLayout=t,this.drawScene()}setCornerOrientationText(t){this.opts.isCornerOrientationText=t,this.updateGLVolume()}setIsOrientationTextVisible(t){this.opts.isOrientationTextVisible=t,this.drawScene()}setHeroImage(t){this.opts.heroImageFraction=t,this.drawScene()}setCustomLayout(t){for(let e=0;e<t.length;e++){const[i,s,r,n]=t[e].position,a=i+r,o=s+n;for(let l=e+1;l<t.length;l++){const[c,h,d,f]=t[l].position,u=c+d,m=h+f,g=i<u&&a>c,p=s<m&&o>h;if(g&&p)throw new Error(`Custom layout is invalid. Tile ${e} overlaps with tile ${l}.`)}}this.customLayout=t,this.drawScene()}clearCustomLayout(){this.customLayout=null,this.drawScene()}getCustomLayout(){return this.customLayout}setRadiologicalConvention(t){this.opts.isRadiologicalConvention=t,this.updateGLVolume()}setDefaults(t={},e=!1){this.document.opts={...yt},this.scene.sceneData={...Fi};for(const i in t)typeof t[i]=="function"?this[i]=t[i]:this.opts[i]=yt[i]===void 0?yt[i]:t[i];if(this.scene.pan2Dxyzmm=[0,0,0,1],e&&this.volumes&&this.volumes.length>0)for(let i=0;i<this.volumes.length;i++)this.volumes[i].cal_min=this.volumes[i].robust_min,this.volumes[i].cal_max=this.volumes[i].robust_max;this.updateGLVolume()}setMeshThicknessOn2D(t){this.opts.meshThicknessOn2D=t,this.updateGLVolume()}setSliceMosaicString(t){this.sliceMosaicString=t,this.updateGLVolume()}setSliceMM(t){this.opts.isSliceMM=t,this.updateGLVolume()}setAdditiveBlend(t){this.opts.isAdditiveBlend=t,this.updateGLVolume()}getRadiologicalConvention(){return this.opts.isRadiologicalConvention}setHighResolutionCapable(t){typeof t=="boolean"&&(t=t?0:-1),this.opts.forceDevicePixelRatio=t,this.resizeListener(),this.drawScene()}addVolume(t){this.volumes.push(t);const e=this.volumes.length===1?0:this.volumes.length-1;this.setVolume(t,e),this.onImageLoaded(t),U.debug("loaded volume",t.name),U.debug(t)}addMesh(t){this.meshes.push(t);const e=this.meshes.length===1?0:this.meshes.length-1;this.setMesh(t,e),this.onMeshLoaded(t)}getVolumeIndexByID(t){const e=this.volumes.length;for(let i=0;i<e;i++)if(this.volumes[i].id===t)return i;return-1}drawAddUndoBitmap(){if(!this.drawBitmap||this.drawBitmap.length<1){U.debug("drawAddUndoBitmap error: No drawing open");return}this.currentDrawUndoBitmap++,this.currentDrawUndoBitmap>=this.opts.maxDrawUndoBitmaps&&(this.currentDrawUndoBitmap=0),this.drawUndoBitmaps[this.currentDrawUndoBitmap]=Yd(this.drawBitmap)}drawClearAllUndoBitmaps(){if(this.currentDrawUndoBitmap=this.opts.maxDrawUndoBitmaps,!(!this.drawUndoBitmaps||this.drawUndoBitmaps.length<1))for(let t=this.drawUndoBitmaps.length-1;t>=0;t--)this.drawUndoBitmaps[t]=new Uint8Array}drawUndo(){if(this.drawUndoBitmaps.length<1){U.debug("undo bitmaps not loaded");return}if(this.currentDrawUndoBitmap--,this.currentDrawUndoBitmap<0&&(this.currentDrawUndoBitmap=this.drawUndoBitmaps.length-1),this.currentDrawUndoBitmap>=this.drawUndoBitmaps.length&&(this.currentDrawUndoBitmap=0),this.drawUndoBitmaps[this.currentDrawUndoBitmap].length<2){U.debug("drawUndo is misbehaving");return}this.drawBitmap=Pa(this.drawUndoBitmaps[this.currentDrawUndoBitmap],this.drawBitmap.length),this.refreshDrawing(!0)}loadDrawing(t){if(this.drawBitmap&&U.debug("Overwriting open drawing!"),!this.back)throw new Error("back undefined");this.drawClearAllUndoBitmaps();const e=t.hdr.dims;if(e[1]!==this.back.hdr.dims[1]||e[2]!==this.back.hdr.dims[2]||e[3]!==this.back.hdr.dims[3])return U.debug("drawing dimensions do not match background image"),!1;t.img.constructor!==Uint8Array&&U.debug("Drawings should be UINT8");const i=t.permRAS,s=e[1]*e[2]*e[3];this.drawBitmap=new Uint8Array(s),this.opts.is2DSliceShader?this.drawTexture=this.r8Tex2D(this.drawTexture,Ft,this.back.dims,!0):this.drawTexture=this.r8Tex(this.drawTexture,Ft,this.back.dims,!0);const r=[0,0,0];for(let m=0;m<3;m++)for(let g=0;g<3;g++)Math.abs(i[m])-1===g&&(r[g]=m*Math.sign(i[m]));let n=1;const a=[1,1,1],o=[!1,!1,!1];for(let m=0;m<r.length;m++)for(let g=0;g<r.length;g++)Math.abs(r[g])===m&&(a[g]=n,(r[g]<0||Object.is(r[g],-0))&&(o[g]=!0),n*=e[g+1]);let l=Z.range(0,e[1]-1,1);o[0]&&(l=Z.range(e[1]-1,0,-1));for(let m=0;m<e[1];m++)l[m]*=a[0];let c=Z.range(0,e[2]-1,1);o[1]&&(c=Z.range(e[2]-1,0,-1));for(let m=0;m<e[2];m++)c[m]*=a[1];let h=Z.range(0,e[3]-1,1);o[2]&&(h=Z.range(e[3]-1,0,-1));for(let m=0;m<e[3];m++)h[m]*=a[2];const d=t.img,f=this.drawBitmap;let u=0;for(let m=0;m<e[3];m++)for(let g=0;g<e[2];g++)for(let p=0;p<e[1];p++)f[l[p]+c[g]+h[m]]=d[u],u++;return this.drawAddUndoBitmap(),this.refreshDrawing(!1),this.drawScene(),!0}binarize(t){const e=t.hdr.dims,i=e[1]*e[2]*e[3],s=new Uint8Array(i);for(let r=0;r<i;r++)t.img[r]!==0&&(s[r]=1);t.img=s,t.hdr.datatypeCode=2,t.hdr.cal_min=0,t.hdr.cal_max=1}async loadDrawingFromUrl(t,e=!1){this.drawBitmap&&U.debug("Overwriting open drawing!"),this.drawClearAllUndoBitmaps();let i=!1;try{const s=await Ke.loadFromUrl(Is(t));e&&await this.binarize(s),i=this.loadDrawing(s)}catch{U.error("loadDrawingFromUrl() failed to load "+t),this.drawClearAllUndoBitmaps()}return i}findOtsu(t=2){if(this.volumes.length<1)return[];const e=this.volumes[0].img,i=e.length;if(i<1)return[];const s=256,r=s-1,n=new Array(s).fill(0),a=this.volumes[0].cal_min,o=this.volumes[0].cal_max;if(o<=a)return[];const l=(o-a)/s;function c(A){return A*l+a}const h=(s-1)/Math.abs(o-a),d=this.volumes[0].hdr.scl_inter,f=this.volumes[0].hdr.scl_slope;for(let A=0;A<i;A++){let w=e[A]*f+d;w=Math.min(Math.max(w,a),o),w=Math.round((w-a)*h),n[w]++}const u=Array(s).fill(0).map(()=>Array(s).fill(0)),m=Array(s).fill(0).map(()=>Array(s).fill(0));for(let A=1;A<s;++A)u[A][A]=n[A],m[A][A]=A*n[A];for(let A=1;A<s-1;++A)u[1][A+1]=u[1][A]+n[A+1],m[1][A+1]=m[1][A]+(A+1)*n[A+1];for(let A=2;A<s;A++)for(let w=A+1;w<s;w++)u[A][w]=u[1][w]-u[1][A-1],m[A][w]=m[1][w]-m[1][A-1];for(let A=1;A<s;++A)for(let w=A+1;w<s;w++)u[A][w]!==0&&(u[A][w]=m[A][w]*m[A][w]/u[A][w]);let g=0;const p=[1/0,1/0,1/0];if(t>3)for(let A=0;A<s-3;A++)for(let w=A+1;w<s-2;w++)for(let x=w+1;x<s-1;x++){const y=u[0][A]+u[A+1][w]+u[w+1][x]+u[x+1][r];y>g&&(p[0]=A,p[1]=w,p[2]=x,g=y)}else if(t===3)for(let A=0;A<s-2;A++)for(let w=A+1;w<s-1;w++){const x=u[0][A]+u[A+1][w]+u[w+1][r];x>g&&(p[0]=A,p[1]=w,g=x)}else for(let A=0;A<s-1;A++){const w=u[0][A]+u[A+1][r];w>g&&(p[0]=A,g=w)}return[c(p[0]),c(p[1]),c(p[2])]}drawOtsu(t=2){if(this.volumes.length===0)return;const e=this.volumes[0].img.length,i=this.findOtsu(t);if(i.length<3)return;this.drawBitmap||this.createEmptyDrawing();const s=this.drawBitmap,r=this.volumes[0].img;for(let n=0;n<e;n++){if(s[n]!==0)continue;const a=r[n];a>i[0]&&(s[n]=1),a>i[1]&&(s[n]=2),a>i[2]&&(s[n]=3)}this.drawAddUndoBitmap(),this.refreshDrawing(!0)}removeHaze(t=5,e=0){const i=this.volumes[e].img,s=this.volumes[e].hdr,r=i.length;let n=2;(t===5||t===1)&&(n=4),(t===4||t===2)&&(n=3);const a=this.findOtsu(n);if(a.length<3)return;let o=a[0];t===1&&(o=a[2]),t===2&&(o=a[1]);const l=s.scl_inter,c=s.scl_slope,h=this.volumes[e].global_min;for(let d=0;d<r;d++)i[d]*c+l<o&&(i[d]=h);this.refreshLayers(this.volumes[e],0),this.drawScene()}async saveImage(t=za){var a;const e={...za,...t},{filename:i,isSaveDrawing:s,volumeByIndex:r}=e;if(U.debug("saveImage",i,s,r),((a=this.back)==null?void 0:a.dims)===void 0)return U.debug("No voxelwise image open"),!1;if(s){if(!this.drawBitmap)return U.debug("No drawing open"),!1;const o=this.volumes[0].permRAS;if(o[0]===1&&o[1]===2&&o[2]===3)return U.debug("saving drawing"),await this.volumes[0].saveToDisk(i,this.drawBitmap);{U.debug("saving drawing");const l=this.volumes[0].hdr.dims,c=[0,0,0];for(let y=0;y<3;y++)for(let v=0;v<3;v++)Math.abs(o[y])-1===v&&(c[v]=y*Math.sign(o[y]));let h=1;const d=[1,1,1],f=[!1,!1,!1];for(let y=0;y<c.length;y++)for(let v=0;v<c.length;v++)Math.abs(c[v])===y&&(d[v]=h,(c[v]<0||Object.is(c[v],-0))&&(f[v]=!0),h*=l[v+1]);let u=Z.range(0,l[1]-1,1);f[0]&&(u=Z.range(l[1]-1,0,-1));for(let y=0;y<l[1];y++)u[y]*=d[0];let m=Z.range(0,l[2]-1,1);f[1]&&(m=Z.range(l[2]-1,0,-1));for(let y=0;y<l[2];y++)m[y]*=d[1];let g=Z.range(0,l[3]-1,1);f[2]&&(g=Z.range(l[3]-1,0,-1));for(let y=0;y<l[3];y++)g[y]*=d[2];const p=new Uint8Array(this.drawBitmap),A=new Uint8Array(l[1]*l[2]*l[3]);let w=0;for(let y=0;y<l[3];y++)for(let v=0;v<l[2];v++)for(let D=0;D<l[1];D++)A[w]=p[u[D]+m[v]+g[y]],w++;return U.debug("saving drawing"),this.volumes[0].saveToDisk(i,A)}}return U.debug("saving image"),this.volumes[r].saveToDisk(i)}getMeshIndexByID(t){if(typeof t=="number")return t>=this.meshes.length?-1:t;const e=this.meshes.length;for(let i=0;i<e;i++)if(this.meshes[i].id===t)return i;return-1}setMeshProperty(t,e,i){const s=this.getMeshIndexByID(t);if(s<0){U.warn("setMeshProperty() id not loaded",t);return}this.meshes[s].setProperty(e,i,this.gl),this.updateGLVolume(),this.onMeshPropertyChanged(s,e,i)}indexNearestXYZmm(t,e,i,s){const r=this.getMeshIndexByID(t);return r<0?(U.warn("indexNearestXYZmm() id not loaded",t),[NaN,NaN]):this.meshes[r].indexNearestXYZmm(e,i,s)}decimateHierarchicalMesh(t,e=3){const i=this.getMeshIndexByID(t);if(i<0){U.warn("reverseFaces() id not loaded",t);return}const s=this.meshes[i].decimateHierarchicalMesh(this.gl,e);return this.updateGLVolume(),s}reverseFaces(t){const e=this.getMeshIndexByID(t);if(e<0){U.warn("reverseFaces() id not loaded",t);return}this.meshes[e].reverseFaces(this.gl),this.updateGLVolume()}async setMeshLayerProperty(t,e,i,s){const r=this.getMeshIndexByID(t);if(r<0){U.warn("setMeshLayerProperty() id not loaded",t);return}await this.meshes[r].setLayerProperty(e,i,s,this.gl),this.updateGLVolume()}setPan2Dxyzmm(t){this.scene.pan2Dxyzmm=t,this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=t[3]),this.drawScene()}setRenderAzimuthElevation(t,e){this.scene.renderAzimuth=t,this.scene.renderElevation=e,this.onAzimuthElevationChange(t,e),this.drawScene()}getOverlayIndexByID(t){const e=this.overlays.length;for(let i=0;i<e;i++)if(this.overlays[i].id===t)return i;return-1}setVolume(t,e=0){const i=this.volumes.length;if(e>i)return;const s=this.getVolumeIndexByID(t.id);e===0?(this.volumes.splice(s,1),this.volumes.unshift(t),this.back=this.volumes[0],this.overlays=this.volumes.slice(1)):e<0?(this.volumes.splice(this.getVolumeIndexByID(t.id),1),this.back=this.volumes[0],this.volumes.length>1?this.overlays=this.volumes.slice(1):this.overlays=[]):(this.volumes.splice(s,1),this.volumes.splice(e,0,t),this.overlays=this.volumes.slice(1),this.back=this.volumes[0]),this.updateGLVolume()}setMesh(t,e=0){this.meshes.forEach(r=>{U.debug("MESH: ",r.name)});const i=this.meshes.length;if(e>i)return;const s=this.getMeshIndexByID(t.id);e===0?(this.meshes.splice(s,1),this.meshes.unshift(t)):e<0?this.meshes.splice(this.getMeshIndexByID(t.id),1):(this.meshes.splice(s,1),this.meshes.splice(e,0,t)),this.updateGLVolume(),this.meshes.forEach(r=>{U.debug(r.name)})}removeVolume(t){if(this.setVolume(t,-1),this.mediaUrlMap.has(t)){const e=this.mediaUrlMap.get(t);this.onVolumeWithUrlRemoved(e),this.mediaUrlMap.delete(t)}this.drawScene()}removeVolumeByIndex(t){if(t>=this.volumes.length)throw new Error("Index of volume out of bounds");this.removeVolume(this.volumes[t])}removeMesh(t){if(t.unloadMesh(this.gl),this.setMesh(t,-1),this.mediaUrlMap.has(t)){const e=this.mediaUrlMap.get(t);this.onMeshWithUrlRemoved(e),this.mediaUrlMap.delete(t)}}removeMeshByUrl(t){const e=this.getMediaByUrl(t);e&&(this.removeMesh(e),this.mediaUrlMap.delete(e),this.onMeshWithUrlRemoved(t))}moveVolumeToBottom(t){this.setVolume(t,0)}moveVolumeUp(t){const e=this.getVolumeIndexByID(t.id);this.setVolume(t,e+1)}moveVolumeDown(t){const e=this.getVolumeIndexByID(t.id);this.setVolume(t,e-1)}moveVolumeToTop(t){this.setVolume(t,this.volumes.length-1)}mouseDown(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.mousePos=[t,e]}mouseMove(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr;const i=(t-this.mousePos[0])/this.uiData.dpr,s=(e-this.mousePos[1])/this.uiData.dpr;this.mousePos=[t,e],!(this.inRenderTile(t,e)<0)&&(Math.abs(i)<1&&Math.abs(s)<1||(this.scene.renderAzimuth+=i,this.scene.renderElevation+=s,this.drawScene()))}sph2cartDeg(t,e){const i=-e*(Math.PI/180),s=(t-90)%360*(Math.PI/180),r=[Math.cos(i)*Math.cos(s),Math.cos(i)*Math.sin(s),Math.sin(i)],n=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);return n<=0||(r[0]/=n,r[1]/=n,r[2]/=n),r}setClipPlane(t){const e=this.sph2cartDeg(t[1]+180,t[2]);this.scene.clipPlane=[e[0],e[1],e[2],t[0]],this.scene.clipPlaneDepthAziElev=t,this.onClipPlaneChange(this.scene.clipPlane),this.drawScene()}setCrosshairColor(t){this.opts.crosshairColor=t,this.drawScene()}setCrosshairWidth(t){this.opts.crosshairWidth=t,this.crosshairs3D&&(this.crosshairs3D.mm[0]=NaN),this.drawScene()}setDrawColormap(t){this.drawLut=ce.makeDrawLut(t),this.updateGLVolume()}setDrawingEnabled(t){this.opts.drawingEnabled=t,this.opts.drawingEnabled?this.drawBitmap||this.createEmptyDrawing():(this.clickToSegmentIsGrowing&&(this.clickToSegmentIsGrowing=!1,this.refreshDrawing(!0,!1)),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawPenFillPts=[]),this.drawScene()}setPenValue(t,e=!1){this.opts.penValue=t,this.opts.isFilledPen=e,this.drawScene()}setDrawOpacity(t){this.drawOpacity=t,this.drawScene()}setSelectionBoxColor(t){this.opts.selectionBoxColor=t}sliceScroll2D(t,e,i,s=!0){if(this.opts.scrollRequiresFocus&&this.canvas!==document.activeElement){U.warn("Canvas element does not have focus. Scroll events will not be processed.");return}if(this.inGraphTile(e,i)){let r=this.volumes[0].frame4D;t>0&&r++,t<0&&r--,this.setFrame4D(this.volumes[0].id,r);return}if(t!==0&&this.opts.dragMode===3&&this.inRenderTile(this.uiData.dpr*e,this.uiData.dpr*i)===-1){let r=this.scene.pan2Dxyzmm[3]*(1+10*t);r=Math.round(r*10)/10;const n=this.scene.pan2Dxyzmm[3]-r;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=r),this.scene.pan2Dxyzmm[3]=r;const a=this.frac2mm(this.scene.crosshairPos);this.scene.pan2Dxyzmm[0]+=n*a[0],this.scene.pan2Dxyzmm[1]+=n*a[1],this.scene.pan2Dxyzmm[2]+=n*a[2],this.drawScene(),this.canvas.focus(),this.sync();return}this.mouseClick(e,i,t,s)}setSliceType(t){return this.opts.sliceType=t,this.drawScene(),this}setOpacity(t,e){this.volumes[t].opacity=e,this.updateGLVolume()}setScale(t){this.scene.volScaleMultiplier=t,this.drawScene()}setClipPlaneColor(t){this.opts.clipPlaneColor=t,this.renderShader.use(this.gl),this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor,this.opts.clipPlaneColor),this.drawScene()}setClipPlaneThick(t){this.opts.clipThick=t,this.renderShader.use(this.gl),this.gl.uniform1f(this.renderShader.uniforms.clipThick,this.opts.clipThick),this.drawScene()}setClipVolume(t,e){this.opts.clipVolumeLow=[Math.min(t[0],e[0]),Math.min(t[1],e[1]),Math.min(t[2],e[2])],this.opts.clipVolumeHigh=[Math.max(t[0],e[0]),Math.max(t[1],e[1]),Math.max(t[2],e[2])],this.renderShader.use(this.gl),this.gl.uniform3fv(this.renderShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.renderShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.pickingImageShader.use(this.gl),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.drawScene()}async setVolumeRenderIllumination(t=0){this.renderGradientValues=Number.isNaN(t),this.renderShader=this.renderVolumeShader,this.renderGradientValues?this.renderShader=this.renderGradientValuesShader:(this.opts.gradientAmount=t,t>0||this.opts.gradientOpacity>0?this.renderShader=this.renderGradientShader:t<0&&(this.renderShader=this.renderSliceShader)),this.initRenderShader(this.renderShader,t),this.renderShader.use(this.gl),this.setClipPlaneColor(this.opts.clipPlaneColor),Number.isNaN(t)?this.gradientTextureAmount=1:this.gradientTextureAmount=t,!(this.volumes.length<1)&&(this.refreshLayers(this.volumes[0],0),this.drawScene())}async setGradientOpacity(t=0,e=0){this.opts.gradientOpacity=t,this.opts.renderSilhouette=e,this.renderGradientValues?this.renderShader=this.renderGradientValuesShader:this.gradientTextureAmount>0||t>0?this.renderShader=this.renderGradientShader:this.gradientTextureAmount<0&&(this.renderShader=this.renderSliceShader),this.initRenderShader(this.renderShader,this.gradientTextureAmount),this.renderShader.use(this.gl),this.gradientTextureAmount>0&&this.refreshLayers(this.volumes[0],0),this.drawScene()}overlayRGBA(t){const e=t.hdr,i=e.dims[1]*e.dims[2]*e.dims[3],s=new Uint8ClampedArray(i*4),r=.2*Math.min(Math.min(e.dims[1],e.dims[2]),e.dims[3]),n=.5*e.dims[1],a=.5*e.dims[2],o=.5*e.dims[3];let l=0;for(let c=0;c<e.dims[3];c++)for(let h=0;h<e.dims[2];h++)for(let d=0;d<e.dims[1];d++){const f=Math.abs(d-n),u=Math.abs(h-a),m=Math.abs(c-o),g=Math.sqrt(f*f+u*u+m*m);let p=0;g<r&&(p=255),s[l++]=0,s[l++]=p,s[l++]=0,s[l++]=p*.5}return s}vox2mm(t,e){return Z.vox2mm(t,e)}cloneVolume(t){return this.volumes[t].clone()}async loadDocumentFromUrl(t){const e=await Dr.loadFromUrl(t);await this.loadDocument(e)}async loadDocument(t){this.volumes=[],this.meshes=[],this.document=t,this.document.labels=this.document.labels?this.document.labels:[];const e={...yt,...t.opts};this.scene.pan2Dxyzmm=t.scene.pan2Dxyzmm?t.scene.pan2Dxyzmm:[0,0,0,1],this.document.opts=e,this.setClipPlane(this.scene.clipPlaneDepthAziElev),U.debug("load document",t),this.mediaUrlMap.clear(),this.createEmptyDrawing();const i=t.encodedImageBlobs;for(let r=0;r<t.imageOptionsArray.length;r++){const n=t.imageOptionsArray[r],a=i[r];if(a){"colorMap"in n&&(n.colormap=n.colorMap);const o=await Ke.loadFromBase64({base64:a,...n});if(o){if(o.colormapLabel){const l=Object.keys(o.colormapLabel.lut).length,c=new Uint8ClampedArray(l);for(const h in o.colormapLabel.lut)c[h]=o.colormapLabel.lut[h];o.colormapLabel.lut=c}this.addVolume(o)}}}this.volumes.length>0&&(this.back=this.volumes[0]);for(const r of t.meshDataObjects??[]){const n={gl:this.gl,...r};r.offsetPt0&&(n.rgba255[3]=0,n.tris=new Uint32Array(r.offsetPt0)),U.debug(n);const a=new li(n.pts,n.tris,n.name,n.rgba255,n.opacity,n.visible,this.gl,n.connectome,n.dpg,n.dps,n.dpv);r.offsetPt0&&(a.fiberGroupColormap=r.fiberGroupColormap,a.fiberColor=r.fiberColor,a.fiberDither=r.fiberDither,a.fiberRadius=r.fiberRadius,a.colormap=r.colormap),a.meshShaderIndex=n.meshShaderIndex,a.layers=n.layers,a.updateMesh(this.gl),U.debug(a),this.addMesh(a)}if(t.data.connectomes)for(const r of t.data.connectomes){const n=JSON.parse(r),a=this.loadConnectomeAsMesh(n);a.updateMesh(this.gl),this.addMesh(a)}this.createEmptyDrawing();const s=t.encodedDrawingBlob;if(s){const r=await Z.b64toUint8(s);if(r){const n=this.back.dims;let a=n[1]*n[2]*n[3];if(r.length-352===a&&(a+=352),r.length!==a)throw new Error(`drawBitmap size does not match the texture dimensions (${n[1]}${n[2]}${n[3]}) ${a} != ${n[1]*n[2]*n[3]}.`);this.drawBitmap=r,this.refreshDrawing()}}return await this.setGradientOpacity(this.opts.gradientOpacity),await this.setVolumeRenderIllumination(this.opts.gradientAmount),this.updateGLVolume(),this.drawScene(),this.onDocumentLoaded(t),this}async generateLoadDocumentJavaScript(t,e){const i=this.json(),s=await Z.compressToBase64String(JSON.stringify(i));return`
        ${e}

        async function saveNiivueAsHtml(pageName) {
          //get new docstring
          const docString = nv1.json();
          const html =
          document.getElementsByTagName("html")[0]
              .innerHTML.replace(base64, await NVUtilities.compressToBase64String(JSON.stringify(docString)));
          NVUtilities.download(html, pageName, "application/html");
        }

        var nv1 = new Niivue();
        await nv1.attachTo("${t}");
        var base64 = "${s}";
        NVUtilities.decompressBase64String(base64).then((jsonText) => {
          var json = JSON.parse(jsonText); // string -> JSON
          var doc = NVDocument.loadFromJSON(json);
          nv1.loadDocument(doc);
          nv1.updateGLVolume();
        });

      `}async generateHTML(t="gl1",e){return`<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width,initial-scale=1.0" />
            <title>Save as HTML</title>
            <style>
            html {
              height: auto;
              min-height: 100%;
              margin: 0;
            }
            body {
              display: flex;
              flex-direction: column;
              margin: 0;
              min-height: 100%;
              width: 100%;
              position: absolute;
              font-family: system-ui, Arial, Helvetica, sans-serif;
              background: #ffffff;
              color: black;
              user-select: none; /* Standard syntax */
            }
            header {
              margin: 10px;
            }
            main {
              flex: 1;
              background: #000000;
              position: relative;
            }
            footer {
              margin: 10px;
            }
            canvas {
              position: absolute;
              cursor: crosshair;
            }
            canvas:focus {
              outline: 0px;
            }
            div {
              display: table-row;
              background-color: blue;
            }
            </style>
          </head>
          <body>
            <noscript>niivue requires JavaScript.</noscript>
            <header>
            Save the current scene as HTML
            <button id="save">Save as HTML</button>
            </header>
            <main>
              <canvas id="gl1"></canvas>
            </main>
            <script type="module" async>
              ${await this.generateLoadDocumentJavaScript(t,e)}
              function saveAsHtml() {
                saveNiivueAsHtml("page.html");
              }
              // assign our event handler
              var button = document.getElementById("save");
              button.onclick = saveAsHtml;
            <\/script>
          </body>
        </html>`}async saveHTML(t="untitled.html",e="gl1",i){const s=await this.generateHTML(e,i);return Z.download(s,t,"application/html")}json(){return this.document.opts=this.opts,this.document.scene=this.scene,this.document.volumes=this.volumes,this.document.meshes=this.meshes,this.drawScene(),this.document.previewImageDataURL=this.canvas.toDataURL(),this.document.json()}async saveDocument(t="untitled.nvd",e=!0,i={}){const{embedImages:s=!0,embedPreview:r=!0}=i;this.document.title=t,this.document.volumes=this.volumes,this.document.meshes=this.meshes,r?(this.drawScene(),this.document.previewImageDataURL=this.canvas.toDataURL()):this.document.previewImageDataURL="",await this.document.download(t,e,{embedImages:s})}async loadImages(t){const e=[],i=[];for(const s of t)if("url"in s){const r=this.getFileExt(s.name?s.name:s.url);if(this.loaders[r]){const n=this.loaders[r].toExt.toUpperCase();Ot.includes(n)?i.push(s):e.push(s);continue}Ot.includes(r.toUpperCase())?i.push(s):e.push(s)}return e.length>0&&await this.loadVolumes(e),i.length>0&&await this.loadMeshes(i),this}async loadDicoms(t){if(!this.getDicomLoader())throw new Error("No dicom loader set. Please set a dicom loader before loading dicoms");this.drawScene(),this.volumes=[],this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT);const e=t.map(async s=>{let r=null;if(s.isManifest)r=await Ke.fetchDicomData(s.url);else{const h=await fetch(s.url);if(!h.ok)throw new Error(`Failed to load file: ${h.statusText}`);const d=await h.arrayBuffer();r=[{name:s.url.split("/").pop(),data:d}]}const n=this.getDicomLoader().loader,a=await n(r);console.log(a);const o=a[0].name,l=a[0].data;return await Ke.loadFromUrl({url:l,name:o})}),i=await Promise.all(e);return i.length===1?this.addVolume(i[0]):this.onDicomLoaderFinishedWithImages(i),this}async loadVolumes(t){return this.drawScene(),this.thumbnailVisible?(this.deferredVolumes=t,this):(this.volumes=[],this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),await this.addVolumesFromUrl(t),this)}async addMeshFromUrl(t){const e=this.getFileExt(t.url);if(e==="JCON"||e==="JSON"){const r=await(await fetch(t.url,{})).json(),n=this.loadConnectomeAsMesh(r);return this.mediaUrlMap.set(n,t.url),this.onMeshAddedFromUrl(t,n),this.addMesh(n),n}const i=await li.loadFromUrl({...t,gl:this.gl});return this.mediaUrlMap.set(i,t.url),this.onMeshAddedFromUrl(t,i),this.addMesh(i),i}async addMeshesFromUrl(t){const e=t.map(async s=>{const r=this.getFileExt(s.name||s.url);if(this.loaders[r]){let a=s.url;const o=this.loaders[r].toExt;let l=s.name||s.url;if(l=l.split("/").pop(),typeof s.url=="string"){const u=s.url;try{const m=await fetch(u);if(!m.ok)throw new Error(`Failed to load file: ${m.statusText}`);a=await m.arrayBuffer()}catch(m){throw new Error(`Failed to load url ${u}: ${m}`)}}const{positions:c,indices:h,colors:d=null}=await this.loaders[r].loader(a);s.name=`${l}.${o}`;const f=await bt.createMZ3Async(c,h,!1,d);s.buffer=f}if(r==="JCON"||r==="JSON"){const o=await(await fetch(s.url,{})).json(),l=this.loadConnectomeAsMesh(o);return this.mediaUrlMap.set(l,s.url),this.onMeshAddedFromUrl(s,l),l}const n=await li.loadFromUrl({...s,gl:this.gl});return this.mediaUrlMap.set(n,s.url),this.onMeshAddedFromUrl(s,n),n}),i=await Promise.all(e);for(let s=0;s<i.length;s++)this.addMesh(i[s]);return i}async loadMeshes(t){return this.drawScene(),this.thumbnailVisible?(this.deferredMeshes=t,this):(this.initialized,this.meshes=[],this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),await this.addMeshesFromUrl(t),this.updateGLVolume(),this.drawScene(),this)}async loadConnectomeFromUrl(t,e={}){const s=await(await fetch(t,{headers:e})).json();return this.loadConnectome(s)}async loadFreeSurferConnectomeFromUrl(t,e={}){const s=await(await fetch(t,{headers:e})).json();return this.loadFreeSurferConnectome(s)}async loadFreeSurferConnectome(t){const e=ps.convertFreeSurferConnectome(t);return this.loadConnectome(e)}handleNodeAdded(t){const e=t.detail.node,i=[1,1,1,1];this.addLabel(e.name,{textColor:i,bulletScale:1,bulletColor:i,lineWidth:0,lineColor:i,lineTerminator:"none",textScale:1},[e.x,e.y,e.z]),this.drawScene()}loadConnectomeAsMesh(t){let e=t;if("data_type"in t&&t.data_type==="fs_pointset")e=ps.convertFreeSurferConnectome(t),U.warn("converted FreeSurfer connectome",e);else if("nodes"in t){const i=t.nodes;"names"in i&&"X"in i&&"Y"in i&&"Z"in i&&"Color"in i&&"Size"in i&&(e=ps.convertLegacyConnectome(t),U.warn("converted legacy connectome",e))}else throw new Error("not a known connectome format");return new ps(this.gl,e)}loadConnectome(t){this.drawScene(),this.meshes=[],this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT);const e=this.loadConnectomeAsMesh(t);return this.addMesh(e),this.drawScene(),this}createEmptyDrawing(){if(this.back===null||!this.back.dims||Math.min(Math.min(this.back.dims[1],this.back.dims[2]),this.back.dims[3])<1)return;const e=this.back.dims[1]*this.back.dims[2]*this.back.dims[3];this.drawBitmap=new Uint8Array(e),this.clickToSegmentGrowingBitmap=new Uint8Array(e),this.drawClearAllUndoBitmaps(),this.drawAddUndoBitmap(),this.opts.is2DSliceShader?this.drawTexture=this.r8Tex2D(this.drawTexture,Ft,this.back.dims):this.drawTexture=this.r8Tex(this.drawTexture,Ft,this.back.dims,!0),this.refreshDrawing(!1)}r16Tex(t,e,i,s){t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16I,i[1],i[2],i[3]);const r=i[1]*i[2]*i[3];return s.length!==r&&(s=new Int16Array(r)),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RED_INTEGER,this.gl.SHORT,s),t}drawGrowCut(){if(!this.back||!this.back.dims)throw new Error("back not defined");const t=this.back.hdr,e=this.gl,i=t.dims[1]*t.dims[2]*t.dims[3];if(!this.drawBitmap||this.drawBitmap.length!==i){U.debug("bitmap dims are wrong");return}const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.disable(e.CULL_FACE),e.viewport(0,0,this.back.dims[1],this.back.dims[2]),e.disable(e.BLEND);let r=Od(this.back);const n=this.r16Tex(null,Qd,this.back.dims,r);for(let y=1;y<i;y++)r[y]=this.drawBitmap[y];const a=this.r16Tex(null,Jd,this.back.dims,r),o=this.r16Tex(null,_d,this.back.dims,r),l=1e4;for(let y=1;y<i;y++)r[y]>0&&(r[y]=l);const c=this.r16Tex(null,Xd,this.back.dims,r),h=this.r16Tex(null,Zd,this.back.dims,r);e.bindVertexArray(this.genericVAO);const d=this.growCutShader;d.use(e);const f=128;e.uniform1i(d.uniforms.finalPass,0),e.uniform1i(d.uniforms.backTex,11);for(let y=0;y<f;y++){e.uniform1i(d.uniforms.labelTex,14),e.uniform1i(d.uniforms.strengthTex,12);for(let v=0;v<this.back.dims[3];v++){const D=1/this.back.dims[3]*(v+.5);e.uniform1f(d.uniforms.coordZ,D),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,o,0,v),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT1,h,0,v),e.drawBuffers([e.COLOR_ATTACHMENT0,e.COLOR_ATTACHMENT1]),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&U.error("Incomplete framebuffer"),e.drawArrays(e.TRIANGLE_STRIP,0,4)}y===f-1&&e.uniform1i(d.uniforms.finalPass,1),e.uniform1i(d.uniforms.labelTex,15),e.uniform1i(d.uniforms.strengthTex,13);for(let v=0;v<this.back.dims[3];v++){const D=1/this.back.dims[3]*(v+.5);e.uniform1f(d.uniforms.coordZ,D),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,a,0,v),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT1,c,0,v),e.drawBuffers([e.COLOR_ATTACHMENT0,e.COLOR_ATTACHMENT1]),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&U.error("Incomplete framebuffer"),e.drawArrays(e.TRIANGLE_STRIP,0,4)}}e.drawBuffers([e.COLOR_ATTACHMENT0]);const u=e.COLOR_ATTACHMENT1,m=a;e.readBuffer(u);const g=e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT),p=e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE);(g!==e.RED_INTEGER||p!==e.SHORT)&&U.debug("readPixels will fail."),r=new Int16Array;const A=this.back.dims[1]*this.back.dims[2],w=new Int16Array(A);for(let y=0;y<this.back.dims[3];y++)e.framebufferTextureLayer(e.FRAMEBUFFER,u,m,0,y),e.readPixels(0,0,this.back.dims[1],this.back.dims[2],g,p,w),r=Int16Array.from([...r,...w]);let x=r[0];for(let y=0;y<r.length;y++)x=Math.max(x,r[y]);for(let y=1;y<i;y++)this.drawBitmap[y]=r[y];e.deleteTexture(n),e.deleteTexture(c),e.deleteTexture(h),e.deleteTexture(a),e.deleteTexture(o),e.bindVertexArray(this.unusedVAO),e.viewport(0,0,e.canvas.width,e.canvas.height),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(s),this.drawAddUndoBitmap(),this.refreshDrawing(!0)}drawPt(t,e,i,s,r=null){var d;if(r===null&&(r=this.drawBitmap),!((d=this.back)!=null&&d.dims))throw new Error("back.dims not set");const n=this.back.dims[1],a=this.back.dims[2],o=this.back.dims[3];t=Math.min(Math.max(t,0),n-1),e=Math.min(Math.max(e,0),a-1),i=Math.min(Math.max(i,0),o-1),r[t+e*n+i*n*a]=s;const l=this.drawPenAxCorSag===0,c=this.drawPenAxCorSag===1,h=this.drawPenAxCorSag===2;if(this.opts.penSize>1){const f=Math.floor(this.opts.penSize/2);for(let u=-f;u<=f;u++)for(let m=-f;m<=f;m++)l?r[t+u+(e+m)*n+i*n*a]=s:c?r[t+u+e*n+(i+m)*n*a]=s:h&&(r[t+(e+m)*n+(i+u)*n*a]=s)}}drawPenLine(t,e,i){const s=Math.abs(t[0]-e[0]),r=Math.abs(t[1]-e[1]),n=Math.abs(t[2]-e[2]);let a=-1,o=-1,l=-1;e[0]>t[0]&&(a=1),e[1]>t[1]&&(o=1),e[2]>t[2]&&(l=1);let c=t[0],h=t[1],d=t[2];const f=e[0],u=e[1],m=e[2];if(s>=r&&s>=n){let g=2*r-s,p=2*n-s;for(;c!==f;)c+=a,g>=0&&(h+=o,g-=2*s),p>=0&&(d+=l,p-=2*s),g+=2*r,p+=2*n,this.drawPt(c,h,d,i)}else if(r>=s&&r>=n){let g=2*s-r,p=2*n-r;for(;h!==u;)h+=o,g>=0&&(c+=a,g-=2*r),p>=0&&(d+=l,p-=2*r),g+=2*s,p+=2*n,this.drawPt(c,h,d,i)}else{let g=2*r-n,p=2*s-n;for(;d!==m;)d+=l,g>=0&&(h+=o,g-=2*n),p>=0&&(c+=a,p-=2*n),g+=2*r,p+=2*s,this.drawPt(c,h,d,i)}}drawingBinaryDilationWithSeed(t,e=6){try{let i=function(p){return p[0]+p[1]*o+p[2]*l};const s=this.drawBitmap,r=this.back.dims[1],n=this.back.dims[2],a=this.back.dims[3],o=r,l=r*n,c=l*a,h=i(t);if(h<0||h>=c)throw new Error("Seed index is out of bounds.");const d=s[h];if(d===0)throw new Error("Seed voxel is not part of a filled cluster.");const f=s.slice();for(let p=0;p<c;p++)f[p]=f[p]===d?1:0;this.drawFloodFillCore(f,h,e);const u=s.slice(),m=[],g=[-l,l,-r,r,-1,1];m.push(...g),e>6&&m.push(-r-1,-r+1,r-1,r+1,-l-r,-l+r,-l-1,-l+1,l-r,l+r,l-1,l+1),e>18&&m.push(-l-r-1,-l-r+1,-l+r-1,-l+r+1,l-r-1,l-r+1,l+r-1,l+r+1);for(let p=0;p<c;p++)if(f[p]===2){const A=p%r,w=Math.floor(p%l/r),x=Math.floor(p/l);for(const y of m){const v=p+y;if(v<0||v>=c)continue;const D=v%r,b=Math.floor(v%l/r),C=Math.floor(v/l);Math.abs(D-A)>1||Math.abs(b-w)>1||Math.abs(C-x)>1||s[v]===0&&(u[v]=d)}}this.drawBitmap=u,this.drawAddUndoBitmap(),this.refreshDrawing(!0)}catch(i){U.error("Error in drawingBinaryDilationWithSeed:",i)}}drawFloodFillCore(t,e,i=6){var c;if(!((c=this.back)!=null&&c.dims))throw new Error("back.dims undefined");const s=[this.back.dims[1],this.back.dims[2],this.back.dims[3]],r=s[0],n=r*s[1];function a(h){return h[0]+h[1]*r+h[2]*n}function o(h){const d=Math.floor(h/n),f=Math.floor((h-d*n)/r);return[Math.floor(h%r),f,d]}const l=[];for(l.push(e),t[e]=2;l.length>0;){let h=function(u){const m=f.slice();if(m[0]+=u[0],m[1]+=u[1],m[2]+=u[2],m[0]<0||m[1]<0||m[2]<0||m[0]>=s[0]||m[1]>=s[1]||m[2]>=s[2])return;const g=a(m);t[g]===1&&(t[g]=2,l.push(g))};const d=l[0];l.shift();const f=o(d);h([0,0,-1]),h([0,0,1]),h([0,-1,0]),h([0,1,0]),h([-1,0,0]),h([1,0,0]),!(i<=6)&&(h([-1,-1,0]),h([1,1,0]),h([-1,1,0]),h([1,1,0]),h([0,-1,-1]),h([0,1,-1]),h([-1,0,-1]),h([1,0,-1]),h([0,-1,1]),h([0,1,1]),h([-1,0,1]),h([1,0,1]),!(i<=18)&&(h([-1,-1,-1]),h([1,-1,-1]),h([-1,1,-1]),h([1,1,-1]),h([-1,-1,1]),h([1,-1,1]),h([-1,1,1]),h([1,1,1])))}}drawFloodFill(t,e=0,i=0,s=NaN,r=NaN,n=6,a=Number.POSITIVE_INFINITY,o=!1,l=null,c=!1){var M;if(!this.drawBitmap&&(U.warn("drawFloodFill called without an initialized drawBitmap."),this.createEmptyDrawing(),!this.drawBitmap)){U.error("Failed to create drawing bitmap.");return}if(this.clickToSegmentIsGrowing&&!this.clickToSegmentGrowingBitmap){if(U.warn("drawFloodFill called in preview mode without initialized clickToSegmentGrowingBitmap."),this.drawBitmap)this.clickToSegmentGrowingBitmap=this.drawBitmap.slice();else{U.error("Cannot initialize growing bitmap as drawBitmap is null.");return}if(!this.clickToSegmentGrowingBitmap){U.error("Failed to create growing bitmap.");return}}if(l===null&&(l=this.drawBitmap),!l){U.error("drawFloodFill targetBitmap is null.");return}if(!((M=this.back)!=null&&M.dims))throw new Error("back.dims undefined");e=Math.abs(e);const h=[this.back.dims[1],this.back.dims[2],this.back.dims[3]];if(t[0]<0||t[1]<0||t[2]<0||t[0]>=h[0]||t[1]>=h[1]||t[2]>=h[2])return;const d=h[0],f=d*h[1],u=f*h[2],m=this.clickToSegmentIsGrowing?this.drawBitmap:l;if(!m){U.error("Could not determine original bitmap state.");return}const g=new Uint8Array(u).fill(0);let p=-1;o&&this.drawPenAxCorSag===0?p=2:o&&this.drawPenAxCorSag===1?p=1:o&&this.drawPenAxCorSag===2&&(p=0);function A(T){const S=Math.floor(T/f),E=Math.floor((T-S*f)/d);return[Math.floor(T%d),E,S]}function w(T){return T[0]+T[1]*d+T[2]*f}const x=T=>this.vox2mm(T,this.back.matRAS),y=x(t),v=a**2;function D(T){const S=A(T);if(p>=0&&S[p]!==t[p])return!1;const E=x(S);return(E[0]-y[0])**2+(E[1]-y[1])**2+(E[2]-y[2])**2<=v}const b=w(t),C=m[b];if(c&&C===0){U.debug("Grow/Erase Cluster tool requires starting on a masked voxel."),this.clickToSegmentIsGrowing&&this.clickToSegmentGrowingBitmap&&this.drawBitmap&&(this.clickToSegmentGrowingBitmap.set(this.drawBitmap),this.refreshDrawing(!0,!0));return}if(i===0&&C===e&&!c&&e!==0&&(U.debug("drawFloodFill selected voxel is already desired color"),!this.clickToSegmentIsGrowing))return;let I=NaN;if(c&&(i===Number.POSITIVE_INFINITY||i===Number.NEGATIVE_INFINITY)){const T=m.slice();for(let R=0;R<u;R++)T[R]=T[R]===C&&D(R)?1:0;if(T[b]!==1){U.error("Seed voxel could not be marked for cluster ID.");return}this.drawFloodFillCore(T,b,n);const S=this.volumes[0].img2RAS();let E=0,B=0;for(let R=0;R<u;R++)T[R]===2&&(E+=S[R],B++);I=B>0?E/B:S[b],U.debug(`Grow Cluster using mean intensity: ${I.toFixed(2)} from ${B} voxels.`);let P=-1/0,V=1/0;i===Number.POSITIVE_INFINITY&&(P=I),i===Number.NEGATIVE_INFINITY&&(V=I);for(let R=0;R<u;R++)if(T[R]===2)g[R]=1;else if(m[R]===0){const k=S[R];k>=P&&k<=V&&D(R)&&(g[R]=1)}e=C}else if(i===0)if(c&&e===0){U.debug(`Erase Cluster: Identifying cluster with color ${C}`);for(let T=0;T<u;T++)g[T]=m[T]===C&&D(T)?1:0}else for(let T=0;T<u;T++)m[T]===C&&D(T)&&C!==0&&(g[T]=1);else{const T=this.volumes[0].img2RAS();I=T[b];let S=-1/0,E=1/0;isFinite(s)&&isFinite(r)?(S=s,E=r):i===Number.POSITIVE_INFINITY?S=I:i===Number.NEGATIVE_INFINITY&&(E=I);for(let B=0;B<u;B++){const P=T[B];P>=S&&P<=E&&D(B)&&(g[B]=1)}e=m[b],e===0&&(e=this.opts.penValue,(e<1||!isFinite(e))&&(e=1))}if(g[b]!==1){let T=!1;if(c&&i!==0?C!==0&&(T=!0):(C!==0||e===0)&&(T=!0),T&&D(b))g[b]=1,U.debug("Forcing seed voxel to 1 in working buffer.");else{U.debug("Seed voxel not marked as candidate '1' and not valid originally."),this.clickToSegmentIsGrowing&&this.clickToSegmentGrowingBitmap&&this.drawBitmap&&this.clickToSegmentGrowingBitmap.set(this.drawBitmap);return}}this.drawFloodFillCore(g,b,n);for(let T=0;T<u;T++)g[T]===2?l[T]=e:this.clickToSegmentIsGrowing&&l===this.clickToSegmentGrowingBitmap&&(l[T]=m[T]);this.clickToSegmentIsGrowing?this.refreshDrawing(!0,!0):(this.drawAddUndoBitmap(),this.refreshDrawing(!0,!1))}drawPenFilled(){var A;const t=this.drawPenFillPts.length;if(t<2){this.drawPenFillPts=[];return}const e=this.drawPenAxCorSag;let i=0,s=1;if(e===1&&(s=2),e===2&&(i=1,s=2),!((A=this.back)!=null&&A.dims))throw new Error("back.dims undefined");const r=[this.back.dims[i+1],this.back.dims[s+1]],n=new Uint8Array(r[0]*r[1]);let a=1;function o(w,x){const y=Math.abs(w[0]-x[0]),v=Math.abs(w[1]-x[1]);n[w[0]+w[1]*r[0]]=a,n[x[0]+x[1]*r[0]]=a;let D=-1,b=-1;x[0]>w[0]&&(D=1),x[1]>w[1]&&(b=1);let C=w[0],I=w[1];const M=x[0],T=x[1];if(y>=v){let S=2*v-y;for(;C!==M;)C+=D,S>=0&&(I+=b,S-=2*y),S+=2*v,n[C+I*r[0]]=a}else{let S=2*y-v;for(;I!==T;)I+=b,S>=0&&(C+=D,S-=2*v),S+=2*y,n[C+I*r[0]]=a}}function l(w){const x=Math.min(Math.max(w[0],0),r[0]-1),y=Math.min(Math.max(w[1],0),r[1]-1);return[x,y]}const c=l([this.drawPenFillPts[0][i],this.drawPenFillPts[0][s]]);let h=[...c],d=[...c],f=c;for(let w=1;w<t;w++){let x=[this.drawPenFillPts[w][i],this.drawPenFillPts[w][s]];x=l(x),h=[Math.min(x[0],h[0]),Math.min(x[1],h[1])],d=[Math.max(x[0],d[0]),Math.max(x[1],d[1])],o(f,x),f=x}o(c,f);const u=1;h[0]=Math.max(0,h[0]-u),h[1]=Math.max(0,h[1]-u),d[0]=Math.min(r[0]-1,d[0]+u),d[1]=Math.min(r[1]-1,d[1]+u);for(let w=0;w<r[1];w++)for(let x=0;x<r[0];x++){if(x>=h[0]&&x<d[0]&&w>=h[1]&&w<=d[1])continue;const y=x+w*r[0];n[y]===0&&(n[y]=2)}const m=[];function g(w){if(w[0]<h[0]||w[1]<h[1]||w[0]>d[0]||w[1]>d[1])return;const x=w[0]+w[1]*r[0];n[x]===0&&(m.push(w),n[x]=2)}for(let w=h[0];w<=d[0];w++)g([w,h[1]]),g([w,d[1]]);for(let w=h[1]+1;w<=d[1]-1;w++)g([h[0],w]),g([d[0],w]);for(;m.length>0;){const w=m.shift();g([w[0]-1,w[1]]),g([w[0]+1,w[1]]),g([w[0],w[1]-1]),g([w[0],w[1]+1])}a=this.opts.penValue;const p=this.drawPenFillPts[0][3-(i+s)];if(!this.drawBitmap)throw new Error("drawBitmap undefined");if(e===0){const w=p*r[0]*r[1];for(let x=0;x<r[0]*r[1];x++)n[x]!==2&&(this.drawBitmap[x+w]=a)}else{let w=1;const x=this.back.dims[1]*this.back.dims[2];let y=p*this.back.dims[1];e===2&&(w=this.back.dims[1],y=p);let v=0;for(let D=0;D<r[1];D++)for(let b=0;b<r[0];b++)n[v]!==2&&(this.drawBitmap[b*w+D*x+y]=a),v++}if(!this.drawFillOverwrites&&this.drawUndoBitmaps[this.currentDrawUndoBitmap].length>0){const w=this.drawBitmap.length,x=Pa(this.drawUndoBitmaps[this.currentDrawUndoBitmap],w);for(let y=0;y<w;y++)x[y]!==0&&(this.drawBitmap[y]=x[y])}this.drawPenFillPts=[],this.drawAddUndoBitmap(),this.refreshDrawing(!1)}closeDrawing(){this.drawClearAllUndoBitmaps(),this.rgbaTex(this.drawTexture,Ft,[2,2,2,2],!0),this.drawBitmap=null,this.clickToSegmentGrowingBitmap=null,this.drawScene()}refreshDrawing(t=!0,e=!1){var a;e&&(!this.opts.drawingEnabled||!this.opts.clickToSegment)&&(U.debug("refreshDrawing: Conditions not met for clickToSegment bitmap, using drawBitmap."),e=!1);const i=e?this.clickToSegmentGrowingBitmap:this.drawBitmap;!i&&!e&&this.clickToSegmentGrowingBitmap?U.warn("refreshDrawing: drawBitmap is null, but clickToSegmentGrowingBitmap exists. Check state."):!i&&e&&this.drawBitmap?(U.warn("refreshDrawing: clickToSegmentGrowingBitmap is null, falling back to drawBitmap."),e=!1):i||U.warn("refreshDrawing: Both bitmaps are null. Uploading empty data.");const s=e?this.clickToSegmentGrowingBitmap:this.drawBitmap;if(!((a=this.back)!=null&&a.dims)){U.warn("refreshDrawing: back.dims undefined, cannot refresh drawing texture yet.");return}const r=this.back.dims.slice(),n=this.back.dims[1]*this.back.dims[2]*this.back.dims[3];if(!s){U.warn(`refreshDrawing: Bitmap data source (${e?"growing":"main"}) is null. Cannot update texture.`),t&&this.drawScene();return}if(s.length===8?(r[1]=2,r[2]=2,r[3]=2):n!==s.length&&U.warn(`Drawing bitmap length (${s.length}) must match the background image (${n})`),this.gl.activeTexture(Ft),this.opts.is2DSliceShader){const o=this.frac2vox(this.scene.crosshairPos),l=Math.min(Math.max(o[2],0),r[3]-1),c=r[1]*r[2],h=l*c;U.debug(`refresh huge 2D drawing xyz ${r[1]}${r[2]}${r[3]} slice ${h}`);const d=s.subarray(h,h+c);this.gl.bindTexture(this.gl.TEXTURE_2D,this.drawTexture),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,r[1],r[2],this.gl.RED,this.gl.UNSIGNED_BYTE,d)}else this.gl.bindTexture(this.gl.TEXTURE_3D,this.drawTexture),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,r[1],r[2],r[3],this.gl.RED,this.gl.UNSIGNED_BYTE,s);if(!this.drawTexture){U.error("refreshDrawing: drawTexture (GPU texture) is null.");return}t&&this.drawScene()}r8Tex2D(t,e,i,s=!1){if(t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.R8,i[1],i[2]),s){const r=new Uint8Array(i[1]*i[2]);this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,i[1],i[2],this.gl.RED,this.gl.UNSIGNED_BYTE,r)}return t}r8Tex(t,e,i,s=!1){if(t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R8,i[1],i[2],i[3]),s){const r=new Uint8Array(i[1]*i[2]*i[3]);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RED,this.gl.UNSIGNED_BYTE,r)}return t}rgbaTex2D(t,e,i,s=null,r=!0){if(t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.RGBA8,i[1],i[2]),s){let n=s;const a=i[1],o=i[2];if(r){n=new Uint8Array(s.length);const l=a*4;for(let c=0;c<o;c++){const h=c*l,d=(o-1-c)*l;n.set(s.subarray(h,h+l),d)}}this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,a,o,this.gl.RGBA,this.gl.UNSIGNED_BYTE,n)}return t}rgbaTex(t,e,i,s=!1){if(t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA8,i[1],i[2],i[3]),s){const r=new Uint8Array(i[1]*i[2]*i[3]*4);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RGBA,this.gl.UNSIGNED_BYTE,r)}return t}rgba16Tex(t,e,i,s=!1){if(t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,2),this.gl.pixelStorei(this.gl.PACK_ALIGNMENT,2),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA16UI,i[1],i[2],i[3]),s){const r=new Uint16Array(i[1]*i[2]*i[3]*4);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RGBA_INTEGER,this.gl.UNSIGNED_SHORT,r)}return t}requestCORSIfNotSameOrigin(t,e){new URL(e,window.location.href).origin!==window.location.origin&&(t.crossOrigin="")}async loadPngAsTexture(t,e){return new Promise((i,s)=>{const r=new Image;r.onload=()=>{if(!this.bmpShader)return;let n;e===4?(this.bmpTexture!==null&&this.gl.deleteTexture(this.bmpTexture),this.bmpTexture=this.gl.createTexture(),n=this.bmpTexture,this.bmpTextureWH=r.width/r.height,this.gl.activeTexture(Hd),this.bmpShader.use(this.gl),this.gl.uniform1i(this.bmpShader.uniforms.bmpTexture,4)):e===5?(this.gl.activeTexture(Na),this.matCapTexture!==null&&this.gl.deleteTexture(this.matCapTexture),this.matCapTexture=this.gl.createTexture(),n=this.matCapTexture):(this.fontShader.use(this.gl),this.gl.activeTexture(jd),this.gl.uniform1i(this.fontShader.uniforms.fontTexture,3),this.fontTexture!==null&&this.gl.deleteTexture(this.fontTexture),this.fontTexture=this.gl.createTexture(),n=this.fontTexture),this.gl.bindTexture(this.gl.TEXTURE_2D,n),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),i(n),e!==4&&this.drawScene()},r.onerror=s,this.requestCORSIfNotSameOrigin(r,t),r.src=t})}async loadFontTexture(t){return this.loadPngAsTexture(t,3)}async loadBmpTexture(t){return this.loadPngAsTexture(t,4)}async loadMatCapTexture(t){return this.loadPngAsTexture(t,5)}initFontMets(){if(!this.fontMetrics)throw new Error("fontMetrics undefined");this.fontMets={distanceRange:this.fontMetrics.atlas.distanceRange,size:this.fontMetrics.atlas.size,mets:{}};for(let i=0;i<256;i++)this.fontMets.mets[i]={xadv:0,uv_lbwh:[0,0,0,0],lbwh:[0,0,0,0]};const t=this.fontMetrics.atlas.width,e=this.fontMetrics.atlas.height;for(let i=0;i<this.fontMetrics.glyphs.length;i++){const s=this.fontMetrics.glyphs[i],r=s.unicode;if(this.fontMets.mets[r].xadv=s.advance,s.planeBounds===void 0)continue;let n=s.atlasBounds.left/t,a=(e-s.atlasBounds.top)/e,o=(s.atlasBounds.right-s.atlasBounds.left)/t,l=(s.atlasBounds.top-s.atlasBounds.bottom)/e;this.fontMets.mets[r].uv_lbwh=[n,a,o,l],n=s.planeBounds.left,a=s.planeBounds.bottom,o=s.planeBounds.right-s.planeBounds.left,l=s.planeBounds.top-s.planeBounds.bottom,this.fontMets.mets[r].lbwh=[n,a,o,l]}}async loadFont(t=Ma,e=Ia){await this.loadFontTexture(t);const i=await fetch(e);if(!i.ok)throw Error(i.statusText);const s=await i.text();this.fontMetrics=JSON.parse(s),this.initFontMets(),this.fontShader.use(this.gl),this.drawScene()}async loadDefaultMatCap(){return this.loadMatCapTexture(Nd)}async loadDefaultFont(){await this.loadFontTexture(this.DEFAULT_FONT_GLYPH_SHEET),this.fontMetrics=this.DEFAULT_FONT_METRICS,this.initFontMets()}async initText(){this.fontShader=new ne(this.gl,y0,v0),this.fontShader.use(this.gl),await this.loadDefaultFont(),await this.loadDefaultMatCap(),this.drawLoadingText(this.opts.loadingText)}meshShaderNameToNumber(t="Phong"){const e=t.toLowerCase();for(let i=0;i<this.meshShaders.length;i++)if(this.meshShaders[i].Name.toLowerCase()===e)return i}setMeshShader(t,e=2){let i=0;if(typeof e=="number"?i=e:i=this.meshShaderNameToNumber(e),i===void 0)throw new Error("shaderIndex undefined");i=Math.min(i,this.meshShaders.length-1),i=Math.max(i,0);const s=this.getMeshIndexByID(t);if(s>=this.meshes.length){U.debug("Unable to change shader until mesh is loaded (maybe you need async)");return}this.meshes[s].meshShaderIndex=i,this.updateGLVolume(),this.onMeshShaderChanged(s,i)}createCustomMeshShader(t,e="Custom"){if(!t)throw new Error("Need fragment shader");const i=this.meshShaderNameToNumber(e);i>=0&&(this.gl.deleteProgram(this.meshShaders[i].shader.program),this.meshShaders.splice(i,1));const s=new ne(this.gl,Sr,t);return s.use(this.gl),{Name:e,Frag:t,shader:s}}setCustomMeshShader(t="",e="Custom"){const i=this.createCustomMeshShader(t,e);return this.meshShaders.push(i),this.onCustomMeshShaderAdded(t,e),this.meshShaders.length-1}meshShaderNames(t=!0){const e=[];for(let i=0;i<this.meshShaders.length;i++)e.push(this.meshShaders[i].Name);return t===!0?e.sort():e}initRenderShader(t,e=0){t.use(this.gl),this.gl.uniform1i(t.uniforms.volume,0),this.gl.uniform1i(t.uniforms.colormap,1),this.gl.uniform1i(t.uniforms.overlay,2),this.gl.uniform1i(t.uniforms.drawing,7),this.gl.uniform1fv(t.uniforms.renderDrawAmbientOcclusion,[this.renderDrawAmbientOcclusion,1]),this.gl.uniform1f(t.uniforms.gradientAmount,e),this.gl.uniform1f(t.uniforms.silhouettePower,this.opts.renderSilhouette);const i=new Float32Array(Ds);for(let s=0;s<Ds;s++)this.opts.gradientOpacity===0?i[s]=1:i[s]=Math.pow(s/(Ds-1),this.opts.gradientOpacity*8);this.gl.uniform1fv(this.gl.getUniformLocation(t.program,"gradientOpacity"),i)}async init(){const t=this.gl.getExtension("WEBGL_debug_renderer_info");if(t){const n=this.gl.getParameter(t.UNMASKED_VENDOR_WEBGL),a=this.gl.getParameter(t.UNMASKED_RENDERER_WEBGL);U.info("renderer vendor: ",n),U.info("renderer: ",a)}else U.info("debug_renderer_info unavailable");const e=this.gl.getParameter(this.gl.RENDERER);U.info("firefox renderer: ",e),this.gl.clearDepth(0),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.FRONT),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.volumeTexture=this.rgbaTex(this.volumeTexture,si,[2,2,2,2],!0),this.overlayTexture=this.rgbaTex(this.overlayTexture,Ir,[2,2,2,2],!0),this.drawTexture=this.r8Tex(this.drawTexture,Ft,[2,2,2,2],!0);const i=[1,1,0,1,0,0,0,1,0,0,0,0],s=this.gl;this.cuboidVertexBuffer=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,this.cuboidVertexBuffer),s.bufferData(s.ARRAY_BUFFER,new Float32Array(i),s.STATIC_DRAW),this.genericVAO=s.createVertexArray(),s.bindVertexArray(this.genericVAO),s.bindBuffer(s.ARRAY_BUFFER,this.cuboidVertexBuffer),s.enableVertexAttribArray(0),s.vertexAttribPointer(0,3,s.FLOAT,!1,0,0),s.bindVertexArray(this.unusedVAO),this.pickingMeshShader=new ne(s,Sr,U0),this.pickingMeshShader.use(s),this.pickingImageShader=new ne(s,yi,q0),this.pickingImageShader.use(s),s.uniform1i(this.pickingImageShader.uniforms.volume,0),s.uniform1i(this.pickingImageShader.uniforms.colormap,1),s.uniform1i(this.pickingImageShader.uniforms.overlay,2),s.uniform1i(this.pickingImageShader.uniforms.drawing,7),this.slice2DShader=new ne(s,yr,h0),this.slice2DShader.use(s),s.uniform1i(this.slice2DShader.uniforms.volume,0),s.uniform1i(this.slice2DShader.uniforms.colormap,1),s.uniform1i(this.slice2DShader.uniforms.overlay,2),s.uniform1i(this.slice2DShader.uniforms.drawing,7),s.uniform1f(this.slice2DShader.uniforms.drawOpacity,this.drawOpacity),this.sliceMMShader=new ne(s,yr,f0),this.sliceMMShader.use(s),s.uniform1i(this.sliceMMShader.uniforms.volume,0),s.uniform1i(this.sliceMMShader.uniforms.colormap,1),s.uniform1i(this.sliceMMShader.uniforms.overlay,2),s.uniform1i(this.sliceMMShader.uniforms.drawing,7),s.uniform1f(this.sliceMMShader.uniforms.drawOpacity,this.drawOpacity),this.sliceV1Shader=new ne(s,yr,d0),this.sliceV1Shader.use(s),s.uniform1i(this.sliceV1Shader.uniforms.volume,0),s.uniform1i(this.sliceV1Shader.uniforms.colormap,1),s.uniform1i(this.sliceV1Shader.uniforms.overlay,2),s.uniform1i(this.sliceV1Shader.uniforms.drawing,7),s.uniform1f(this.sliceV1Shader.uniforms.drawOpacity,this.drawOpacity),this.orientCubeShader=new ne(s,Q0,X0),this.orientCubeShaderVAO=s.createVertexArray(),s.bindVertexArray(this.orientCubeShaderVAO);const r=s.createBuffer();s.enableVertexAttribArray(0),s.enableVertexAttribArray(1),s.bindBuffer(s.ARRAY_BUFFER,r),s.bufferData(s.ARRAY_BUFFER,sf,s.STATIC_DRAW),s.vertexAttribPointer(0,3,s.FLOAT,!1,24,0),s.enableVertexAttribArray(1),s.vertexAttribPointer(1,3,s.FLOAT,!1,24,12),s.bindVertexArray(this.unusedVAO),this.rectShader=new ne(s,ba,vr),this.rectShader.use(s),this.rectOutlineShader=new ne(s,ba,u0),this.rectOutlineShader.use(s),this.lineShader=new ne(s,p0,vr),this.lineShader.use(s),this.line3DShader=new ne(s,A0,vr),this.line3DShader.use(s),this.circleShader=new ne(s,b0,C0),this.circleShader.use(s),this.renderVolumeShader=new ne(s,yi,o0),this.initRenderShader(this.renderVolumeShader),this.renderSliceShader=new ne(s,yi,a0),this.initRenderShader(this.renderSliceShader),this.renderGradientShader=new ne(s,yi,l0),this.initRenderShader(this.renderGradientShader,.3),s.uniform1i(this.renderGradientShader.uniforms.matCap,5),s.uniform1i(this.renderGradientShader.uniforms.gradient,6),this.renderGradientValuesShader=new ne(s,yi,c0),this.initRenderShader(this.renderGradientValuesShader),s.uniform1i(this.renderGradientValuesShader.uniforms.matCap,5),s.uniform1i(this.renderGradientValuesShader.uniforms.gradient,6),this.renderShader=this.renderVolumeShader,this.colorbarShader=new ne(s,m0,g0),this.colorbarShader.use(s),s.uniform1i(this.colorbarShader.uniforms.colormap,1),this.blurShader=new ne(s,ms,_0),this.sobelBlurShader=new ne(s,ms,$0),this.sobelFirstOrderShader=new ne(s,ms,ef),this.sobelSecondOrderShader=new ne(s,ms,tf),this.growCutShader=new ne(s,D0,T0),this.passThroughShader=new ne(s,Z0,J0),this.orientShaderAtlasU=new ne(s,ii,br.concat(Sa)),this.orientShaderAtlasI=new ne(s,ii,Ca.concat(Sa)),this.orientShaderU=new ne(s,ii,br.concat(Cr)),this.orientShaderI=new ne(s,ii,Ca.concat(Cr)),this.orientShaderF=new ne(s,ii,S0.concat(Cr)),this.orientShaderRGBU=new ne(s,ii,br.concat(E0)),this.surfaceShader=new ne(s,M0,I0),this.surfaceShader.use(s),this.fiberShader=new ne(s,F0,B0),this.pickingImageShader.use(s);for(let n=0;n<this.meshShaders.length;n++){const a=this.meshShaders[n];a.Name==="Flat"?a.shader=new ne(s,H0,Ea):a.shader=new ne(s,Sr,a.Frag),a.shader.use(s),a.shader.isMatcap=a.Name==="Matcap",a.shader.isMatcap&&s.uniform1i(a.shader.uniforms.matCap,5)}return this.bmpShader=new ne(s,w0,x0),await this.initText(),this.opts.thumbnail.length>0&&(await this.loadBmpTexture(this.opts.thumbnail),this.thumbnailVisible=!0),this.updateGLVolume(),this.initialized=!0,this.resizeListener(),this.drawScene(),this}gradientGL(t){const e=this.gl,i=[0,0,0,0,1,0,1,0,0,1,1,0],s=e.createVertexArray();e.bindVertexArray(s);const r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,new Float32Array(i),e.STATIC_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,3,e.FLOAT,!1,0,0);const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.disable(e.CULL_FACE),e.viewport(0,0,t.dims[1],t.dims[2]),e.disable(e.BLEND);const a=this.rgbaTex(null,La,t.dims,!0),o=this.opts.gradientOrder===2?this.sobelBlurShader:this.blurShader;o.use(e),e.activeTexture(si),e.bindTexture(e.TEXTURE_3D,this.volumeTexture);const l=.7;e.uniform1i(o.uniforms.intensityVol,0),e.uniform1f(o.uniforms.dX,l/t.dims[1]),e.uniform1f(o.uniforms.dY,l/t.dims[2]),e.uniform1f(o.uniforms.dZ,l/t.dims[3]),e.bindVertexArray(s);for(let d=0;d<t.dims[3]-1;d++){const f=1/t.dims[3]*(d+.5);e.uniform1f(o.uniforms.coordZ,f),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,a,0,d);const u=e.checkFramebufferStatus(e.FRAMEBUFFER);u!==e.FRAMEBUFFER_COMPLETE&&U.error("framebuffer status: ",u),e.clear(e.DEPTH_BUFFER_BIT),e.drawArrays(e.TRIANGLE_STRIP,0,i.length/3)}const c=this.opts.gradientOrder===2?this.sobelSecondOrderShader:this.sobelFirstOrderShader;c.use(e),e.activeTexture(La),e.bindTexture(e.TEXTURE_3D,a),e.uniform1i(c.uniforms.intensityVol,8);const h=.7;e.uniform1f(c.uniforms.dX,h/t.dims[1]),e.uniform1f(c.uniforms.dY,h/t.dims[2]),e.uniform1f(c.uniforms.dZ,h/t.dims[3]),this.opts.gradientOrder===2&&(e.uniform1f(c.uniforms.dX2,2*h/t.dims[1]),e.uniform1f(c.uniforms.dY2,2*h/t.dims[2]),e.uniform1f(c.uniforms.dZ2,2*h/t.dims[3])),e.uniform1f(c.uniforms.coordZ,.5),e.bindVertexArray(s),this.gradientTexture!==null&&e.deleteTexture(this.gradientTexture),this.gradientTexture=this.rgbaTex(this.gradientTexture,ka,t.dims);for(let d=0;d<t.dims[3]-1;d++){const f=1/t.dims[3]*(d+.5);e.uniform1f(c.uniforms.coordZ,f),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,this.gradientTexture,0,d);const u=e.checkFramebufferStatus(e.FRAMEBUFFER);u!==e.FRAMEBUFFER_COMPLETE&&U.error("framebuffer status: ",u),e.clear(e.DEPTH_BUFFER_BIT),e.drawArrays(e.TRIANGLE_STRIP,0,i.length/3)}e.deleteFramebuffer(n),e.deleteTexture(a),e.deleteBuffer(r),e.bindFramebuffer(e.FRAMEBUFFER,null)}updateGLVolume(){var i;let t=0;const e=this.volumes.length;this.refreshColormaps();for(let s=0;s<e;s++)this.volumes[s].toRAS&&(this.refreshLayers(this.volumes[s],t),t++);if(this.furthestVertexFromOrigin=0,e>0&&(this.furthestVertexFromOrigin=((i=this.volumeObject3D)==null?void 0:i.furthestVertexFromOrigin)??0),this.meshes)for(let s=0;s<this.meshes.length;s++)this.furthestVertexFromOrigin=Math.max(this.furthestVertexFromOrigin,this.meshes[s].furthestVertexFromOrigin);this.onVolumeUpdated&&this.onVolumeUpdated(),this.drawScene()}getDescriptives(t){const{layer:e=0,masks:i=[],drawingIsMask:s=!1,roiIsMask:r=!1,startVox:n=[0,0,0],endVox:a=[0,0,0]}=t;let o=null;const l=this.volumes[e].hdr,c=this.volumes[e].pixDimsRAS;let h=l.scl_slope;isNaN(h)&&(h=1);let d=l.scl_inter;isNaN(d)&&(d=1);const f=this.volumes[e].img,u=f.length,m=new Float32Array(u);for(let S=0;S<u;S++)m[S]=f[S]*h+d;const g=new Uint8Array(u);for(let S=0;S<u;S++)g[S]=1;if(i.length>0)for(let S=0;S<i.length;S++){const E=this.volumes[i[S]].img;if(E.length!==u){U.debug("Mask resolution does not match image. Skipping masking layer "+i[S]);continue}for(let B=0;B<u;B++)(E[B]===0||isNaN(E[B]))&&(g[B]=0)}else if(i.length<1&&s)for(let S=0;S<u;S++)(this.drawBitmap[S]===0||isNaN(this.drawBitmap[S]))&&(g[S]=0);else if(i.length<1&&r){g.fill(0);let S=-1;if(n[0]===a[0])S=0;else if(n[1]===a[1])S=1;else if(n[2]===a[2])S=2;else{console.error("Error: No constant dimension found.");return}const B=[0,1,2].filter(ke=>ke!==S),P=[];P[S]=n[S],P[B[0]]=(n[B[0]]+a[B[0]])/2,P[B[1]]=(n[B[1]]+a[B[1]])/2;const V=Math.abs(a[B[0]]-n[B[0]])/2,R=Math.abs(a[B[1]]-n[B[1]])/2,k=l.dims[1],z=l.dims[2],W=Math.max(0,Math.floor(P[B[0]]-V)),j=Math.min(l.dims[B[0]+1]-1,Math.ceil(P[B[0]]+V)),Q=Math.max(0,Math.floor(P[B[1]]-R)),pe=Math.min(l.dims[B[1]+1]-1,Math.ceil(P[B[1]]+R)),Ce=P[S];if(Ce<0||Ce>=l.dims[S+1]){console.error("Error: Constant dimension value is out of bounds.");return}for(let ke=W;ke<=j;ke++)for(let Le=Q;Le<=pe;Le++){const ve=[];ve[S]=Ce,ve[B[0]]=ke,ve[B[1]]=Le;const Ai=(ve[B[0]]-P[B[0]])/V,Jn=(ve[B[1]]-P[B[1]])/R;if(Ai*Ai+Jn*Jn<=1){const hc=ve[0],fc=ve[1],dc=ve[2]*k*z+fc*k+hc;g[dc]=1}}const Me=c[B[0]+1]*c[B[1]+1];o=g.reduce((ke,Le)=>ke+(Le===1?1:0),0)*Me;const tt=V*c[B[0]+1],at=R*c[B[1]+1];o=Math.PI*tt*at}let p=0,A=0,w=0,x=Number.NEGATIVE_INFINITY,y=Number.POSITIVE_INFINITY,v=0,D=0,b=0;for(let S=0;S<u;S++){if(g[S]<1)continue;const E=m[S];p++;let B=A+(E-A)/p;w=w+(E-A)*(E-B),A=B,E!==0&&(v++,B=D+(E-D)/v,b=b+(E-D)*(E-B),D=B,y=Math.min(E,x),x=Math.max(E,x))}const C=Math.sqrt(w/(p-1)),I=Math.sqrt(b/(v-1)),M=y,T=x;return p!==v&&(y=Math.min(0,x),x=Math.max(0,x)),{mean:A,stdev:C,nvox:p,volumeMM3:p*l.pixDims[1]*l.pixDims[2]*l.pixDims[3],volumeML:p*l.pixDims[1]*l.pixDims[2]*l.pixDims[3]*.001,min:y,max:x,meanNot0:D,stdevNot0:I,nvoxNot0:v,minNot0:M,maxNot0:T,cal_min:this.volumes[e].cal_min,cal_max:this.volumes[e].cal_max,robust_min:this.volumes[e].robust_min,robust_max:this.volumes[e].robust_max,area:o}}refreshLayers(t,e){var D;if(this.volumes.length<1)return;this.refreshColormaps();const i=t.hdr;let s=t.img;t.frame4D>0&&t.frame4D<t.nFrame4D&&(s=t.img.slice(t.frame4D*t.nVox3D,(t.frame4D+1)*t.nVox3D));const r=t.opacity;if(e>1&&r===0)return;let n=null;if(!this.back)throw new Error("back undefined");this.gl.bindVertexArray(this.unusedVAO),this.crosshairs3D&&(this.crosshairs3D.mm[0]=NaN);let a=be(t.toRAS);if(e===0){this.volumeObject3D=kd(t,this.VOLUME_ID,this.gl),Je(a,a),this.back.matRAS=t.matRAS,this.back.dims=t.dimsRAS,this.back.pixDims=t.pixDimsRAS;const{volScale:b,vox:C}=this.sliceScale(!0);this.volScale=b,this.vox=C,this.volumeObject3D.scale=b,(i.dims[1]>this.uiData.max2D||i.dims[2]>this.uiData.max2D)&&U.error("Image dimensions exceed maximum texture size of hardware.");const M=i.dims[1]>this.uiData.max3D||i.dims[2]>this.uiData.max3D||i.dims[3]>this.uiData.max3D;if(M&&i.datatypeCode===2304&&i.dims[3]<2){U.info(`Large RGBA image (>${this.uiData.max3D}) requires Texture2D`),this.opts.is2DSliceShader=!0,n=this.rgbaTex2D(this.volumeTexture,si,t.dimsRAS,s);return}if(M){U.info(`Large scalar image (>${this.uiData.max3D}) requires Texture2D (${i.dims[1]}${i.dims[2]}${i.dims[3]})`);const S=i.dims[1]*i.dims[2],E=this.frac2vox(this.scene.crosshairPos),P=Math.min(Math.max(E[2],0),i.dims[3]-1)*S,V=new Uint8Array(S*4),R=new Uint32Array(V.buffer),k=Math.floor(t.opacity*255),z=255*i.scl_slope/(t.cal_max-t.cal_min),W=255*(i.scl_inter-t.cal_min)/(t.cal_max-t.cal_min),j=new Uint8Array(this.colormap(t.colormap)),Q=new Uint32Array(j.buffer);let pe=-1;for(let Ce=0;Ce<S;Ce++){const Me=s[Ce+P]*z+W,Qe=Math.round(Math.min(255,Math.max(0,Me)));R[Ce]=Q[Qe],V[pe+=4]=k}this.opts.is2DSliceShader=!0,n=this.rgbaTex2D(this.volumeTexture,si,t.dimsRAS,V,!1);return}if(M&&U.warn(`dimensions exceed 3D limits ${i.dims}`),this.opts.is2DSliceShader=!1,n=this.rgbaTex(this.volumeTexture,si,t.dimsRAS),!this.renderShader)throw new Error("renderShader undefined");this.renderShader.use(this.gl),this.gl.uniform3fv(this.renderShader.uniforms.texVox,C),this.gl.uniform3fv(this.renderShader.uniforms.volScale,b);const T=this.pickingImageShader;T.use(this.gl),this.gl.uniform1i(T.uniforms.volume,0),this.gl.uniform1i(T.uniforms.colormap,1),this.gl.uniform1i(T.uniforms.overlay,2),this.gl.uniform3fv(T.uniforms.volScale,b),U.debug(this.volumeObject3D)}else{((D=this.back)==null?void 0:D.dims)===void 0&&U.error("Fatal error: Unable to render overlay: background dimensions not defined!");const b=this.mm2frac(t.mm000,0,!0);let C=this.mm2frac(t.mm100,0,!0),I=this.mm2frac(t.mm010,0,!0),M=this.mm2frac(t.mm001,0,!0);C=de(C,C,b),I=de(I,I,b),M=de(M,M,b),a=nt(C[0],I[0],M[0],b[0],C[1],I[1],M[1],b[1],C[2],I[2],M[2],b[2],0,0,0,1),Je(a,a),e===1?(n=this.rgbaTex(this.overlayTexture,Ir,this.back.dims),this.overlayTexture=n,this.overlayTextureID=n):n=this.overlayTextureID}const o=this.gl.createFramebuffer();this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,o),this.gl.disable(this.gl.CULL_FACE),this.gl.viewport(0,0,this.back.dims[1],this.back.dims[2]),this.gl.disable(this.gl.BLEND);const l=this.gl.createTexture();this.gl.activeTexture(qd),this.gl.bindTexture(this.gl.TEXTURE_3D,l),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1);let c=this.orientShaderU;if(!i)throw new Error("hdr undefined");if(!s)throw new Error("img undefined");if(i.datatypeCode===2)i.intent_code===1002&&(c=this.orientShaderAtlasU),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.UNSIGNED_BYTE,s);else if(i.datatypeCode===4)c=this.orientShaderI,i.intent_code===1002&&(c=this.orientShaderAtlasI),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16I,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.SHORT,s);else if(i.datatypeCode===16)this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R32F,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.FLOAT,s),c=this.orientShaderF;else if(i.datatypeCode===64){let b=new Float32Array;b=Float32Array.from(s),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R32F,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.FLOAT,b),c=this.orientShaderF}else i.datatypeCode===128?(c=this.orientShaderRGBU,c.use(this.gl),this.gl.uniform1i(c.uniforms.hasAlpha,0),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGB8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RGB_INTEGER,this.gl.UNSIGNED_BYTE,s)):i.datatypeCode===512?(i.intent_code===1002&&(c=this.orientShaderAtlasU),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.UNSIGNED_SHORT,s)):i.datatypeCode===2304&&(c=this.orientShaderRGBU,c.use(this.gl),this.gl.uniform1i(c.uniforms.hasAlpha,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RGBA_INTEGER,this.gl.UNSIGNED_BYTE,s));t.global_min===void 0&&t.calMinMax();let h=null;if(this.gl.bindVertexArray(this.genericVAO),e>1){if(!this.back.dims)throw new Error("back.dims undefined");h=this.rgbaTex(h,Oa,this.back.dims),this.gl.bindTexture(this.gl.TEXTURE_3D,h);const b=this.passThroughShader;b.use(this.gl),this.gl.uniform1i(b.uniforms.in3D,2);for(let C=0;C<this.back.dims[3];C++){const I=1/this.back.dims[3]*(C+.5);this.gl.uniform1f(b.uniforms.coordZ,I),this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,h,0,C),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}}else h=this.rgbaTex(h,Oa,[2,2,2,2]);c.use(this.gl),this.gl.activeTexture(As);let d=null;if(t.colormapLabel!==null&&t.colormapLabel.lut.length>7){const b=t.colormapLabel.max-t.colormapLabel.min+1;d=this.createColormapTexture(d,1,b),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,b,1,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.colormapLabel.lut),this.gl.uniform1f(c.uniforms.cal_min,t.colormapLabel.min-.5),this.gl.uniform1f(c.uniforms.cal_max,t.colormapLabel.max+.5),this.gl.bindTexture(this.gl.TEXTURE_2D,d)}else this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture),this.gl.uniform1f(c.uniforms.cal_min,t.cal_min),this.gl.uniform1f(c.uniforms.cal_max,t.cal_max);"alphaThreshold"in t&&(U.warn("alphaThreshold is deprecated: use colormapType"),t.alphaThreshold===!0&&(t.colormapType=2),t.alphaThreshold===!1&&(t.colormapType=1),delete t.alphaThreshold);const f=t.colormapType!==0?1:0,u=t.colormapType===2?1:0;this.gl.uniform1i(c.uniforms.isAlphaThreshold,u),this.gl.uniform1i(c.uniforms.isColorbarFromZero,f),this.gl.uniform1i(c.uniforms.isAdditiveBlend,this.opts.isAdditiveBlend?1:0);let m=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY;if(t.colormapNegative.length>0&&(m=Math.min(-t.cal_min,-t.cal_max),g=Math.max(-t.cal_min,-t.cal_max),isFinite(t.cal_minNeg)&&isFinite(t.cal_maxNeg)&&(m=Math.min(t.cal_minNeg,t.cal_maxNeg),g=Math.max(t.cal_minNeg,t.cal_maxNeg))),e>0&&this.overlayOutlineWidth>0){const b=t.cal_min,C=t.cal_max;let I=Math.min(b,C)<=0&&Math.max(b,C)>=0;!I&&m<g&&(I=m<=0&&g>=0),I&&U.error("issue1139: do not use overlayOutlineWidth when thresholds cross or touch zero")}if(!c)throw new Error("orientShader undefined");this.gl.uniform1f(c.uniforms.layer??null,e),this.gl.uniform1f(c.uniforms.cal_minNeg??null,m),this.gl.uniform1f(c.uniforms.cal_maxNeg??null,g),this.gl.bindTexture(this.gl.TEXTURE_3D,l),this.gl.uniform1i(c.uniforms.intensityVol??null,9),this.gl.uniform1i(c.uniforms.blend3D??null,10),this.gl.uniform1i(c.uniforms.colormap??null,1),this.gl.uniform1f(c.uniforms.scl_inter??null,i.scl_inter),this.gl.uniform1f(c.uniforms.scl_slope??null,i.scl_slope),this.gl.uniform1f(c.uniforms.opacity??null,r),this.gl.uniform1i(c.uniforms.modulationVol??null,7);let p=null;if(t.modulationImage!==null&&t.modulationImage>=0&&t.modulationImage<this.volumes.length){U.debug("modulating",this.volumes);const b=this.volumes[t.modulationImage].hdr;if(b.dims[1]===i.dims[1]&&b.dims[2]===i.dims[2]&&b.dims[3]===i.dims[3]){t.modulateAlpha?(this.gl.uniform1i(c.uniforms.modulation,2),this.gl.uniform1f(c.uniforms.opacity,1)):this.gl.uniform1i(c.uniforms.modulation,1),p=this.r8Tex(p,this.gl.TEXTURE7,i.dims,!0),this.gl.activeTexture(this.gl.TEXTURE7),this.gl.bindTexture(this.gl.TEXTURE_3D,p);const C=i.dims[1]*i.dims[2]*i.dims[3],I=new Uint8Array(C),M=this.volumes[t.modulationImage].cal_min,T=1/(this.volumes[t.modulationImage].cal_max-M),S=this.volumes[t.modulationImage].img.buffer;let E=new Uint8Array(S);switch(b.datatypeCode){case 4:E=new Int16Array(S);break;case 16:E=new Float32Array(S);break;case 64:E=new Float64Array(S);break;case 128:E=new Uint8Array(S);break;case 512:E=new Uint16Array(S);break}U.debug(this.volumes[t.modulationImage]);const B=this.volumes[t.modulationImage].colormapNegative.length>0;let P=this.volumes[t.modulationImage].cal_min,V=this.volumes[t.modulationImage].cal_max;isFinite(this.volumes[t.modulationImage].cal_minNeg)&&isFinite(this.volumes[t.modulationImage].cal_maxNeg)&&(P=this.volumes[t.modulationImage].cal_minNeg,V=this.volumes[t.modulationImage].cal_minNeg),P=Math.abs(P),V=Math.abs(V),P>V&&([P,V]=[V,P]);const R=1/(V-P);let k=Math.abs(t.modulateAlpha);k=Math.max(k,1);const z=this.volumes[t.modulationImage].frame4D*C;for(let W=0;W<C;W++){const j=E[W+z]*b.scl_slope+b.scl_inter;let Q=(j-M)*T;B&&j<0&&(Q=(Math.abs(j)-P)*R),Q=Math.min(Math.max(Q,0),1),Q=Math.pow(Q,k)*255,I[W]=Q}this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.UNSIGNED_BYTE,I)}else U.debug("Modulation image dimensions do not match target")}else this.gl.uniform1i(c.uniforms.modulation,0);if(this.gl.uniformMatrix4fv(c.uniforms.mtx,!1,a),!this.back.dims)throw new Error("back.dims undefined");let A=0;i.intent_code===1002&&(A=this.opts.atlasOutline),this.gl.uniform4fv(c.uniforms.xyzaFrac,[1/this.back.dims[1],1/this.back.dims[2],1/this.back.dims[3],A]),U.debug("back dims: ",this.back.dims);for(let b=0;b<this.back.dims[3];b++){const C=1/this.back.dims[3]*(b+.5);this.gl.uniform1f(c.uniforms.coordZ,C),this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,n,0,b),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}if(this.gl.bindVertexArray(this.unusedVAO),this.gl.deleteTexture(l),this.gl.deleteTexture(p),this.gl.deleteTexture(h),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.deleteFramebuffer(o),e===0&&(this.volumeTexture=n,this.gradientTextureAmount>0?this.gradientGL(i):(this.gradientTexture!==null&&this.gl.deleteTexture(this.gradientTexture),this.gradientTexture=null)),!this.renderShader)throw new Error("renderShader undefined");this.renderShader.use(this.gl);const w=this.sliceScale(!0),x=w.vox,y=w.volScale;if(this.gl.uniform1f(this.renderShader.uniforms.overlays,this.overlays),this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor,this.opts.clipPlaneColor),this.gl.uniform1f(this.renderShader.uniforms.clipThick,this.opts.clipThick),this.gl.uniform3fv(this.renderShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.renderShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.gl.uniform1f(this.renderShader.uniforms.backOpacity,this.volumes[0].opacity),this.gl.uniform1f(this.renderShader.uniforms.renderOverlayBlend,this.opts.renderOverlayBlend),this.gl.uniform4fv(this.renderShader.uniforms.clipPlane,this.scene.clipPlane),this.gl.uniform3fv(this.renderShader.uniforms.texVox,x),this.gl.uniform3fv(this.renderShader.uniforms.volScale,y),!this.pickingImageShader)throw new Error("pickingImageShader undefined");this.pickingImageShader.use(this.gl),this.gl.uniform1f(this.pickingImageShader.uniforms.overlays,this.overlays.length),this.gl.uniform3fv(this.pickingImageShader.uniforms.texVox,x),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi,this.opts.clipVolumeHigh);let v=this.sliceMMShader;if(this.opts.is2DSliceShader&&(v=this.slice2DShader),this.opts.isV1SliceShader&&(v=this.sliceV1Shader),!v)throw new Error("slice shader undefined");v.use(this.gl),this.gl.uniform1f(v.uniforms.overlays,this.overlays.length),this.gl.uniform1f(v.uniforms.drawOpacity,this.drawOpacity),d!==null&&(this.gl.deleteTexture(d),this.gl.activeTexture(As),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture)),this.gl.uniform1i(v.uniforms.drawing,7),this.gl.activeTexture(Ft),this.opts.is2DSliceShader?this.gl.bindTexture(this.gl.TEXTURE_2D,this.drawTexture):this.gl.bindTexture(this.gl.TEXTURE_3D,this.drawTexture),this.updateInterpolation(e)}colormaps(){return ce.colormaps()}addColormap(t,e){ce.addColormap(t,e)}setColormap(t,e){const i=this.getVolumeIndexByID(t);this.volumes[i].colormap=e,this.updateGLVolume()}idx(t,e,i,s){return i*s[0]*s[1]+e*s[0]+t}check_previous_slice(t,e,i,s,r,n,a,o){const l=new Uint32Array(27);let c=0;if(!r)return 0;const h=t[this.idx(i,s,r,n)];if(a>=6){const d=this.idx(i,s,r-1,n);h===t[d]&&(l[c++]=e[d])}if(a>=18){if(i){const d=this.idx(i-1,s,r-1,n);h===t[d]&&(l[c++]=e[d])}if(s){const d=this.idx(i,s-1,r-1,n);h===t[d]&&(l[c++]=e[d])}if(i<n[0]-1){const d=this.idx(i+1,s,r-1,n);h===t[d]&&(l[c++]=e[d])}if(s<n[1]-1){const d=this.idx(i,s+1,r-1,n);h===t[d]&&(l[c++]=e[d])}}if(a===26){if(i&&s){const d=this.idx(i-1,s-1,r-1,n);h===t[d]&&(l[c++]=e[d])}if(i<n[0]-1&&s){const d=this.idx(i+1,s-1,r-1,n);h===t[d]&&(l[c++]=e[d])}if(i&&s<n[1]-1){const d=this.idx(i-1,s+1,r-1,n);h===t[d]&&(l[c++]=e[d])}if(i<n[0]-1&&s<n[1]-1){const d=this.idx(i+1,s+1,r-1,n);h===t[d]&&(l[c++]=e[d])}}return c?(this.fill_tratab(o,l,c),l[0]):0}do_initial_labelling(t,e,i){let s=1;const r=8192;let n=r,a=new Uint32Array(n).fill(0);const o=new Uint32Array(e[0]*e[1]*e[2]).fill(0),l=new Uint32Array(27);for(let c=0;c<e[2];c++)for(let h=0;h<e[1];h++)for(let d=0;d<e[0];d++){let f=0;const u=t[this.idx(d,h,c,e)];if(u!==0){if(l[0]=this.check_previous_slice(t,o,d,h,c,e,i,a),l[0]&&(f+=1),i>=6){if(d){const m=this.idx(d-1,h,c,e);u===t[m]&&(l[f++]=o[m])}if(h){const m=this.idx(d,h-1,c,e);u===t[m]&&(l[f++]=o[m])}}if(i>=18){if(h&&d){const m=this.idx(d-1,h-1,c,e);u===t[m]&&(l[f++]=o[m])}if(h&&d<e[0]-1){const m=this.idx(d+1,h-1,c,e);u===t[m]&&(l[f++]=o[m])}}if(f)o[this.idx(d,h,c,e)]=l[0],this.fill_tratab(a,l,f);else{if(o[this.idx(d,h,c,e)]=s,s>=n){n+=r;const m=new Uint32Array(n);m.set(a),a=m}a[s-1]=s,s++}}}for(let c=0;c<s-1;c++){let h=c;for(;a[h]!==h+1;)h=a[h]-1;a[c]=h+1}return[s-1,a,o]}fill_tratab(t,e,i){let s=0;const r=new Uint32Array(i+5).fill(0);let a=2147483647;for(let o=0;o<i;o++){let l=e[o];for(s=0;t[l-1]!==l;)if(l=t[l-1],s++,s>100){U.info(`
Ooh no!!`);break}r[o]=l,a=Math.min(a,l)}for(let o=0;o<i;o++)t[r[o]-1]=a}translate_labels(t,e,i,s){const r=e[0]*e[1]*e[2];let n=0;const a=new Uint32Array(r).fill(0);for(let c=0;c<s;c++)n=Math.max(n,i[c]);const o=new Uint32Array(n).fill(0);let l=0;for(let c=0;c<r;c++)t[c]&&(o[i[t[c]-1]-1]||(l+=1,o[i[t[c]-1]-1]=l),a[c]=o[i[t[c]-1]-1]);return[l,a]}largest_original_cluster_labels(t,e,i){const s=t.length,r=new Uint32Array(e+1).fill(0),n=new Uint32Array(e+1).fill(0);for(let l=0;l<s;l++){const c=t[l],h=i[l];r[h]=c,n[h]++}let a=0;for(let l=0;l<e+1;l++){const c=r[l];a=Math.max(a,c);for(let h=0;h<e+1;h++)h!==l&&c===r[h]&&(n[l]<n[h]||n[l]===n[h]&&l<h)&&(r[l]=0)}const o=new Uint32Array(s).fill(0);for(let l=0;l<s;l++)o[l]=r[i[l]];return[a,o]}bwlabel(t,e,i=26,s=!1,r=!1){const n=Date.now(),a=e[0]*e[1]*e[2],o=new Uint32Array(a).fill(0);if(![6,18,26].includes(i))return U.info("bwlabel: conn must be 6, 18 or 26."),[0,o];if(e[0]<2||e[1]<2||e[2]<1)return U.info("bwlabel: img must be 2 or 3-dimensional"),[0,o];if(s)for(let u=0;u<a;u++)t[u]!==0&&(o[u]=1);else o.set(t);let[l,c,h]=this.do_initial_labelling(o,e,i);c===void 0&&(c=new Uint32Array);const[d,f]=this.translate_labels(h,e,c,l);if(U.info(i+" neighbor clustering into "+d+" regions in "+(Date.now()-n)+"ms"),r){const[u,m]=this.largest_original_cluster_labels(o,d,f);return[u,m]}return[d,f]}async createConnectedLabelImage(t,e=26,i=!1,s=!1){var h,d;const r=this.getVolumeIndexByID(t),n=Uint32Array.from(((h=this.volumes[r].dims)==null?void 0:h.slice(1,4))??[]),a=Uint32Array.from(((d=this.volumes[r].img)==null?void 0:d.slice())??[]),[o,l]=this.bwlabel(a,n,e,i,s),c=this.volumes[r].clone();c.opacity=.5,c.colormap="random";for(let f=0;f<c.img.length;f++)c.img[f]=l[f];return c.cal_min=0,c.cal_max=o,c}async scalecropUint8(t,e=0,i=255,s,r){const n=t.length,a=new Uint8Array(n);for(let o=0;o<n;o++){let l=t[o];l=e+r*(l-s),l=Math.max(l,e),l=Math.min(l,i),a[o]=l}return a}async scalecropFloat32(t,e=0,i=1,s,r){const n=t.length,a=new Float32Array(n);for(let o=0;o<n;o++){let l=t[o];l=e+r*(l-s),l=Math.max(l,e),l=Math.min(l,i),a[o]=l}return a}getScale(t,e=0,i=255,s=0,r=.999){let n=t.global_min,a=t.global_max;if(t.hdr.datatypeCode===2)return[n,1];if((!isFinite(s)||!isFinite(r))&&isFinite(t.cal_min)&&isFinite(t.cal_max)&&t.cal_max>t.cal_min){n=t.cal_min,a=t.cal_max;const w=(i-e)/(a-n);return U.info(" Robust Rescale:  min: "+n+"  max: "+a+" scale: "+w),console.log("Robust Rescale:  min: "+n+"  max: "+a+" scale: "+w),[n,w]}const o=t.img,l=t.hdr.dims[1]*t.hdr.dims[2]*t.hdr.dims[3];if(t.hdr.scl_slope!==1||t.hdr.scl_inter!==0){const w=t.img,x=new Float32Array(t.img.length);for(let y=0;y<l;y++)x[y]=w[y]*t.hdr.scl_slope+t.hdr.scl_inter}if(n<0&&U.warn("WARNING: Input image has value(s) below 0.0 !"),U.info(" Input:    min: "+n+"  max: "+a),s===0&&r===1)return[n,1];let c=0;for(let w=0;w<l;w++)Math.abs(o[w])>=1e-15&&c++;const h=1e3,d=(a-n)/h,f=new Array(h).fill(0);for(let w=0;w<l;w++){const x=o[w];let y=Math.floor((x-n)/d);y=Math.min(y,h-1),f[y]++}const u=new Array(h).fill(0);u[0]=f[0];for(let w=1;w<h;w++)u[w]=u[w-1]+f[w];let m=Math.floor(s*l),g=0;for(;g<h&&!(u[g]>=m);)g++;const p=n;for(n=g*d+p,m=l-Math.floor((1-r)*c),g=0;g<h-1&&!(u[g+1]>=m);)g++;a=g*d+p;let A=1;return n!==a&&(A=(i-e)/(a-n)),U.info(" Rescale:  min: "+n+"  max: "+a+" scale: "+A),[n,A]}conformVox2Vox(t,e,i=256,s=1,r=!1){const n=e.flat(),a=nt(n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9],n[10],n[11],n[12],n[13],n[14],n[15]),o=ue(t[1]/2,t[2]/2,t[3]/2,1),l=Ct(),c=se();rt(c,a),Ve(l,o,c);const h=H(l[0],l[1],l[2]),d=H(s,s,s);let f=nt(-1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1);r&&(f=nt(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)),rt(f,f);const u=ue(i,i,i,1),m=se();$n(m,f,d);const g=ue(u[0],u[1],u[2],1);Ve(g,g,m),Dc(g,g,.5);const p=fe();de(p,h,H(g[0],g[1],g[2]));const A=se();rt(A,m),A[3]=p[0],A[7]=p[1],A[11]=p[2];const w=se();Je(w,A);const x=se();Mo(x,a,w);const y=se();return Je(y,x),[A,x,y]}async createNiftiArray(t=[256,256,256],e=[1,1,1],i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1],s=2,r=new Uint8Array){return await Ke.createNiftiArray(t,e,i,s,r)}async niftiArray2NVImage(t=new Uint8Array){return await Ke.loadFromUrl({url:t})}async loadFromUrl(t){return await Ke.loadFromUrl({url:t})}async conform(t,e=!1,i=!0,s=!1,r=!1){const o=this.conformVox2Vox(t.hdr.dims,t.hdr.affine.flat(),256,1,e),l=o[0],c=o[2],h=256*256*256,d=new Float32Array(h),f=new Float32Array(t.img),u=t.hdr.dims[1]*t.hdr.dims[2]*t.hdr.dims[3];if(t.hdr.scl_slope!==1||t.hdr.scl_inter!==0)for(let M=0;M<u;M++)f[M]=f[M]*t.hdr.scl_slope+t.hdr.scl_inter;const m=t.hdr.dims[1],g=t.hdr.dims[2],p=t.hdr.dims[3],A=m*g;let w=-1;function x(M,T,S){return M+T*m+S*A}const y=c[0],v=c[4],D=c[8];if(i)for(let M=0;M<256;M++)for(let T=0;T<256;T++){const S=T*c[1]+M*c[2]+c[3],E=T*c[5]+M*c[6]+c[7],B=T*c[9]+M*c[10]+c[11];for(let P=0;P<256;P++){const V=P*y+S,R=P*v+E,k=P*D+B,z=Math.floor(V),W=Math.floor(R),j=Math.floor(k);if(w++,z<0||W<0||j<0)continue;const Q=Math.ceil(V),pe=Math.ceil(R),Ce=Math.ceil(k);if(Q>=m||pe>=g||Ce>=p)continue;const Me=V-z,Qe=R-W,tt=k-j,at=1-Me,dt=1-Qe,ke=1-tt,Le=x(z,W,j);let ve=0;ve+=f[Le]*at*dt*ke,ve+=f[Le+A]*at*dt*tt,ve+=f[Le+m]*at*Qe*ke,ve+=f[Le+m+A]*at*Qe*tt,ve+=f[Le+1]*Me*dt*ke,ve+=f[Le+1+A]*Me*dt*tt,ve+=f[Le+1+m]*Me*Qe*ke,ve+=f[Le+1+m+A]*Me*Qe*tt,d[w]=ve}}else for(let M=0;M<256;M++)for(let T=0;T<256;T++){const S=T*c[1]+M*c[2]+c[3],E=T*c[5]+M*c[6]+c[7],B=T*c[9]+M*c[10]+c[11];for(let P=0;P<256;P++){const V=Math.round(P*y+S),R=Math.round(P*v+E),k=Math.round(P*D+B);w++,!(V<0||R<0||k<0)&&(V>=m||R>=g||k>=p||(d[w]=f[x(V,R,k)]))}}let b=0;r&&(b=NaN);let C=new Uint8Array;if(s){const M=await this.getScale(t,0,1,b),T=await this.scalecropFloat32(d,0,1,M[0],M[1]);C=await this.createNiftiArray([256,256,256],[1,1,1],Array.from(l),16,new Uint8Array(T.buffer))}else{const M=await this.getScale(t,0,255,b),T=await this.scalecropUint8(d,0,255,M[0],M[1]);C=await this.createNiftiArray([256,256,256],[1,1,1],Array.from(l),2,T)}return await this.niftiArray2NVImage(C)}setRenderDrawAmbientOcclusion(t){if(!this.renderShader)throw new Error("renderShader undefined");this.renderDrawAmbientOcclusion=t,this.renderShader.use(this.gl),this.gl.uniform1fv(this.renderShader.uniforms.renderDrawAmbientOcclusion,[this.renderDrawAmbientOcclusion,1]),this.drawScene()}setColorMap(t,e){this.setColormap(t,e)}setColormapNegative(t,e){const i=this.getVolumeIndexByID(t);this.volumes[i].colormapNegative=e,this.updateGLVolume()}setModulationImage(t,e,i=0){const s=this.getVolumeIndexByID(t);let r=null;e.length>0&&(r=this.getVolumeIndexByID(e)),this.volumes[s].modulationImage=r,this.volumes[s].modulateAlpha=i,this.updateGLVolume()}setGamma(t=1){this.scene.gamma=t,ce.gamma=t,this.updateGLVolume()}async loadDeferred4DVolumes(t){const e=this.getVolumeIndexByID(t),i=this.volumes[e];if(i.nTotalFrame4D<=i.nFrame4D)return;i.nTotalFrame4D=i.nFrame4D;let s;i.fileObject?s=await Ke.loadFromFile({file:i.fileObject}):s=await Ke.loadFromUrl({url:i.url}),s&&(i.img=s.img.slice(),i.nTotalFrame4D=s.nTotalFrame4D,i.nFrame4D=s.nFrame4D,this.updateGLVolume())}setFrame4D(t,e){const i=this.getVolumeIndexByID(t),s=this.volumes[i];e>s.nFrame4D-1&&(e=s.nFrame4D-1),e<0&&(e=0),e!==s.frame4D&&(s.frame4D=e,this.updateGLVolume(),this.onFrameChange(s,e),this.createOnLocationChange())}getFrame4D(t){const e=this.getVolumeIndexByID(t);return this.volumes[e].frame4D}colormapFromKey(t){return ce.colormapFromKey(t)}colormap(t="",e=!1){return ce.colormap(t,e)}createColormapTexture(t=null,e=0,i=256){return t!==null&&this.gl.deleteTexture(t),e<1||i<1?null:(t=this.gl.createTexture(),this.gl.activeTexture(As),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.RGBA8,i,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),t)}addColormapList(t="",e=NaN,i=NaN,s=!1,r=!1,n=!0,a=!1){t.length<1&&(n=!1),this.colormapLists.push({name:t,min:e,max:i,isColorbarFromZero:s,negative:r,visible:n,invert:a})}refreshColormaps(){if(this.colormapLists=[],this.volumes.length<1&&this.meshes.length<1)return;const t=this.volumes.length;if(t>0)for(let n=0;n<t;n++){const a=this.volumes[n],o=Tr(a.cal_min,a.cal_max,a.cal_minNeg,a.cal_maxNeg),l=a.colormapType!==0;this.addColormapList(a.colormapNegative,o[0],o[1],l,!0,a.colorbarVisible,a.colormapInvert),this.addColormapList(a.colormap,a.cal_min,a.cal_max,l,!1,a.colorbarVisible,a.colormapInvert)}const e=this.meshes.length;if(e>0)for(let n=0;n<e;n++){const a=this.meshes[n];if(!a.colorbarVisible)continue;const o=a.layers.length;if("edgeColormap"in a&&"edges"in a&&a.edges!==void 0){const l=Tr(a.edgeMin,a.edgeMax,NaN,NaN);this.addColormapList(a.edgeColormapNegative,l[0],l[1],!1,!0,!0,a.colormapInvert),this.addColormapList(a.edgeColormap,a.edgeMin,a.edgeMax,!1,!1,!0,a.colormapInvert)}if(!(o<1))for(let l=0;l<o;l++){const c=this.meshes[n].layers[l];if(!c.colorbarVisible||c.colormap.length<1)continue;const h=c.colormapType!==0;if(c.useNegativeCmap){const d=Tr(c.cal_min,c.cal_max,c.cal_minNeg,c.cal_maxNeg);this.addColormapList(c.colormapNegative,d[0],d[1],h,!0,!0,c.colormapInvert)}this.addColormapList(c.colormap,c.cal_min,c.cal_max,h,!1,!0,c.colormapInvert)}}const i=this.colormapLists.length;if(i<1)return;this.colormapTexture=this.createColormapTexture(this.colormapTexture,i+1);let s=new Uint8ClampedArray;function r(n){const a=new Uint8ClampedArray(s.length+n.length);a.set(s),a.set(n,s.length),s=a}for(let n=0;n<i;n++)r(Array.from(this.colormap(this.colormapLists[n].name,this.colormapLists[n].invert)));return r(Array.from(this.drawLut.lut)),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,256,i+1,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s),this}sliceScale(t=!1){var n;let e=this.screenFieldOfViewMM(0);t&&(e=this.screenFieldOfViewVox(0));const i=Math.max(e[0],Math.max(e[1],e[2])),s=[e[0]/i,e[1]/i,e[2]/i];if(!((n=this.back)!=null&&n.dims))throw new Error("back.dims undefined");const r=[this.back.dims[1],this.back.dims[2],this.back.dims[3]];return{volScale:s,vox:r,longestAxis:i,dimsMM:e}}tileIndex(t,e){for(let i=0;i<this.screenSlices.length;i++){const s=this.screenSlices[i].leftTopWidthHeight;if(t>s[0]&&e>s[1]&&t<s[0]+s[2]&&e<s[1]+s[3])return i}return-1}inRenderTile(t,e){const i=this.tileIndex(t,e);return i>=0&&this.screenSlices[i].axCorSag===4?i:-1}sliceScroll3D(t=0){if(t!==0){if(this.volumes.length>0&&this.scene.clipPlaneDepthAziElev[0]<1.8){const e=this.scene.clipPlaneDepthAziElev.slice();return t>0&&(e[0]=Math.min(1.5,e[0]+.025)),t<0&&(e[0]=Math.max(-1.5,e[0]-.025)),e[0]!==this.scene.clipPlaneDepthAziElev[0]?(this.scene.clipPlaneDepthAziElev=e,this.setClipPlane(this.scene.clipPlaneDepthAziElev)):void 0}t>0&&(this.scene.volScaleMultiplier=Math.min(2,this.scene.volScaleMultiplier*1.1)),t<0&&(this.scene.volScaleMultiplier=Math.max(.5,this.scene.volScaleMultiplier*.9)),this.drawScene()}}deleteThumbnail(){this.bmpTexture&&(this.gl.deleteTexture(this.bmpTexture),this.bmpTexture=null,this.thumbnailVisible=!1)}inGraphTile(t,e){if(this.graph.opacity<=0||this.volumes.length<1||this.volumes[0].nFrame4D<1||!this.graph.plotLTWH||this.graph.plotLTWH[2]<1||this.graph.plotLTWH[3]<1)return!1;const i=[(t-this.graph.LTWH[0])/this.graph.LTWH[2],(e-this.graph.LTWH[1])/this.graph.LTWH[3]];return i[0]>0&&i[1]>0&&i[0]<=1&&i[1]<=1}updateBitmapFromClickToSegment(){if(this.clickToSegmentGrowingBitmap===null||this.drawBitmap===null||this.clickToSegmentGrowingBitmap.length!==this.drawBitmap.length)return;const t=this.drawBitmap.length;for(let e=0;e<t;e++)this.drawBitmap[e]=this.clickToSegmentGrowingBitmap[e]}sumBitmap(t){let e=0;for(let i=0;i<t.length;i++)e+=t[i];return e}doClickToSegment(t){const{tileIndex:e}=t;if(e<0||e>=this.screenSlices.length){U.warn(`Invalid tileIndex ${e} received in doClickToSegment.`);return}const i=this.screenSlices[e].axCorSag;if(i>2){U.warn("ClickToSegment attempted on non-2D slice tile.");return}const s=this.screenXY2TextureFrac(this.clickToSegmentXY[0],this.clickToSegmentXY[1],e,!1);if(s[0]<0){U.debug("Click location outside valid texture fraction for the tile.");return}const r=this.frac2vox(s),n=this.opts.clickToSegmentPercent;let a=this.back.getValue(r[0],r[1],r[2]);this.opts.clickToSegmentAutoIntensity&&(n!==0&&(a===0&&(a=.01),this.opts.clickToSegmentIntensityMax=a*(1+n),this.opts.clickToSegmentIntensityMin=a*(1-n)),a>(this.back.cal_min+this.back.cal_max)*.5?this.opts.clickToSegmentBright=!0:this.opts.clickToSegmentBright=!1);const o=this.opts.clickToSegmentBright?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;this.drawPenAxCorSag=i;const l=this.clickToSegmentIsGrowing?this.clickToSegmentGrowingBitmap:this.drawBitmap;if(!l){if(U.error("Target bitmap for flood fill is null."),this.clickToSegmentIsGrowing){if(this.drawBitmap||this.createEmptyDrawing(),!this.drawBitmap)return;this.clickToSegmentGrowingBitmap=this.drawBitmap.slice()}else if(this.createEmptyDrawing(),!this.drawBitmap)return;U.warn("Initialized missing bitmap in doClickToSegment.")}if(this.drawFloodFill([r[0],r[1],r[2]],this.opts.penValue,o,this.opts.clickToSegmentIntensityMin,this.opts.clickToSegmentIntensityMax,this.opts.floodFillNeighbors,this.opts.clickToSegmentMaxDistanceMM,this.opts.clickToSegmentIs2D,l),!this.clickToSegmentIsGrowing&&(U.debug("Applying clickToSegment mask to drawBitmap."),this.drawBitmap?(this.refreshDrawing(!1,!1),this.drawScene()):U.error("Cannot refresh drawing after click-to-segment apply, drawBitmap is null."),this.drawBitmap)){const c=this.getDescriptives({layer:0,masks:[],drawingIsMask:!0});this.onClickToSegment({mL:c.volumeML,mm3:c.volumeMM3})}this.createOnLocationChange(i)}mouseClick(t,e,i=0,s=!0){if(t*=this.uiData.dpr,e*=this.uiData.dpr,this.canvas.focus(),this.thumbnailVisible){this.thumbnailVisible=!1,Promise.all([this.loadVolumes(this.deferredVolumes),this.loadMeshes(this.deferredMeshes)]).catch(r=>{throw r});return}if(this.inGraphTile(t,e)){if(!this.graph.plotLTWH)throw new Error("plotLTWH undefined");const r=[(t-this.graph.plotLTWH[0])/this.graph.plotLTWH[2],(e-this.graph.plotLTWH[1])/this.graph.plotLTWH[3]];if(r[0]>0&&r[1]>0&&r[0]<=1&&r[1]<=1){const n=Math.round(r[0]*(this.volumes[0].nFrame4D-1));this.setFrame4D(this.volumes[0].id,n);return}r[0]>.5&&r[1]>1&&this.loadDeferred4DVolumes(this.volumes[0].id).catch(n=>{throw n});return}if(this.inRenderTile(t,e)>=0){this.sliceScroll3D(i),this.drawScene();return}if(!(this.screenSlices.length<1||this.gl.canvas.height<1||this.gl.canvas.width<1))for(let r=0;r<this.screenSlices.length;r++){const n=this.screenSlices[r].axCorSag;if(this.drawPenAxCorSag>=0&&this.drawPenAxCorSag!==n||n>2&&!this.opts.clickToSegment&&i===0)continue;const a=this.screenXY2TextureFrac(t,e,r,!0);if(!(a[0]<0)){if(i!==0||!s){if(!s){n<=2&&(this.scene.crosshairPos[2-n]=i,this.drawScene(),this.createOnLocationChange(n));return}const o=i<0?-1:1,l=[0,0,0];n<=2&&(l[2-n]=o,this.moveCrosshairInVox(l[0],l[1],l[2]));return}if(this.opts.isForceMouseClickToVoxelCenters?this.scene.crosshairPos=Vi(this.vox2frac(this.frac2vox(a))):this.scene.crosshairPos=Vi(a),this.opts.drawingEnabled){const o=this.frac2vox(this.scene.crosshairPos);if(!isFinite(this.opts.penValue)||this.opts.penValue<0||Object.is(this.opts.penValue,-0)){let l=0,c=Math.abs(this.opts.penValue);const h=!0;Object.is(this.opts.penValue,-0)?(l=0,c=0,U.debug("Erase Cluster selected")):(l=this.opts.penValue,U.debug("Intensity Grow selected",l)),this.drawFloodFill(o,c,l,NaN,NaN,this.opts.floodFillNeighbors,Number.POSITIVE_INFINITY,!1,this.drawBitmap,h),this.drawScene(),this.createOnLocationChange(n);return}else if(this.opts.clickToSegment){n<=2&&(this.clickToSegmentIsGrowing=!1,this.doClickToSegment({x:this.clickToSegmentXY[0],y:this.clickToSegmentXY[1],tileIndex:r})),this.createOnLocationChange(n);return}else{if(isNaN(this.drawPenLocation[0]))this.drawPenAxCorSag=n,this.drawPenFillPts=[],this.drawPt(...o,this.opts.penValue);else{if(o[0]===this.drawPenLocation[0]&&o[1]===this.drawPenLocation[1]&&o[2]===this.drawPenLocation[2]){this.drawScene(),this.createOnLocationChange(n);return}this.drawPenLine(o,this.drawPenLocation,this.opts.penValue)}this.drawPenLocation=o,this.opts.isFilledPen&&this.drawPenFillPts.push(o),this.refreshDrawing(!1,!1)}}this.drawScene(),this.createOnLocationChange(n);return}}}drawRuler(){let t=[],e=[];for(let h=0;h<this.screenSlices.length;h++)if(this.screenSlices[h].axCorSag!==4&&this.screenSlices[h].fovMM.length>1){e=this.screenSlices[h].leftTopWidthHeight,t=this.screenSlices[h].fovMM;break}if(e.length<4)return;const s=100/t[0]*e[2],r=Math.max(Math.round(s*.1),2),n=Math.floor(e[0]+.5*e[2]-.5*s),a=Number(this.opts.rulerWidth),o=Math.floor(e[1]+e[3]-r)+.5*a,l=[n,o,n+s,o];let c=[0,0,0,1];this.opts.rulerColor[0]+this.opts.rulerColor[1]+this.opts.rulerColor[2]<.8&&(c=[1,1,1,1]),this.drawRuler10cm(l,c,a+1),this.drawRuler10cm(l,this.opts.rulerColor,a)}drawRuler10cm(t,e,i=1){if(!this.lineShader)throw new Error("lineShader undefined");this.gl.bindVertexArray(this.genericVAO),this.lineShader.use(this.gl),this.gl.uniform4fv(this.lineShader.uniforms.lineColor,e),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,i),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,t),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const s=-.1*(t[0]-t[2]),r=t[1]-Math.floor(.5*this.opts.rulerWidth),n=Math.floor(r-.35*s),a=Math.floor(r-.7*s);for(let o=0;o<11;o++){let l=t[0]+o*s;l=Math.max(l,t[0]+.5*i),l=Math.min(l,t[2]-.5*i);const c=[l,r,l,n];o%5===0&&(c[3]=a),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,c),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}this.gl.bindVertexArray(this.unusedVAO)}screenXY2mm(t,e,i=-1){let s;for(let r=0;r<this.screenSlices.length;r++){let n=r;if(i>=0&&(n=i),this.screenSlices[n].axCorSag>2)continue;const o=this.screenSlices[n].leftTopWidthHeight;if(t<o[0]||e<o[1]||t>o[0]+o[2]||e>o[1]+o[3]||(s=this.screenXY2TextureFrac(t,e,n,!1),s[0]<0))continue;const l=this.frac2mm(s);return ue(l[0],l[1],l[2],n)}return ue(NaN,NaN,NaN,NaN)}dragForPanZoom(t){const e=this.screenXY2mm(t[2],t[3]);if(isNaN(e[0]))return;const i=this.screenXY2mm(t[0],t[1],e[3]);if(isNaN(i[0])||isNaN(e[0])||isNaN(e[3]))return;const s=Ct(),r=this.uiData.pan2DxyzmmAtMouseDown[3];Tc(s,e,i),this.scene.pan2Dxyzmm[0]=this.uiData.pan2DxyzmmAtMouseDown[0]+r*s[0],this.scene.pan2Dxyzmm[1]=this.uiData.pan2DxyzmmAtMouseDown[1]+r*s[1],this.scene.pan2Dxyzmm[2]=this.uiData.pan2DxyzmmAtMouseDown[2]+r*s[2],this.canvas.focus()}dragForCenterButton(t){this.dragForPanZoom(t)}dragForSlicer3D(t){let e=this.uiData.pan2DxyzmmAtMouseDown[3];const i=t[3]-t[1];e+=i*.01,e=Math.max(e,.1),e=Math.min(e,10);const r=this.scene.pan2Dxyzmm[3]-e;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=e),this.scene.pan2Dxyzmm[3]=e;const n=this.frac2mm(this.scene.crosshairPos);this.scene.pan2Dxyzmm[0]+=r*n[0],this.scene.pan2Dxyzmm[1]+=r*n[1],this.scene.pan2Dxyzmm[2]+=r*n[2]}drawMeasurementTool(t){function e(l,c,h,d,f){const u=l-h,m=c-d;if(u===0&&m===0)return{origin:[h+f,d],terminus:[h+f,d]};const g=Math.sqrt(u*u+m*m),p=f*u/g,A=f*m/g;return{origin:[l+p,c+A],terminus:[h-p,d-A]}}const i=this.gl;if(i.bindVertexArray(this.genericVAO),i.depthFunc(i.ALWAYS),i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl),i.uniform4fv(this.lineShader.uniforms.lineColor,this.opts.rulerColor),i.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[i.canvas.width,i.canvas.height]),i.uniform1f(this.lineShader.uniforms.thickness,this.opts.rulerWidth),i.uniform4fv(this.lineShader.uniforms.startXYendXY,t),i.drawArrays(i.TRIANGLE_STRIP,0,4);const s=this.opts.measureLineColor;s[3]=1,i.uniform4fv(this.lineShader.uniforms.lineColor,s);const r=this.opts.rulerWidth;i.uniform1f(this.lineShader.uniforms.thickness,r*2);let n=[t[0],t[1]-r,t[0],t[1]+r];i.uniform4fv(this.lineShader.uniforms.startXYendXY,n),i.drawArrays(i.TRIANGLE_STRIP,0,4),n=[t[2],t[3]-r,t[2],t[3]+r],i.uniform4fv(this.lineShader.uniforms.startXYendXY,n),i.drawArrays(i.TRIANGLE_STRIP,0,4);let a=this.canvasPos2frac([t[0],t[1]]),o=this.canvasPos2frac([t[2],t[3]]);if(a[0]>=0&&o[0]>=0){const l=this.frac2mm(a);a=H(l[0],l[1],l[2]);const c=this.frac2mm(o);o=H(c[0],c[1],c[2]);const h=fe();ta(h,a,o);const d=Li(h);let f=2;d>9&&(f=1),d>99&&(f=0);let u=d.toFixed(f);this.opts.showMeasureUnits&&(u=`${u} mm`);let m=t;const[g,p,A,w]=t,{origin:x,terminus:y}=e(g,p,A,w,30);switch(this.opts.measureTextJustify){case"start":m=[...x,...x.map(v=>v+1)];break;case"end":m=m=[...y,...y.map(v=>v+1)];break;default:m=t;break}this.drawTextBetween(m,u,this.opts.measureTextHeight/this.opts.textHeight,this.opts.measureTextColor)}i.bindVertexArray(this.unusedVAO)}drawRect(t,e=[1,0,0,-1]){if(e[3]<0&&(e=this.opts.crosshairColor),!this.rectShader)throw new Error("rectShader undefined");this.opts.selectionBoxIsOutline?(this.drawCircle(t,e,.1),this.rectOutlineShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform1f(this.rectOutlineShader.uniforms.thickness,this.opts.selectionBoxLineThickness),this.gl.uniform4fv(this.rectOutlineShader.uniforms.lineColor,e),this.gl.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.rectOutlineShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)):(this.rectShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform4fv(this.rectShader.uniforms.lineColor,e),this.gl.uniform2fv(this.rectShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.rectShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO))}drawCircle(t,e=this.opts.fontColor,i=1){if(!this.circleShader)throw new Error("circleShader undefined");this.circleShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform4fv(this.circleShader.uniforms.circleColor,e),this.gl.uniform2fv(this.circleShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.circleShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.uniform1f(this.circleShader.uniforms.fillPercent,i),this.gl.uniform4fv(this.circleShader.uniforms.circleColor,e),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawSelectionBox(t){if(this.opts.dragMode===6){this.drawCircle(t,this.opts.selectionBoxColor,.1);return}this.drawRect(t,this.opts.selectionBoxColor)}effectiveCanvasHeight(){return this.gl.canvas.height-this.colorbarHeight}effectiveCanvasWidth(){return this.gl.canvas.width-this.getLegendPanelWidth()}getAllLabels(){const s=this.meshes.filter(n=>n.type==="connectome").flatMap(n=>n.nodes).map(n=>n.label).filter(n=>n!==void 0);return[...this.document.labels,...s]}getConnectomeLabels(){const s=this.meshes.filter(o=>o.type==="connectome"&&o.showLegend!==!1).flatMap(o=>o.nodes).map(o=>o.label).filter(o=>o!==void 0&&o.text!==""),r=this.document.labels.filter(o=>o.anchor==null||o.anchor===0),n=new Set(s);for(const o of r)n.add(o);const a=this.meshes.filter(o=>o.type==="mesh");for(let o=0;o<a.length;o++)for(let l=0;l<a[o].layers.length;l++)if(a[o].layers[l].labels)for(let c=0;c<a[o].layers[l].labels.length;c++)n.add(a[o].layers[l].labels[c]);return Array.from(n)}getBulletMarginWidth(){let t=0;const e=this.getConnectomeLabels();if(e.length===0)return 0;const i=e.length===1?e[0].style.bulletScale:e.reduce((n,a)=>n.style.bulletScale>a.style.bulletScale?n:a).style.bulletScale,s=e.length===1?e[0]:e.reduce((n,a)=>{const o=this.opts.textHeight*this.gl.canvas.height*n.style.textScale,l=this.opts.textHeight*this.gl.canvas.height*a.style.textScale;return this.textHeight(o,n.text)>this.textHeight(l,a.text)?n:a}),r=this.opts.textHeight*this.gl.canvas.height*s.style.textScale;return t=this.textHeight(r,s.text)*i,t+=r,t}getLegendPanelWidth(){const t=this.getConnectomeLabels();if(!this.opts.showLegend||t.length===0)return 0;const i=this.opts.textHeight*this.gl.canvas.height*1;let s=0;const r=t.reduce((l,c)=>{const h=this.opts.textHeight*this.gl.canvas.height*l.style.textScale,d=this.opts.textHeight*this.gl.canvas.height*c.style.textScale;return this.textWidth(h,l.text)>this.textWidth(d,c.text)?l:c}),n=this.opts.textHeight*this.gl.canvas.height*r.style.textScale,a=this.textWidth(n,r.text),o=this.getBulletMarginWidth();return a&&(s=o+a,s+=i*2),s>=this.gl.canvas.width?0:s}getLegendPanelHeight(){const t=this.getConnectomeLabels();let e=0;const i=this.opts.textHeight*this.gl.canvas.height;for(const s of t){const r=this.opts.textHeight*this.gl.canvas.height*s.style.textScale,n=this.textHeight(r,s.text);e+=n}return e&&(e+=i/2*(t.length+1)),e}reserveColorbarPanel(){let t=Math.max(this.opts.textHeight,.01);t=t*Math.min(this.gl.canvas.height,this.gl.canvas.width);const e=3*t,s=(this.opts.colorbarWidth>0&&this.opts.colorbarWidth<=1?this.opts.colorbarWidth:1)*this.gl.canvas.width,r=[(this.gl.canvas.width-s)/2,this.gl.canvas.height-e,s,e];return this.colorbarHeight=r[3]+1,r}drawColorbarCore(t=0,e=[0,0,0,0],i=!1,s=0,r=1,n){if(e[2]<=0||e[3]<=0)return;let a=Math.max(this.opts.textHeight,.01);a=a*Math.min(this.gl.canvas.height,this.gl.canvas.width);let o=a;const l=3*a;let c=a;if(e[3]<l){if(e[3]<3)return;o=1,c=e[3]-2}this.gl.disable(this.gl.DEPTH_TEST),this.colorbarHeight=e[3]+1;const h=[e[0]+o,e[1],e[2]-2*o,c],d=[h[0]-1,h[1]-1,h[2]+2,h[3]+2];if(this.opts.showColorbarBorder&&this.drawRect(d,this.opts.crosshairColor),!this.colorbarShader)throw new Error("colorbarShader undefined");this.colorbarShader.use(this.gl),this.gl.activeTexture(As),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST);const f=t;if(this.gl.uniform1f(this.colorbarShader.uniforms.layer,f),this.gl.uniform2fv(this.colorbarShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.disable(this.gl.CULL_FACE),i){const D=[h[0]+h[2],h[1],-h[2],h[3]];this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight,D)}else this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight,h);this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR);let u=0;if(n&&r<0&&i?(u=r,r=0):n&&s>0&&(u=s,s=0),s===r||a<1)return;const m=Math.abs(r-s);let[g,p]=Ba(s,r);p<s&&(p+=g);function A(D){return D.toFixed(6).replace(/\.?0*$/,"")}let w=p;const x=[0,h[1]+h[3]-a*.5,2,a*.75],y=x[1]+x[3],v=1;for(;w<=r;){x[0]=h[0]+(w-s)/m*h[2],this.drawRect(x);const D=A(v*w);this.drawTextBelow([x[0],y],D),w+=g}if(u!==0){const D=[h[0]+(u-s)/m*h[2],h[1]-h[3]*.25,2,h[3]*1.5];this.drawRect(D)}}drawColorbar(){const t=this.colormapLists,e=t.length;if(e<1)return;let i=0;for(let o=0;o<e;o++)t[o].visible&&i++;if(i<1)return;let s=this.reserveColorbarPanel(),r=Math.max(this.opts.textHeight,.01);r=r*Math.min(this.gl.canvas.height,this.gl.canvas.width);const n=3*r;let a=s[2]/i;(s[2]<=0||s[3]<=0)&&(a=this.gl.canvas.width/i,s=[0,this.gl.canvas.height-n,a,n]),s[2]=a;for(let o=0;o<e;o++)t[o].visible&&(this.drawColorbarCore(o,s,t[o].negative,t[o].min,t[o].max,t[o].isColorbarFromZero),s[0]+=a)}textWidth(t,e){if(!e)return 0;let i=0;const s=new TextEncoder().encode(e);for(let r=0;r<e.length;r++)i+=t*this.fontMets.mets[s[r]].xadv;return i}textHeight(t,e){if(!e)return 0;const i=new Set(Array.from(e)),s=new TextEncoder().encode(Array.from(i).join("")),n=Object.values(this.fontMets.mets).filter((a,o)=>s.includes(o)).reduce((a,o)=>a.lbwh[3]>o.lbwh[3]?a:o).lbwh[3];return t*n}drawChar(t,e,i){if(!this.fontShader)throw new Error("fontShader undefined");const s=this.fontMets.mets[i],r=t[0]+e*s.lbwh[0],n=-(e*s.lbwh[1]),a=e*s.lbwh[2],o=e*s.lbwh[3],l=t[1]+(n-o)+e;return this.gl.uniform4f(this.fontShader.uniforms.leftTopWidthHeight,r,l,a,o),this.gl.uniform4fv(this.fontShader.uniforms.uvLeftTopWidthHeight,s.uv_lbwh),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),e*s.xadv}drawLoadingText(t){if(t){if(!this.canvas)throw new Error("canvas undefined");this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.BLEND),this.drawTextBelow([this.canvas.width/2,this.canvas.height/2],t,3)}}drawText(t,e,i=1,s=null){if(this.opts.textHeight<=0)return;if(!this.fontShader)throw new Error("fontShader undefined");this.fontShader.use(this.gl);const r=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width)*i;this.gl.enable(this.gl.BLEND),this.gl.uniform2f(this.fontShader.uniforms.canvasWidthHeight,this.gl.canvas.width,this.gl.canvas.height),s===null&&(s=this.opts.fontColor),this.gl.uniform4fv(this.fontShader.uniforms.fontColor,s);let n=r/this.fontMets.size*this.fontMets.distanceRange;n=Math.max(n,1),this.gl.uniform1f(this.fontShader.uniforms.screenPxRange,n);const a=new TextEncoder().encode(e);this.gl.bindVertexArray(this.genericVAO);for(let o=0;o<e.length;o++)t[0]+=this.drawChar(t,r,a[o]);this.gl.bindVertexArray(this.unusedVAO)}drawTextRight(t,e,i=1,s=null){this.opts.textHeight<=0||(t[1]-=.5*this.opts.textHeight*this.gl.canvas.height,this.drawText(t,e,i,s))}drawTextLeft(t,e,i=1,s=null){if(this.opts.textHeight<=0)return;const r=this.opts.textHeight*this.gl.canvas.height*i;t[0]-=this.textWidth(r,e),t[1]-=.5*r,this.drawText(t,e,i,s)}drawTextRightBelow(t,e,i=1,s=null){this.opts.textHeight<=0||this.drawText(t,e,i,s)}drawTextBetween(t,e,i=1,s=null){if(this.opts.textHeight<=0)return;const r=[(t[0]+t[2])*.5,(t[1]+t[3])*.5],n=this.opts.textHeight*this.gl.canvas.height*i,a=this.textWidth(n,e);r[0]-=.5*a,r[1]-=.5*n;const o=[r[0]-1,r[1]-1,a+2,n+2];let l=s;l===null&&(l=this.opts.crosshairColor),l&&l[0]+l[1]+l[2]>.8?l=[0,0,0,.5]:l=[1,1,1,.5],this.drawRect(o,l),this.drawText(r,e,i,s)}drawTextBelow(t,e,i=1,s=null){if(this.opts.textHeight<=0)return;if(!this.canvas)throw new Error("canvas undefined");let r=this.opts.textHeight*this.gl.canvas.height*i,n=this.textWidth(r,e);n>this.canvas.width&&(i*=(this.canvas.width-2)/n,r=this.opts.textHeight*this.gl.canvas.height*i,n=this.textWidth(r,e)),t[0]-=.5*this.textWidth(r,e),t[0]=Math.max(t[0],1),t[0]=Math.min(t[0],this.canvas.width-n-1),this.drawText(t,e,i,s)}updateInterpolation(t,e=!1){let i=this.gl.LINEAR;!e&&this.opts.isNearestInterpolation&&(i=this.gl.NEAREST),t===0?this.gl.activeTexture(si):this.gl.activeTexture(Ir),this.opts.is2DSliceShader?(this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,i),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,i)):(this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,i),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,i))}setAtlasOutline(t){this.opts.atlasOutline=t,this.updateGLVolume(),this.drawScene()}setInterpolation(t){this.opts.isNearestInterpolation=t;const e=this.volumes.length;if(!(e<1)){for(let i=0;i<e;i++)this.updateInterpolation(i);this.drawScene()}}calculateMvpMatrix2D(t,e,i,s=1/0,r=0,n=0,a=0,o){this.gl.viewport(t[0],this.gl.canvas.height-(t[1]+t[3]),t[2],t[3]);let c=e[0],h=i[0],d=[c,e[1]],f=[h-c,i[1]-e[1]];o&&(d=[i[0],e[1]],f=[e[0]-i[0],i[1]-e[1]],c=-i[0],h=-e[0]);const u=2*Math.max(Math.abs(e[2]),Math.abs(i[2])),m=se();let g=.01,p=u*8;if(s!==1/0){let D=o;a===0&&(n===0||n===180)&&(D=!D);let b=u*1.8-r;D||(b=u*1.8+r),g=b-s,p=b+s}fs(m,c,h,e[1],i[1],g,p);const A=se();A[0]=-1;const w=H(0,0,-u*1.8);ai(A,A,w),cs(A,A,It(270-a)),hs(A,A,It(n-180));const x=se();Je(x,A);const y=se();rt(y,x);const v=se();return Rt(v,m,A),{modelViewProjectionMatrix:v,modelMatrix:A,normalMatrix:y,leftTopMM:d,fovMM:f}}swizzleVec3MM(t,e){return e===1?t=Ge(t,[0,2,1]):e===2&&(t=Ge(t,[1,2,0])),t}screenFieldOfViewVox(t=0){const e=Vi(this.volumeObject3D.fieldOfViewDeObliqueMM);return this.swizzleVec3MM(e,t)}screenFieldOfViewMM(t=0,e=!1){if(this.volumes.length<1){let o=H(this.extentsMin[0],this.extentsMin[1],this.extentsMin[2]),l=H(this.extentsMax[0],this.extentsMax[1],this.extentsMax[2]);o=this.swizzleVec3MM(o,t),l=this.swizzleVec3MM(l,t);const c=fe();return de(c,l,o),c}if(!e&&!this.opts.isSliceMM)return this.screenFieldOfViewVox(t);const i=this.volumeObject3D.extentsMin,s=this.volumeObject3D.extentsMax;let r=H(i[0],i[1],i[2]),n=H(s[0],s[1],s[2]);r=this.swizzleVec3MM(r,t),n=this.swizzleVec3MM(n,t);const a=fe();return de(a,n,r),a}screenFieldOfViewExtendedVox(t=0){const e=this.volumes[0].extentsMinOrtho,i=this.volumes[0].extentsMaxOrtho;let s=H(e[0],e[1],e[2]),r=H(i[0],i[1],i[2]);const n=se();s=this.swizzleVec3MM(s,t),r=this.swizzleVec3MM(r,t);const a=fe();return de(a,r,s),{mnMM:s,mxMM:r,rotation:n,fovMM:a}}screenFieldOfViewExtendedMM(t=0){if(this.volumes.length<1){let o=H(this.extentsMin[0],this.extentsMin[1],this.extentsMin[2]),l=H(this.extentsMax[0],this.extentsMax[1],this.extentsMax[2]);const c=se();o=this.swizzleVec3MM(o,t),l=this.swizzleVec3MM(l,t);const h=fe();return de(h,l,o),{mnMM:o,mxMM:l,rotation:c,fovMM:h}}if(!this.volumeObject3D)throw new Error("volumeObject3D undefined");const e=this.volumeObject3D.extentsMin,i=this.volumeObject3D.extentsMax;let s=H(e[0],e[1],e[2]),r=H(i[0],i[1],i[2]);const n=se();s=this.swizzleVec3MM(s,t),r=this.swizzleVec3MM(r,t);const a=fe();return de(a,r,s),{mnMM:s,mxMM:r,rotation:n,fovMM:a}}drawSliceOrientationText(t,e,i=[NaN,NaN]){this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height);let s="S";e===0&&(s="A");let r=this.opts.isRadiologicalConvention?"R":"L";if(e===2&&(r=this.opts.sagittalNoseLeft?"A":"P"),this.opts.isCornerOrientationText){this.drawTextRightBelow([t[0],t[1]],r+s);return}let n=!0,a=!0;if(!isNaN(i[0])){const o=this.opts.textHeight*this.gl.canvas.height+2;i[1]>o&&(this.drawTextBelow([t[0]+t[2]*.5,t[1]+i[1]-o],s),n=!1);const l=this.textWidth(o,r)+2;i[0]>l&&(this.drawTextRight([t[0]+i[0]-l,t[1]+t[3]*.5],r),a=!1)}n&&this.drawTextBelow([t[0]+t[2]*.5,t[1]],s),a&&this.drawTextRight([t[0],t[1]+t[3]*.5],r)}xyMM2xyzMM(t,e){let i=2;t===1&&(i=1),t===2&&(i=0);let s=[0,0,0],r=[1,1,0],n=[1,0,1];s[i]=e,r[i]=e,n[i]=e,s=this.frac2mm(s),r=this.frac2mm(r),n=this.frac2mm(n),s=this.swizzleVec3MM(H(s[0],s[1],s[2]),t),r=this.swizzleVec3MM(H(r[0],r[1],r[2]),t),n=this.swizzleVec3MM(H(n[0],n[1],n[2]),t);const a=(r[0]-s[0])*(n[1]-s[1])-(n[0]-s[0])*(r[1]-s[1]);let o=(r[0]-s[0])*(n[2]-s[2])-(n[0]-s[0])*(r[2]-s[2]);o/=a;let l=(r[1]-s[1])*(n[2]-s[2])-(n[1]-s[1])*(r[2]-s[2]);l/=a;const c=[0,0,0,0,0];return c[0]=s[0],c[1]=s[1],c[2]=s[2],c[3]=l,c[4]=o,c}draw2DMain(t,e,i=NaN){let s=new Float32Array([0,0,0]);this.volumes.length>0&&(s=new Float32Array(this.volumes[0].frac2mm.slice()));let r=this.screenFieldOfViewExtendedMM(e),n=se();!this.opts.isSliceMM&&this.volumes.length>0&&(s=new Float32Array(this.volumes[0].frac2mmOrtho.slice()),n=be(this.volumes[0].mm2ortho),r=this.screenFieldOfViewExtendedVox(e));let a=this.opts.isRadiologicalConvention&&e<2;i===1/0||i===-1/0?(a=i!==1/0,e===1&&(a=!a)):this.opts.sagittalNoseLeft&&e===2&&(a=!a);let o=0,l=0;e===2?l=a?90:-90:e===1?l=a?180:0:(l=a?180:0,o=a?-90:90);const c=this.gl;let h=!1;if(t[2]===0||t[3]===0){h=!0;const p=c.canvas.width/r.fovMM[0],A=c.canvas.height/r.fovMM[1],w=Math.min(p,A),x=p/w,y=A/w;r.fovMM[0]*=x,r.fovMM[1]*=y;let v=(r.mnMM[0]+r.mxMM[0])*.5;r.mnMM[0]=v-r.fovMM[0]*.5,r.mxMM[0]=v+r.fovMM[0]*.5,v=(r.mnMM[1]+r.mxMM[1])*.5,r.mnMM[1]=v-r.fovMM[1]*.5,r.mxMM[1]=v+r.fovMM[1]*.5,t=[0,0,c.canvas.width,c.canvas.height]}if(isNaN(i)){const p=this.scene.pan2Dxyzmm,A=this.swizzleVec3MM(H(p[0],p[1],p[2]),e),w=this.scene.pan2Dxyzmm[3];r.mnMM[0]-=A[0],r.mxMM[0]-=A[0],r.mnMM[1]-=A[1],r.mxMM[1]-=A[1],r.mnMM[0]/=w,r.mxMM[0]/=w,r.mnMM[1]/=w,r.mxMM[1]/=w}let d=2;e===1&&(d=1),e===2&&(d=0);let f=this.scene.crosshairPos[d],u=this.frac2mm(this.scene.crosshairPos);!isNaN(i)&&i!==1/0&&i!==-1/0&&(u=this.frac2mm([.5,.5,.5]),u[d]=i,f=this.mm2frac(u)[d]);const m=u[d];c.clear(c.DEPTH_BUFFER_BIT);let g=this.calculateMvpMatrix2D(t,r.mnMM,r.mxMM,1/0,0,l,o,a);if(i===1/0||i===-1/0){const p=t.slice();this.draw3D(t,g.modelViewProjectionMatrix,g.modelMatrix,g.normalMatrix,l,o);const A=this.screenSlices[this.screenSlices.length-1];A.leftTopWidthHeight=p,A.axCorSag=e,A.sliceFrac=1/0,A.AxyzMxy=this.xyMM2xyzMM(e,f),A.leftTopMM=g.leftTopMM,A.fovMM=g.fovMM;return}if(c.enable(c.DEPTH_TEST),c.blendFunc(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA),c.disable(c.BLEND),c.depthFunc(c.GREATER),c.disable(c.CULL_FACE),this.volumes.length>0){let p=this.sliceMMShader;if(this.opts.is2DSliceShader&&(p=this.slice2DShader),this.opts.isV1SliceShader&&(p=this.sliceV1Shader),!p)throw new Error("slice Shader undefined");p.use(this.gl),c.uniform1f(p.uniforms.overlayOutlineWidth,this.overlayOutlineWidth),c.uniform1f(p.uniforms.overlayAlphaShader,this.overlayAlphaShader),c.uniform1i(p.uniforms.isAlphaClipDark,this.isAlphaClipDark?1:0),c.uniform1i(p.uniforms.backgroundMasksOverlays,this.backgroundMasksOverlays),c.uniform1f(p.uniforms.drawOpacity,this.drawOpacity),c.enable(c.BLEND),c.blendFunc(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA),c.uniform1f(p.uniforms.opacity,this.volumes[0].opacity),c.uniform1i(p.uniforms.axCorSag,e),c.uniform1f(p.uniforms.slice,f),c.uniformMatrix4fv(p.uniforms.frac2mm,!1,s),c.uniformMatrix4fv(p.uniforms.mvpMtx,!1,g.modelViewProjectionMatrix.slice()),c.bindVertexArray(this.genericVAO),c.drawArrays(c.TRIANGLE_STRIP,0,4),c.bindVertexArray(this.unusedVAO),this.screenSlices.push({leftTopWidthHeight:t,axCorSag:e,sliceFrac:f,AxyzMxy:this.xyMM2xyzMM(e,f),leftTopMM:g.leftTopMM,screen2frac:[],fovMM:g.fovMM})}if(isNaN(i)&&this.drawCrosshairs3D(!0,1,g.modelViewProjectionMatrix,!0,this.opts.isSliceMM),this.opts.meshThicknessOn2D>0){this.opts.meshThicknessOn2D!==1/0&&(g=this.calculateMvpMatrix2D(t,r.mnMM,r.mxMM,this.opts.meshThicknessOn2D,m,l,o,a));const p=be(g.modelViewProjectionMatrix);Rt(p,p,n),this.drawMesh3D(!0,1,p,g.modelMatrix,g.normalMatrix)}isNaN(i)&&this.drawCrosshairs3D(!1,.15,g.modelViewProjectionMatrix,!0,this.opts.isSliceMM),h&&this.opts.isOrientationTextVisible&&this.drawSliceOrientationText(t,e),this.readyForSync=!0}draw2D(t,e,i=NaN,s=[NaN,NaN]){const r=[NaN,NaN];if(s[0]===1/0){const n=this.sliceScale().volScale;let a=this.scaleSlice(n[0],n[1],[0,0],[t[2],t[3]]);e===1&&(a=this.scaleSlice(n[0],n[2],[0,0],[t[2],t[3]])),e===2&&(a=this.scaleSlice(n[1],n[2],[0,0],[t[2],t[3]])),s[0]=a[2],s[1]=a[3]}if(isNaN(s[0]))this.draw2DMain(t,e,i);else{const n=t.slice();r[0]=Math.floor(.5*(n[2]-s[0])),r[1]=Math.floor(.5*(n[3]-s[1])),n[0]+=r[0],n[1]+=r[1],n[2]=s[0],n[3]=s[1],this.draw2DMain(n,e,i)}i===1/0||i===-1/0||e===4||t[2]!==0&&t[3]!==0&&this.opts.isOrientationTextVisible&&this.drawSliceOrientationText(t,e,r)}calculateMvpMatrix(t,e=[0,0,0,0],i,s){(e[2]===0||e[3]===0)&&(e=[0,0,this.gl.canvas.width,this.gl.canvas.height]);const r=e[2]/e[3];let n=this.furthestFromPivot;const a=this.pivot3D,o=se();n=.8*n/this.scene.volScaleMultiplier,r<1?fs(o,-n,n,-n/r,n/r,n*.01,n*8):fs(o,-n*r,n*r,-n,n,n*.01,n*8);const l=se();l[0]=-1;const c=H(0,0,-n*1.8);ai(l,l,c),this.position&&ai(l,l,this.position),cs(l,l,It(270-s)),hs(l,l,It(i-180)),ai(l,l,[-a[0],-a[1],-a[2]]);const h=se();Je(h,l);const d=se();rt(d,h);const f=se();return Rt(f,o,l),[f,l,d]}calculateModelMatrix(t,e){if(!this.back)throw new Error("back undefined");const i=se();if(i[0]=-1,cs(i,i,It(270-e)),hs(i,i,It(t-180)),this.back.obliqueRAS){const s=be(this.back.obliqueRAS);Rt(i,i,s)}return i}calculateRayDirection(t,e){const i=this.calculateModelMatrix(t,e),s=nt(1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1),r=se();Rt(r,s,i);const n=se();Je(n,r);const a=ue(0,0,-1,1);Ve(a,a,n);const o=H(a[0],a[1],a[2]);ft(o,o);const l=5e-5;return Math.abs(o[0])<l&&(o[0]=l),Math.abs(o[1])<l&&(o[1]=l),Math.abs(o[2])<l&&(o[2]=l),o}sceneExtentsMinMax(t=!0){let e=H(0,0,0),i=H(0,0,0);if(this.volumes.length>0){if(!this.volumeObject3D)throw new Error("volumeObject3D undefined");e=H(this.volumeObject3D.extentsMin[0],this.volumeObject3D.extentsMin[1],this.volumeObject3D.extentsMin[2]),i=H(this.volumeObject3D.extentsMax[0],this.volumeObject3D.extentsMax[1],this.volumeObject3D.extentsMax[2]),t||(e=H(this.volumes[0].extentsMinOrtho[0],this.volumes[0].extentsMinOrtho[1],this.volumes[0].extentsMinOrtho[2]),i=H(this.volumes[0].extentsMaxOrtho[0],this.volumes[0].extentsMaxOrtho[1],this.volumes[0].extentsMaxOrtho[2]))}if(this.meshes.length>0){if(this.volumes.length<1){const r=this.meshes[0].extentsMin,n=this.meshes[0].extentsMax;e=H(r[0],r[1],r[2]),i=H(n[0],n[1],n[2])}for(let r=0;r<this.meshes.length;r++){const n=this.meshes[r].extentsMin,a=this.meshes[r].extentsMax,o=H(n[0],n[1],n[2]);un(e,e,o);const l=H(a[0],a[1],a[2]);mn(i,i,l)}}const s=fe();return de(s,i,e),[e,i,s]}setPivot3D(){const[t,e]=this.sceneExtentsMinMax(),i=fe();Ht(i,t,e),vc(i,i,.5),this.pivot3D=[i[0],i[1],i[2]],de(i,e,t),this.extentsMin=t,this.extentsMax=e,this.furthestFromPivot=Lt(i)*.5}getMaxVols(){if(this.volumes.length<1)return 0;let t=0;for(let e=0;e<this.volumes.length;e++)t=Math.max(t,this.volumes[e].nFrame4D);return t}detectPartialllyLoaded4D(){if(this.volumes.length<1)return!1;for(let t=0;t<this.volumes.length;t++)if(this.volumes[t].nFrame4D<this.volumes[t].hdr.dims[4])return!0;return!1}drawGraph(){if(this.getMaxVols()<2)return;const t=this.graph;let e=0;if(this.graph.autoSizeMultiplanar&&this.opts.sliceType===3)for(let k=0;k<this.screenSlices.length;k++){const z=this.screenSlices[k].axCorSag;if(z===0&&(e=this.screenSlices[k].leftTopWidthHeight[1]),z!==2)continue;const W=this.screenSlices[k].leftTopWidthHeight.slice();W[1]===e?(t.LTWH[0]=W[0]+W[2],t.LTWH[1]=W[1]):(t.LTWH[0]=W[0],t.LTWH[1]=W[1]+W[3]),t.LTWH[2]=W[2],t.LTWH[3]=W[2]}if(t.opacity<=0||t.LTWH[2]<=5||t.LTWH[3]<=5||Math.floor(t.LTWH[0]+t.LTWH[2])>this.gl.canvas.width||Math.floor(t.LTWH[1]+t.LTWH[3])>this.gl.canvas.height)return;t.backColor=[.15,.15,.15,t.opacity],t.lineColor=[1,1,1,1],this.opts.backColor[0]+this.opts.backColor[1]+this.opts.backColor[2]>1.5&&(t.backColor=[.95,.95,.95,t.opacity],t.lineColor=[0,0,0,1]);const i=.2,s=.3;t.lineColor[3]=i,t.textColor=t.lineColor.slice(),t.textColor[3]=1,t.lineThickness=3,t.gridLineThickness=1,t.lineAlpha=1,t.lines=[];const r=[];if(t.vols.length<1)this.volumes[0]!=null&&r.push(0);else for(let k=0;k<t.vols.length;k++){const z=t.vols[k];this.volumes[z]==null||this.volumes[z].nFrame4D<2||r.push(z)}if(r.length<1)return;const n=this.volumes[r[0]].nFrame4D;if(this.graph.selectedColumn=this.volumes[r[0]].frame4D,n<2){U.debug("Unable to generate a graph: Selected volume is 3D not 4D");return}for(let k=0;k<r.length;k++){t.lines[k]=[];const z=this.frac2vox(this.scene.crosshairPos),W=this.volumes[r[k]];let j=W.nFrame4D;j=Math.min(j,n);for(let Q=0;Q<j;Q++){const pe=W.getValue(z[0],z[1],z[2],Q);t.lines[k].push(pe)}}t.lineRGB=[[.8,0,0],[0,.7,0],[0,0,.9],[.7,.7,0],[.8,0,.8],[0,.7,.7],[.6,.6,.6],[0,0,0]];let a=t.lines[0][0],o=t.lines[0][0];for(let k=0;k<t.lines.length;k++)for(let z=0;z<t.lines[k].length;z++){const W=t.lines[k][z];a=Math.min(W,a),o=Math.max(W,o)}const l=this.volumes[r[0]].cal_min,c=this.volumes[r[0]].cal_max;if(t.isRangeCalMinMax&&l<c&&isFinite(l)&&isFinite(c)&&(a=l,o=c),t.normalizeValues&&o>a){const k=o-a;for(let z=0;z<t.lines.length;z++)for(let W=0;W<t.lines[z].length;W++){const j=t.lines[z][W];t.lines[z][W]=(j-a)/k}a=0,o=1}a>=o&&(o=a+1),this.drawRect(t.LTWH,t.backColor);const[h,d,f]=Ba(a,o),u=Math.max(0,-1*Math.floor(Math.log(h)/Math.log(10)));a=Math.min(d,a),o=Math.max(f,o);function m(k){return k.toFixed(6).replace(/\.?0*$/,"")}const g=Math.min(t.LTWH[2],t.LTWH[3]);let x=16*Math.pow(g/480,.5);x<12&&(x=0);const y=x/(this.opts.textHeight*this.gl.canvas.height);let v=0,D=d;if(x>0)for(;D<=o;){const k=D.toFixed(u),z=this.textWidth(x,k);v=Math.max(z,v),D+=h}const b=.05,C=Math.abs(t.LTWH[2]),I=Math.abs(t.LTWH[3]),M=[t.LTWH[0]+b*C+v,t.LTWH[1]+b*I,t.LTWH[2]-v-2*b*C,t.LTWH[3]-x-2.5*b*I];this.graph.LTWH=t.LTWH,this.graph.plotLTWH=M,this.drawRect(M,this.opts.backColor);const T=o-a,S=M[3]/T,E=M[2]/(t.lines[0].length-1),B=M[1]+M[3];D=d+.5*h;const P=t.lineColor.slice();for(P[3]=.5*t.lineColor[3];D<=o;){const k=B-(D-a)*S;this.drawLine([M[0],k,M[0]+M[2],k],t.gridLineThickness,P),D+=h}D=d;const V=.5*t.gridLineThickness;for(;D<=o;){const k=B-(D-a)*S;this.drawLine([M[0]-V,k,M[0]+M[2]+t.gridLineThickness,k],t.gridLineThickness,t.lineColor);const z=D.toFixed(u);x>0&&this.drawTextLeft([M[0]-6,k],z,y,t.textColor),D+=h}let R=1;for(;t.lines[0].length/R>20;)R*=5;for(let k=0;k<t.lines[0].length;k+=R){const z=k*E+M[0];let W=t.gridLineThickness;if(k%2===1)W*=.5,this.drawLine([z,M[1],z,M[1]+M[3]],W,P);else{const j=m(k);x>0&&this.drawTextBelow([z,2+M[1]+M[3]],j,y,t.textColor),this.drawLine([z,M[1],z,M[1]+M[3]],W,t.lineColor)}}for(let k=0;k<t.lines.length;k++){let z=[1,0,0,t.lineAlpha];k<t.lineRGB.length&&(z=[t.lineRGB[k][0],t.lineRGB[k][1],t.lineRGB[k][2],t.lineAlpha]);for(let W=1;W<t.lines[k].length;W++){const j=(W-1)*E,Q=W*E,pe=(t.lines[k][W-1]-a)*S,Ce=(t.lines[k][W]-a)*S,Me=[M[0]+j,M[1]+M[3]-pe,M[0]+Q,M[1]+M[3]-Ce];this.drawLine(Me,t.lineThickness,z)}}if(t.selectedColumn>=0&&t.selectedColumn<t.lines[0].length){const k=t.selectedColumn*E+M[0];this.drawLine([k,M[1],k,M[1]+M[3]],t.lineThickness,[t.lineRGB[0][0],t.lineRGB[0][1],t.lineRGB[0][2],s])}x>0&&t.LTWH[1]+t.LTWH[3]>M[1]+M[3]+x*2.4&&this.drawTextBelow([M[0]+.5*M[2],M[1]+M[3]+x*1.2],"Volume",y,t.textColor),this.detectPartialllyLoaded4D()&&this.drawTextBelow([M[0]+M[2],M[1]+M[3]+x*.5],"...",y,t.textColor)}depthPicker(t,e){if(!this.uiData.mouseDepthPicker)return;this.uiData.mouseDepthPicker=!1;const i=this.gl,s=this.mousePos[0]*t[2]/t[2],r=i.canvas.height-this.mousePos[1]*t[3]/t[3]-1,n=new Uint8Array(4);if(i.readPixels(s,r,1,1,i.RGBA,i.UNSIGNED_BYTE,n),this.selectedObjectId=n[3],this.selectedObjectId===this.VOLUME_ID){this.scene.crosshairPos=new Float32Array(n.slice(0,3)).map(d=>d/255);return}const a=Gd(n);if(a>1)return;const o=(this.mousePos[0]-t[0])/t[2],l=(i.canvas.height-this.mousePos[1]-t[1])/t[3],c=zd(o,l,a,e),h=this.mm2frac(c,0,!0);h[0]<0||h[0]>1||h[1]<0||h[1]>1||h[2]<0||h[2]>1||(this.scene.crosshairPos=this.mm2frac(c,0,!0))}drawImage3D(t,e,i){if(this.volumes.length===0)return;const s=this.gl,r=this.calculateRayDirection(e,i),n=this.volumeObject3D;if(n){s.enable(s.BLEND),s.blendFunc(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA),s.enable(s.CULL_FACE),s.cullFace(s.FRONT);let a=this.renderShader;if(this.uiData.mouseDepthPicker&&(a=this.pickingImageShader),a.use(this.gl),s.uniform1i(a.uniforms.backgroundMasksOverlays,this.backgroundMasksOverlays),this.gradientTextureAmount>0){s.activeTexture(ka),s.bindTexture(s.TEXTURE_3D,this.gradientTexture);const o=this.calculateModelMatrix(e,i),l=se();Je(l,o);const c=se();rt(c,l),s.uniformMatrix4fv(a.uniforms.normMtx,!1,c)}this.drawBitmap&&this.drawBitmap.length>8?s.uniform2f(a.uniforms.renderDrawAmbientOcclusionXY,this.renderDrawAmbientOcclusion,this.drawOpacity):s.uniform2f(a.uniforms.renderDrawAmbientOcclusionXY,this.renderDrawAmbientOcclusion,0),s.uniformMatrix4fv(a.uniforms.mvpMtx,!1,t),s.uniformMatrix4fv(a.uniforms.matRAS,!1,this.back.matRAS),s.uniform3fv(a.uniforms.rayDir,r),this.gradientTextureAmount<0?s.uniform4fv(a.uniforms.clipPlane,[this.scene.crosshairPos[0],this.scene.crosshairPos[1],this.scene.crosshairPos[2],30]):s.uniform4fv(a.uniforms.clipPlane,this.scene.clipPlane),s.uniform1f(a.uniforms.drawOpacity,1),s.bindVertexArray(n.vao),s.drawElements(n.mode,n.indexCount,s.UNSIGNED_SHORT,0),s.bindVertexArray(this.unusedVAO)}}drawOrientationCube(t,e=0,i=0){if(!this.opts.isOrientCube)return;const s=.05*Math.min(t[2],t[3]);if(s<5)return;const r=this.gl;r.enable(r.CULL_FACE),r.cullFace(r.BACK),this.orientCubeShader.use(this.gl),r.bindVertexArray(this.orientCubeShaderVAO);const n=se(),a=se();fs(a,0,r.canvas.width,0,r.canvas.height,-10*s,10*s);let o=0;t[1]===0&&(o=r.canvas.height-this.effectiveCanvasHeight()),ai(n,n,[1.8*s+t[0],o+1.8*s+t[1],0]),$n(n,n,[s,s,s]),cs(n,n,It(270-i)),hs(n,n,It(-e));const l=se();Rt(l,a,n),r.uniformMatrix4fv(this.orientCubeShader.uniforms.u_matrix,!1,l),r.drawArrays(r.TRIANGLE_STRIP,0,168),r.bindVertexArray(this.unusedVAO),this.gl.disable(this.gl.CULL_FACE)}createOnLocationChange(t=NaN){const[e,i,s]=this.sceneExtentsMinMax(!0),r=Math.max(Math.max(s[0],s[1]),s[2]);function n(d){return Math.max(0,-Math.ceil(Math.log10(Math.abs(d))))}let a=n(r*.001);const o=this.frac2mm(this.scene.crosshairPos,0,!0);function l(d,f=0){return parseFloat(d.toFixed(f))}let c=l(o[0],a)+""+l(o[1],a)+""+l(o[2],a);if(this.volumes.length>0&&this.volumes[0].nFrame4D>0&&(c+=""+l(this.volumes[0].frame4D)),this.volumes.length>0){let d=" = ";for(let m=0;m<this.volumes.length;m++){const g=this.volumes[m].mm2vox(o);let p=this.volumes[m].getValue(g[0],g[1],g[2],this.volumes[m].frame4D);if(a=3,this.volumes[m].colormapLabel!==null){const A=Math.round(p);A>=0&&A<this.volumes[m].colormapLabel.labels.length?d+=this.volumes[m].colormapLabel.labels[A]:d+="undefined("+l(p,a)+")"}else d+=l(p,a);this.volumes[m].imaginary&&(p=this.volumes[m].getValue(g[0],g[1],g[2],this.volumes[m].frame4D,!0),p>=0&&(d+="+"),d+=l(p,a)),d+="   "}c+=d;const f=this.back.dimsRAS,u=f[1]*f[2]*f[3];if(this.drawBitmap&&this.drawBitmap.length===u){const m=this.frac2vox(this.scene.crosshairPos),g=m[0]+m[1]*f[1]+m[2]*f[1]*f[2];c+=" "+this.drawLut.labels[this.drawBitmap[g]]}}const h={mm:this.frac2mm(this.scene.crosshairPos,0,!0),axCorSag:t,vox:this.frac2vox(this.scene.crosshairPos),frac:this.scene.crosshairPos,xy:[this.mousePos[0],this.mousePos[1]],values:this.volumes.map(d=>{const f=this.frac2mm(this.scene.crosshairPos,0,!0),u=d.mm2vox(f),m=d.getValue(u[0],u[1],u[2],d.frame4D);return{name:d.name,value:m,id:d.id,mm:f,vox:u}}),string:c};this.onLocationChange(h)}addLabel(t,e,i,s,r){const n={textColor:this.opts.legendTextColor,textScale:1,textAlignment:"left",lineWidth:0,lineColor:this.opts.legendTextColor,lineTerminator:"none",bulletScale:0,bulletColor:this.opts.legendTextColor},a=e?{...n,...e}:{...n},o=new Bn(t,{...a},i,s,r);return this.document.labels.push(o),o}calculateScreenPoint(t,e,i){const s=Ct();return Ve(s,[...t,1],e),s[3]!==0&&(s[0]=(s[0]/s[3]+1)*.5*i[2],s[1]=(1-s[1]/s[3])*.5*i[3],s[2]/=s[3],s[0]+=i[0],s[1]+=i[1]),s}getLabelAtPoint(t){const i=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width)*1,s=this.opts.textHeight*this.gl.canvas.height*1;for(const c of this.document.labels){if(c.anchor==null||c.anchor===0)continue;const h=this.opts.textHeight*this.gl.canvas.height*c.style.textScale,d=this.textHeight(h,c.text),f=this.textWidth(h,c.text);if(!(c.anchor&1&&t[0]>f)&&!(c.anchor&2&&(t[0]<(this.gl.canvas.width-f)/2||t[0]>(this.gl.canvas.width+f)/2))&&!(c.anchor&4&&t[0]<this.gl.canvas.width-f)&&!(c.anchor&8&&(t[1]<s/2||t[1]>d+s/2))&&!(c.anchor&16&&(t[1]<(this.gl.canvas.height-d-s)/2||t[1]>(this.gl.canvas.height+d-s/2)/2))&&!(c.anchor&32&&(t[1]<this.gl.canvas.height-d-s||t[1]>this.gl.canvas.height-s/2)))return c}U.debug("screenPoint",t);const r=this.getLegendPanelHeight(),n=this.getLegendPanelWidth(),a=this.gl.canvas.width-n;let o=(this.canvas.height-r)/2;if(U.debug("panelrect",a,o,a+n,o+r),t[0]<a||t[1]<o||t[0]>a+n||t[1]>o+r)return null;const l=this.getConnectomeLabels();for(const c of l){const h=this.opts.textHeight*this.gl.canvas.height*c.style.textScale,d=this.textHeight(h,c.text);if(t[1]>=o&&t[1]<=o+d+i/2)return c;o+=d,o+=i/2}return null}drawLabelLine(t,e,i,s,r=!1){const n=Array.isArray(t.points)&&Array.isArray(t.points[0])?t.points:[t.points];for(const a of n){const o=this.calculateScreenPoint(a,i,s);r?this.drawDottedLine([...e,o[0],o[1]],t.style.lineWidth,t.style.lineColor):this.draw3DLine(e,[o[0],o[1],o[2]],t.style.lineWidth,t.style.lineColor)}}draw3DLabel(t,e,i,s,r,n,a){const o=t.text,l=e[0],c=e[1],h=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width)*1,d=this.textHeight(t.style.textScale,o)*h;if(t.style.lineWidth>0&&Array.isArray(t.points)&&this.drawLabelLine(t,[l,c+d],i,s,a),t.style.bulletScale){const m=t.style.bulletScale*d,g=d-m,p=c+g/2+m/2,A=l+(r-m)/2;this.drawCircle([A,p,m,m],t.style.bulletColor)}let f=l;if(n)if(t.style.textAlignment!=="left"){const m=this.textWidth(t.style.textScale,t.text)*h;if(t.style.textAlignment==="right")f=l+n-h*1.5-m;else{const g=n-(r||h);f+=(g-m)/2}}else f+=r;const u=t.style.textScale;this.drawText([f,c],o,u,t.style.textColor)}draw3DLabels(t,e,i=!1){const s=this.getConnectomeLabels();if(!this.opts.showLegend||s.length===0)return;if(!this.canvas)throw new Error("canvas undefined");const r=this.gl;r.disable(r.CULL_FACE),r.viewport(0,0,this.canvas.width,this.canvas.height);const n=this.getLegendPanelHeight();n>this.canvas.height&&U.debug("Legend may overflow screen size");const a=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width),o=this.getBulletMarginWidth(),l=this.getLegendPanelWidth(),c=r.canvas.width-l;let h=(this.canvas.height-n)/2;this.drawRect([r.canvas.width-l,h,l-a,n],this.opts.legendBackgroundColor);const d=r.getParameter(r.BLEND),f=r.getParameter(r.DEPTH_FUNC);i||(r.disable(r.BLEND),r.depthFunc(r.GREATER));for(const u of s){this.draw3DLabel(u,[c,h],t,e,o,l,i);const m=this.opts.textHeight*this.gl.canvas.height*u.style.textScale,g=this.textHeight(m,u.text);h+=g,h+=a/2}i||(r.depthFunc(f),d&&r.enable(r.BLEND))}drawAnchoredLabels(){const t=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width)*1,e=this.document.labels.filter(i=>i.anchor!=null&&i.anchor!==0);for(const i of e){const s=i.text,r=this.textHeight(i.style.textScale,s)*t,n=this.textWidth(i.style.textScale,s)*t;let a,o;const c=this.opts.textHeight*this.gl.canvas.height*1,h=c;let d=c/4,f=0,u=0;i.anchor&1&&(a=0),i.anchor&4&&(a=this.canvas.width-n,f-=c/4),i.anchor&2&&(a=(this.canvas.width-n)/2,f-=c/4,d+=c/4),i.anchor&8&&(o=0),i.anchor&16&&(o=(this.canvas.height-r-c)/2,u-=c/4),i.anchor&32&&(o=this.canvas.height-r-c,u-=c/4),this.drawRect([a+f,o+u,n+d,r+h],i.style.backgroundColor),this.draw3DLabel(i,[a,o])}}draw3D(t=[0,0,0,0],e=null,i=null,s=null,r=null,n=0){const a=r!==null;this.setPivot3D(),a||(r=this.scene.renderAzimuth,n=this.scene.renderElevation);const o=this.gl;e===null&&([e,i,s]=this.calculateMvpMatrix(null,t,r,n));let l=[...t];if(t[2]===0||t[3]===0?(t=[0,0,o.canvas.width,o.canvas.height],l=[...t],this.screenSlices.push({leftTopWidthHeight:t,axCorSag:4,sliceFrac:0,AxyzMxy:[],leftTopMM:[],fovMM:[Ua(i),0]})):(this.screenSlices.push({leftTopWidthHeight:t.slice(),axCorSag:4,sliceFrac:0,AxyzMxy:[],leftTopMM:[],fovMM:[Ua(i),0]}),t[1]=o.canvas.height-t[3]-t[1]),o.enable(o.DEPTH_TEST),o.depthFunc(o.ALWAYS),o.depthMask(!0),o.clearDepth(0),this.draw3DLabels(e,l,!1),o.viewport(t[0],t[1],t[2],t[3]),this.volumes.length>0&&(this.updateInterpolation(0,!0),this.updateInterpolation(1,!0),this.drawImage3D(e,r,n)),this.updateInterpolation(0),this.updateInterpolation(1),a||this.drawCrosshairs3D(!0,1,e),this.drawMesh3D(!0,1,e,i,s),this.uiData.mouseDepthPicker){this.depthPicker(t,e),this.createOnLocationChange(),this.draw3D(t,e,i,s,r,n);return}this.opts.meshXRay>0&&this.drawMesh3D(!1,this.opts.meshXRay,e,i,s),this.draw3DLabels(e,l,!1),o.viewport(t[0],t[1],t[2],t[3]),a||this.drawCrosshairs3D(!1,.15,e),o.viewport(0,0,o.canvas.width,o.canvas.height),this.drawOrientationCube(t,r,n);const c="azimuth: "+this.scene.renderAzimuth.toFixed(0)+" elevation: "+this.scene.renderElevation.toFixed(0);return this.readyForSync=!0,this.sync(),this.draw3DLabels(e,l,!0),c}drawMesh3D(t=!0,e=1,i,s,r){if(this.meshes.length<1)return;const n=this.gl;i||([i,s,r]=this.calculateMvpMatrix(this.volumeObject3D,void 0,this.scene.renderAzimuth,this.scene.renderElevation)),n.enable(n.DEPTH_TEST),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.disable(n.BLEND),n.depthFunc(n.GREATER),n.disable(n.CULL_FACE),t?n.depthFunc(n.GREATER):(n.enable(n.BLEND),n.depthFunc(n.ALWAYS),n.enable(n.CULL_FACE)),n.cullFace(n.BACK);let a=this.meshShaders[0].shader,o=!1;for(let l=0;l<this.meshes.length;l++){if(this.meshes[l].visible===!1||this.meshes[l].opacity<=0)continue;let c=e;if(t&&(c=this.meshes[l].opacity,n.depthFunc(n.GREATER),n.depthMask(!0),c<1?(n.depthMask(!1),n.enable(n.DEPTH_TEST),n.enable(n.BLEND),n.cullFace(n.BACK),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA)):(n.enable(n.DEPTH_TEST),n.disable(n.BLEND))),a=this.meshShaders[this.meshes[l].meshShaderIndex].shader,this.uiData.mouseDepthPicker&&(a=this.pickingMeshShader),a.use(this.gl),n.uniformMatrix4fv(a.uniforms.mvpMtx,!1,i),n.uniformMatrix4fv(a.uniforms.normMtx,!1,r),n.uniform1f(a.uniforms.opacity,c),!(this.meshes[l].indexCount<3)){if(this.meshes[l].offsetPt0&&(this.meshes[l].fiberSides<3||this.meshes[l].fiberRadius<=0)){o=!0;continue}a.isMatcap&&(n.activeTexture(Na),n.bindTexture(n.TEXTURE_2D,this.matCapTexture)),n.bindVertexArray(this.meshes[l].vao),n.drawElements(n.TRIANGLES,this.meshes[l].indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)}}if(n.depthMask(!0),!o){n.enable(n.BLEND),n.depthFunc(n.ALWAYS);return}a=this.fiberShader,a.use(this.gl),n.uniformMatrix4fv(a.uniforms.mvpMtx,!1,i),n.uniform1f(a.uniforms.opacity,e);for(let l=0;l<this.meshes.length;l++)this.meshes[l].indexCount<3||this.meshes[l].offsetPt0&&(this.meshes[l].fiberSides>=3&&this.meshes[l].fiberRadius>0||(n.bindVertexArray(this.meshes[l].vaoFiber),n.drawElements(n.LINE_STRIP,this.meshes[l].indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)));n.enable(n.BLEND),n.depthFunc(n.ALWAYS),this.readyForSync=!0}drawCrosshairs3D(t=!0,e=1,i=null,s=!1,r=!0){var u,m;if(!this.opts.show3Dcrosshair&&!s||this.opts.crosshairWidth<=0&&s)return;const n=this.gl,a=this.frac2mm(this.scene.crosshairPos,0,r);let o=1;const[l,c,h]=this.sceneExtentsMinMax(r);if(this.volumes.length>0){if(!this.back)throw new Error("back undefined");o=.5*Math.min(Math.min(this.back.pixDims[1],this.back.pixDims[2]),this.back.pixDims[3])}else(h[0]<50||h[0]>1e3)&&(o=h[0]*.02);if(o*=this.opts.crosshairWidth,((u=this.opts)==null?void 0:u.crosshairWidthUnit)==="percent"&&(o=h[0]*this.opts.crosshairWidth*.5*.01),((m=this.opts)==null?void 0:m.crosshairWidthUnit)==="mm"&&(o=this.opts.crosshairWidth*.5),(this.crosshairs3D===null||this.crosshairs3D.mm[0]!==a[0]||this.crosshairs3D.mm[1]!==a[1]||this.crosshairs3D.mm[2]!==a[2])&&(this.crosshairs3D!==null&&(n.deleteBuffer(this.crosshairs3D.indexBuffer),n.deleteBuffer(this.crosshairs3D.vertexBuffer)),this.crosshairs3D=Zt.generateCrosshairs(this.gl,1,a,l,c,o,20,this.opts.crosshairGap),this.crosshairs3D.mm=a),!this.surfaceShader)throw new Error("surfaceShader undefined");const d=this.surfaceShader;d.use(this.gl),i==null&&([i]=this.calculateMvpMatrix(this.crosshairs3D,void 0,this.scene.renderAzimuth,this.scene.renderElevation)),n.uniformMatrix4fv(d.uniforms.mvpMtx,!1,i),n.disable(n.CULL_FACE),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.crosshairs3D.indexBuffer),n.enable(n.DEPTH_TEST);const f=[...this.opts.crosshairColor];t?(n.disable(n.BLEND),n.depthFunc(n.GREATER)):(n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.ALWAYS)),f[3]=e,n.uniform4fv(d.uniforms.surfaceColor,f),n.bindVertexArray(this.crosshairs3D.vao),n.drawElements(n.TRIANGLES,this.crosshairs3D.indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)}mm2frac(t,e=0,i=!1){if(this.volumes.length<1){const s=H(.1,.5,.5),[r,n,a]=this.sceneExtentsMinMax();return s[0]=(t[0]-r[0])/a[0],s[1]=(t[1]-r[1])/a[1],s[2]=(t[2]-r[2])/a[2],isFinite(s)||(isFinite(s[0])||(s[0]=.5),isFinite(s[1])||(s[1]=.5),isFinite(s[2])||(s[2]=.5),this.meshes.length<1&&U.error("mm2frac() not finite: objects not (yet) loaded.")),s}return this.volumes[e].convertMM2Frac(t,i||this.opts.isSliceMM)}vox2frac(t,e=0){return this.volumes[e].convertVox2Frac(t)}frac2vox(t,e=0){return this.volumes.length<=e?[0,0,0]:this.volumes[e].convertFrac2Vox(t)}moveCrosshairInVox(t,e,i){const s=this.frac2vox(this.scene.crosshairPos),r=s[2];s[0]+=t,s[1]+=e,s[2]+=i,s[0]=Mr(s[0],0,this.volumes[0].dimsRAS[1]-1),s[1]=Mr(s[1],0,this.volumes[0].dimsRAS[2]-1),s[2]=Mr(s[2],0,this.volumes[0].dimsRAS[3]-1),this.scene.crosshairPos=this.vox2frac(s),this.createOnLocationChange(),this.opts.is2DSliceShader&&r!==s[2]&&(this.updateGLVolume(),this.refreshDrawing(!1)),this.drawScene()}frac2mm(t,e=0,i=!1){const s=ue(t[0],t[1],t[2],1);if(this.volumes.length>0)return this.volumes[e].convertFrac2MM(t,i||this.opts.isSliceMM);{const[r,n]=this.sceneExtentsMinMax(),a=(o,l,c)=>o*(1-c)+l*c;s[0]=a(r[0],n[0],t[0]),s[1]=a(r[1],n[1],t[1]),s[2]=a(r[2],n[2],t[2])}return s}screenXY2TextureFrac(t,e,i,s=!0){const r=H(-1,-1,-1),n=this.screenSlices[i].axCorSag;if(n>2)return r;const a=this.screenSlices[i].leftTopWidthHeight.slice();let o=!1;a[2]<0&&(o=!0,a[0]+=a[2],a[2]=-a[2]);let l=(t-a[0])/a[2];o&&(l=1-l);const c=1-(e-a[1])/a[3];if(l<0||l>1||c<0||c>1||this.screenSlices[i].AxyzMxy.length<4)return r;let h=H(0,0,0);h[0]=this.screenSlices[i].leftTopMM[0]+l*this.screenSlices[i].fovMM[0],h[1]=this.screenSlices[i].leftTopMM[1]+c*this.screenSlices[i].fovMM[1];const d=this.screenSlices[i].AxyzMxy;h[2]=d[2]+d[4]*(h[1]-d[1])-d[3]*(h[0]-d[0]),n===1&&(h=Ge(h,[0,2,1])),n===2&&(h=Ge(h,[2,0,1]));const f=this.mm2frac(h);return s&&(f[0]<0||f[0]>1||f[1]<0||f[1]>1||f[2]<0||f[2]>1)?r:f}canvasPos2frac(t){for(let e=0;e<this.screenSlices.length;e++){const i=this.screenXY2TextureFrac(t[0],t[1],e);if(i[0]>=0)return i}return[-1,-1,-1]}scaleSlice(t,e,i=[0,0],s=[0,0]){const r=s[0]===0?this.effectiveCanvasWidth()-i[0]:s[0]-i[0],n=s[1]===0?this.effectiveCanvasHeight()-i[1]:s[1]-i[1];let a=r/t;e*a>n&&(a=n/e);const o=t*a,l=e*a;return[(r-o)*.5,(n-l)*.5,o,l,a]}drawThumbnail(){if(!this.bmpShader)throw new Error("bmpShader undefined");this.bmpShader.use(this.gl),this.gl.uniform2f(this.bmpShader.uniforms.canvasWidthHeight,this.gl.canvas.width,this.gl.canvas.height);let t=this.gl.canvas.height,e=this.gl.canvas.height*this.bmpTextureWH;e>this.gl.canvas.width&&(t=this.gl.canvas.width/this.bmpTextureWH,e=this.gl.canvas.width);const i=(this.gl.canvas.width-e)/2,s=(this.gl.canvas.height-t)/2;this.gl.uniform4f(this.bmpShader.uniforms.leftTopWidthHeight,i,s,e,t),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawLine(t,e=1,i=[1,0,0,-1]){if(this.gl.bindVertexArray(this.genericVAO),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl),i[3]<0&&(i=this.opts.crosshairColor),this.gl.uniform4fv(this.lineShader.uniforms.lineColor,i),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,e),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,t),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}draw3DLine(t,e,i=1,s=[1,0,0,-1]){if(this.gl.bindVertexArray(this.genericVAO),!this.line3DShader)throw new Error("line3DShader undefined");this.line3DShader.use(this.gl),s[3]<0&&(s=this.opts.crosshairColor),this.gl.uniform4fv(this.line3DShader.uniforms.lineColor,s),this.gl.uniform2fv(this.line3DShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.line3DShader.uniforms.thickness,i),this.gl.uniform2fv(this.line3DShader.uniforms.startXY,t),this.gl.uniform3fv(this.line3DShader.uniforms.endXYZ,e),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawDottedLine(t,e=1,i=[1,0,0,-1]){if(this.gl.bindVertexArray(this.genericVAO),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl);const s=i[3]<0?[...this.opts.crosshairColor]:[...i];s[3]=.3;const r=sa(t[2]-t[0],t[3]-t[1]),n=ra(r);Fc(r,r);const o=this.opts.textHeight*Math.min(this.gl.canvas.height,this.gl.canvas.width)*1;Ic(r,r,o/2);const l=ra(r);let c=Math.floor(n/l);n%l&&c++;const h=[t[0],t[1]];this.gl.uniform4fv(this.lineShader.uniforms.lineColor,s),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,e);for(let d=0;d<c-1;d++){if(d%2){h[0]+=r[0],h[1]+=r[1];continue}const f=[h[0],h[1],h[0]+r[0],h[1]+r[1]];this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,f),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),h[0]+=r[0],h[1]+=r[1]}this.gl.bindVertexArray(this.unusedVAO)}drawGraphLine(t,e=[1,0,0,.5],i=2){this.drawLine(t,i,e)}drawCrossLinesMM(t,e,i,s,r){if(t<0||this.screenSlices.length<=t)return;const n=this.screenSlices[t];let a=n.sliceFrac;a===1/0&&U.debug("Rendering approximate cross lines in world view mode"),a===1/0&&(a=.5);let l=s.slice(),c=r.slice();const h=Math.max(1,this.opts.crosshairWidth);e===1&&(l=i.slice()),e===2&&(l=i.slice(),c=s.slice());function d(f){const u=sa(0,0);return u[0]=n.leftTopWidthHeight[0]+(f[0]-n.leftTopMM[0])/n.fovMM[0]*n.leftTopWidthHeight[2],u[1]=n.leftTopWidthHeight[1]+n.leftTopWidthHeight[3]-(f[1]-n.leftTopMM[1])/n.fovMM[1]*n.leftTopWidthHeight[3],u}if(l.length>0&&e===0){const f=a,u=1;for(let m=0;m<l.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=l[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([0,p,f]);A=Ge(A,[0,1,2]);let w=this.frac2mm([1,p,f]);w=Ge(w,[0,1,2]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}if(l.length>0&&e===1){const f=a,u=2;for(let m=0;m<l.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=l[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([0,f,p]);A=Ge(A,[0,2,1]);let w=this.frac2mm([1,f,p]);w=Ge(w,[0,2,1]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}if(l.length>0&&e===2){const f=a,u=2;for(let m=0;m<l.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=l[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([f,0,p]);A=Ge(A,[1,2,0]);let w=this.frac2mm([f,1,p]);w=Ge(w,[1,2,0]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}if(c.length>0&&e===0){const f=a,u=0;for(let m=0;m<c.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=c[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([p,0,f]);A=Ge(A,[0,1,2]);let w=this.frac2mm([p,1,f]);w=Ge(w,[0,1,2]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}if(c.length>0&&e===1){const f=a,u=0;for(let m=0;m<c.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=c[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([p,f,0]);A=Ge(A,[0,2,1]);let w=this.frac2mm([p,f,1]);w=Ge(w,[0,2,1]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}if(c.length>0&&e===2){const f=a,u=1;for(let m=0;m<c.length;m++){const g=this.frac2mm([.5,.5,.5]);g[u]=c[m];let p=this.mm2frac(g);p=p[u];let A=this.frac2mm([f,p,0]);A=Ge(A,[1,2,0]);let w=this.frac2mm([f,p,1]);w=Ge(w,[1,2,0]),A=d(A),w=d(w),this.drawLine([A[0],A[1],w[0],w[1]],h)}}}drawCrossLines(t,e,i,s,r){if(t<0||this.screenSlices.length<=t)return;if(this.opts.isSliceMM)return this.drawCrossLinesMM(t,e,i,s,r);if(this.screenSlices[t].sliceFrac===1/0)return this.drawCrossLinesMM(t,e,i,s,r);const n=this.screenSlices[t];let a=s.slice(),o=r.slice();if(e===1&&(a=i.slice()),e===2&&(a=i.slice(),o=s.slice()),a.length>0){const l=n.leftTopWidthHeight.slice();let c=2;e===0&&(c=1);const h=this.frac2mm([.5,.5,.5]);for(let d=0;d<a.length;d++){h[c]=a[d];const f=this.mm2frac(h);this.drawRect([l[0],l[1]+l[3]-f[c]*l[3],l[2],1])}}if(o.length>0){const l=n.leftTopWidthHeight.slice(),c=n.fovMM[0]<0;let h=0;e===2&&(h=1);const d=this.frac2mm([.5,.5,.5]);for(let f=0;f<o.length;f++){d[h]=o[f];const u=this.mm2frac(d);c?this.drawRect([l[0]+(l[2]-u[h]*l[2]),l[1],1,l[3]]):this.drawRect([l[0]+u[h]*l[2],l[1],1,l[3]])}}}drawMosaic(t){var f;this.screenSlices=[];const e=this.screenFieldOfViewMM(0,!0),i=this.screenFieldOfViewMM(0);t=t.replaceAll(";"," ;").trim();const s=[],r=[],n=[],a=t.split(/\s+/);let o=1;const l=this.opts.textHeight;let c=0,h=0,d=0;(f=this.volumes[0])!=null&&f.dims||(d=Math.ceil(this.opts.tileMargin*.3));for(let u=0;u<2;u++){let m=!1,g=!1;m=!1;let p=0,A=0,w=0,x=0,y=!1,v=0,D=0,b=0,C=0;for(let T=0;T<a.length;T++){const S=a[T];if(S.includes("X")){g=!0;continue}if(S.includes("L")){y=!S.includes("-");continue}if(S.includes("H")){T++,D=Math.max(0,Math.min(1,parseFloat(a[T]))),D=Math.abs(D);continue}if(S.includes("V")){T++;continue}if(S.includes("A")){v=0;continue}if(S.includes("C")){v=1;continue}if(S.includes("S")){v=2;continue}if(S.includes("R")){m=!0;continue}S.includes(";")&&(w+=p,x=Math.max(x,A+b),p=0,A=0),C=b,D>0&&!m&&(C=Math.round(C*(1-D))),U.debug(`slice ${T} width with overlap ${C} pixels`),A+=C,C=0;const E=parseFloat(S);if(isNaN(E))continue;let B=0,P=i;if(m&&(P=e),v===2?C=P[1]:C=P[0],v===0?B=P[1]:B=P[2],u===0)m||(v===0&&s.push(E),v===1&&r.push(E),v===2&&n.push(E));else{const V=[c+o*A,h+o*w,o*C,o*B];if(this.opts.textHeight=y?l:0,m){let R=E<0?-1/0:1/0;Object.is(E,-0)&&(R=-1/0),this.draw2D(V,v,R)}else this.draw2D(V,v,E);g&&this.drawCrossLines(this.screenSlices.length-1,v,s,r,n),m=!1,g=!1}b=C,A+=d,p=Math.max(p,B)}if(w+=p,x=Math.max(x,A+b),x<=0||w<=0)break;const I=(this.gl.canvas.width-2*this.opts.tileMargin-d)/x,M=(this.effectiveCanvasHeight()-2*this.opts.tileMargin)/w;o=Math.min(I,M),this.opts.centerMosaic?(c=Math.floor(.5*(this.gl.canvas.width-x*o)),h=Math.floor(.5*(this.effectiveCanvasHeight()-w*o))):(c=this.opts.tileMargin,h=this.opts.tileMargin)}this.opts.textHeight=l}calculateWidthHeight(t,e,i,s){let r,n;switch(t){case 0:r=e[0],n=e[1];break;case 1:r=e[0],n=e[2];break;case 2:r=e[1],n=e[2];break;default:return[i,s]}const a=r/n,o=i/s;let l,c;return a>o?(l=i,c=i/a):(c=s,l=s*a),[l,c]}drawSceneCore(){var r,n,a;if(!this.initialized)return;if(this.colorbarHeight=0,this.gl.clearColor(this.opts.backColor[0],this.opts.backColor[1],this.opts.backColor[2],this.opts.backColor[3]),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.bmpTexture&&this.thumbnailVisible){this.drawThumbnail();return}let t="";if(this.volumes.length===0||typeof this.volumes[0].dims>"u"){if(this.meshes.length>0){if(this.sliceMosaicString.length>0){this.opts.isColorbar&&this.reserveColorbarPanel(),this.drawMosaic(this.sliceMosaicString),this.opts.isColorbar&&this.drawColorbar();return}this.screenSlices=[],this.draw3D(),this.opts.isColorbar&&this.drawColorbar();return}this.drawLoadingText(this.opts.loadingText);return}if(this.uiData.isDragging&&this.scene.clipPlaneDepthAziElev[0]<1.8&&this.inRenderTile(this.uiData.dragStart[0],this.uiData.dragStart[1])>=0){const o=this.uiData.dragStart[0]-this.uiData.dragEnd[0],l=this.uiData.dragStart[1]-this.uiData.dragEnd[1],c=this.uiData.dragClipPlaneStartDepthAziElev.slice();if(c[1]-=o,c[1]=c[1]%360,c[2]+=l,c[1]!==this.scene.clipPlaneDepthAziElev[1]||c[2]!==this.scene.clipPlaneDepthAziElev[2])return this.scene.clipPlaneDepthAziElev=c,this.setClipPlane(this.scene.clipPlaneDepthAziElev)}if(this.sliceMosaicString.length<1&&this.opts.sliceType===4){this.opts.isColorbar&&this.reserveColorbarPanel(),this.screenSlices=[],this.draw3D(),this.opts.isColorbar&&this.drawColorbar();return}this.opts.isColorbar&&this.reserveColorbarPanel();const e=this.getMaxVols(),i=this.opts.sliceType===3&&e>1&&this.graph.autoSizeMultiplanar&&this.graph.opacity>0;if(this.sliceMosaicString.length>0)this.drawMosaic(this.sliceMosaicString);else{const o=[0,0];let l=!1;if(this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.screenSlices=[],this.customLayout&&this.customLayout.length>0){this.screenSlices=[],this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height);const{volScale:c}=this.sliceScale(),h=[this.effectiveCanvasWidth(),this.effectiveCanvasHeight()];for(const d of this.customLayout){const{sliceType:f,position:u,sliceMM:m}=d,g=u.slice();if(u[0]>=0&&u[0]<=1&&u[2]<=1&&(g[0]=u[0]*h[0],g[2]=u[2]*h[0]),u[1]>=0&&u[1]<=1&&u[3]<=1&&(g[1]=u[1]*h[1],g[3]=u[3]*h[1]),g[0]+g[2]>h[0]&&(U.warn("adjusting slice width because it would have been clipped"),g[2]=h[0]-g[0]),g[1]+g[3]>h[1]&&(U.warn("adjusting slice height because it would have been clipped"),g[3]=h[1]-g[1]),f===4)this.draw3D(g);else if(f===0||f===1||f===2){const p=this.calculateWidthHeight(f,c,g[2],g[3]);this.draw2D(g,f,m??NaN,p)}}}else if(this.opts.sliceType===0)this.draw2D([0,0,0,0],0);else if(this.opts.sliceType===1)this.draw2D([0,0,0,0],1);else if(this.opts.sliceType===2)this.draw2D([0,0,0,0],2);else{let c=function(k,z){return[(k-1)*m+k*g,(z-1)*m+z*g]},h=!1;this.opts.multiplanarForceRender?(h=!0,this.opts.multiplanarForceRender?this.opts.multiplanarShowRender=1:this.opts.multiplanarShowRender=2,delete this.opts.multiplanarForceRender):this.opts.multiplanarShowRender===1&&(h=!0);const d=isFinite(this.drawPenLocation[0])&&this.opts.drawingEnabled,{volScale:f}=this.sliceScale(),u=f.slice();this.opts.multiplanarEqualSize&&(f[0]=1,f[1]=1,f[2]=1),typeof this.opts.multiplanarPadPixels!="number"&&U.debug("multiplanarPadPixels must be numeric");const m=parseFloat(`${this.opts.multiplanarPadPixels}`);let g=this.opts.tileMargin;g<0&&(g=2*(2+Math.ceil(Math.max(this.opts.textHeight,.01)*Math.min(this.gl.canvas.height,this.gl.canvas.width))));let p=[this.effectiveCanvasWidth(),this.effectiveCanvasHeight()];this.opts.heroImageFraction>0&&this.opts.heroImageFraction<1&&(h=!1,l=!0,p[0]>p[1]&&this.opts.multiplanarLayout!==3?o[0]=p[0]*this.opts.heroImageFraction:o[1]=p[1]*this.opts.heroImageFraction,p=[p[0]-o[0],p[1]-o[1]]);const A=this.scaleSlice(f[0]+f[1],f[1]+f[2],c(2,2),p),w=Math.max(Math.max(f[1],f[2]),f[0]),x=this.scaleSlice(f[0]+f[0]+f[1],Math.max(f[1],f[2]),c(3,1),p),y=this.scaleSlice(f[0]+f[0]+f[1]+w,Math.max(f[1],f[2]),c(4,1),p),v=this.scaleSlice(w,f[1]+f[2]+f[2],c(1,3),p),D=this.scaleSlice(w,f[1]+f[2]+f[2]+w,c(1,4),p);let b=!d&&(e<2||!i),C=!1,I=!1,M=!1;this.opts.multiplanarLayout===1?C=!0:this.opts.multiplanarLayout===2?I=!0:this.opts.multiplanarLayout===3?M=!0:v[4]>x[4]&&v[4]>A[4]?C=!0:x[4]>A[4]?M=!0:I=!0;let T=A;if(C?(T=v,!l&&(h||this.opts.multiplanarShowRender===2&&D[4]>=v[4])?T=D:b=!1):M&&(T=x,!l&&(h||this.opts.multiplanarShowRender===2&&y[4]>=x[4])?T=y:b=!1),l){const k=o[0]===0?this.effectiveCanvasWidth():o[0],z=o[1]===0?this.effectiveCanvasHeight():o[1];if(((r=this.opts)==null?void 0:r.heroSliceType)===0||((n=this.opts)==null?void 0:n.heroSliceType)===1||((a=this.opts)==null?void 0:a.heroSliceType)===2)this.draw2D([0,0,k,z],this.opts.heroSliceType,NaN,[1/0,1/0]);else{const W=T.slice(),j=this.effectiveCanvasWidth();k===j&&(W[0]=0),this.draw3D([W[0],0,k,z])}T[0]+=o[0],T[1]+=o[1],b=!1}const S=f[0]*T[4]+g,E=f[1]*T[4]+g,B=f[2]*T[4]+g,P=u[0]*T[4],V=u[1]*T[4],R=u[2]*T[4];if(C){if(this.draw2D([T[0],T[1],S,E],0,NaN,[P,V]),this.draw2D([T[0],T[1]+E+m,S,B],1,NaN,[P,R]),this.draw2D([T[0],T[1]+E+m+B+m,E,B],2,NaN,[V,R]),b){const k=w*T[4];this.draw3D([T[0],T[1]+E+B+B+m*3,k,k])}}else if(M){if(this.draw2D([T[0],T[1],S,E],0,NaN,[P,V]),this.draw2D([T[0]+S+m,T[1],S,B],1,NaN,[P,R]),this.draw2D([T[0]+S+S+m*2,T[1],E,B],2,NaN,[V,R]),b){const k=w*T[4];this.draw3D([T[0]+S+S+E+m*3,T[1],k,k])}}else I&&(h||(b=!1),this.opts.multiplanarShowRender===2&&(b=!0),l&&(b=!1),this.draw2D([T[0],T[1]+B+m,S,E],0,NaN,[P,V]),this.draw2D([T[0],T[1],S,B],1,NaN,[P,R]),this.draw2D([T[0]+S+m,T[1],E,B],2,NaN,[V,R]),b&&this.draw3D([T[0]+S+m,T[1]+B+m,E,E]))}}if(this.opts.isRuler&&this.drawRuler(),this.opts.isColorbar&&this.drawColorbar(),i&&this.drawGraph(),this.uiData.isDragging){if(this.uiData.mouseButtonCenterDown){this.dragForCenterButton([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);return}if(this.opts.dragMode===4){this.dragForSlicer3D([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);return}if(this.opts.dragMode===3){this.dragForPanZoom([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);return}if(this.inRenderTile(this.uiData.dragStart[0],this.uiData.dragStart[1])>=0)return;if(this.opts.dragMode===2){this.drawMeasurementTool([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);return}const o=Math.abs(this.uiData.dragStart[0]-this.uiData.dragEnd[0]),l=Math.abs(this.uiData.dragStart[1]-this.uiData.dragEnd[1]);this.drawSelectionBox([Math.min(this.uiData.dragStart[0],this.uiData.dragEnd[0]),Math.min(this.uiData.dragStart[1],this.uiData.dragEnd[1]),o,l]);return}const s=this.frac2mm([this.scene.crosshairPos[0],this.scene.crosshairPos[1],this.scene.crosshairPos[2]]);return t=s[0].toFixed(2)+""+s[1].toFixed(2)+""+s[2].toFixed(2),this.readyForSync=!0,this.sync(),this.drawAnchoredLabels(),t}drawScene(){if(this.isBusy){this.needsRefresh=!0;return}this.isBusy=!1,this.needsRefresh=!1;let t=this.drawSceneCore();return this._gl!==null&&this.gl.finish(),this.needsRefresh&&(t=this.drawScene()),t}get gl(){if(!this._gl)throw new Error("unable to get WebGL context. Maybe the browser doesn't support WebGL2.");return this._gl}set gl(t){this._gl=t}};const eu={batchSize:1,numOfChan:1,isColorEnable:!0,isAutoColors:!0,bgLabelValue:0,drawBoundingVolume:!1,isGPU:!0,isBrainCropMaskBased:!0,showPhase1Output:!1,isPostProcessEnable:!0,isContoursViewEnable:!1,browserArrayBufferMaxZDim:30,telemetryFlag:!1,chartXaxisStepPercent:10,uiSampleName:"BC_UI_Sample",atlasSelectedColorTable:"Fire"},ws=[{id:1,type:"Segmentation",path:"/models/model5_gw_ae/model.json",modelName:" Tissue GWM (light)",labelsPath:"./models/model5_gw_ae/labels.json",colorsPath:"./models/model5_gw_ae/colorLUT.json",colormapPath:"./models/model5_gw_ae/colormap3.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the subvolume model."},{id:2,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:" Tissue GWM (High Acc)",labelsPath:"./models/model20chan3cls/labels.json",colorsPath:"./models/model20chan3cls/colorLUT.json",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides the best accuracy with hard cropping for better speed"},{id:3,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:" Tissue GWM (High Acc, Low Mem)",labelsPath:"./models/model20chan3cls/labels.json",colorsPath:"./models/model20chan3cls/colorLUT.json",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides high accuracy and fit low memory available but slower"},{id:4,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:" Subcortical + GWM (High Mem, Fast)",labelsPath:"./models/model30chan18cls/labels.json",colorsPath:"./models/model30chan18cls/colorLUT.json",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:5,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:" Subcortical + GWM (Low Mem, Slow)",labelsPath:"./models/model30chan18cls/labels.json",colorsPath:"./models/model30chan18cls/colorLUT.json",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:6,type:"Atlas",path:"/models/model18cls/model.json",modelName:" Subcortical + GWM (Low Mem, Faster)",labelsPath:"./models/model18cls/labels.json",colorsPath:"./models/model18cls/colorLUT.json",colormapPath:"./models/model18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:7,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:" Subcortical + GWM (Failsafe, Less Acc)",labelsPath:"./models/model30chan18cls/labels.json",colorsPath:"./models/model30chan18cls/colorLUT.json",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is not a robust model, it may work on low data quality, including varying saturation, and even clinical scans. It may work also on infant brains, but your mileage may vary."},{id:8,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:" Aparc+Aseg 50 (High Mem, Fast)",labelsPath:"./models/model30chan50cls/labels.json",colorsPath:"./models/model30chan50cls/colorLUT.json",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class."},{id:9,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:" Aparc+Aseg 50 (Low Mem, Slow)",labelsPath:"./models/model30chan50cls/labels.json",colorsPath:"./models/model30chan50cls/colorLUT.json",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time."},{id:10,type:"Brain_Extraction",path:"/models/model5_gw_ae/model.json",modelName:" Extract the Brain (FAST)",labelsPath:null,colorsPath:null,preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Extract the brain fast model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the failsafe version."},{id:11,type:"Brain_Extraction",path:"/models/model11_gw_ae/model.json",modelName:" Extract the Brain (High Acc, Slow)",labelsPath:null,colorsPath:null,preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on full T1 image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."},{id:12,type:"Brain_Masking",path:"/models/model5_gw_ae/model.json",modelName:" Brain Mask (FAST)",labelsPath:null,colorsPath:null,colormapPath:"./models/model5_gw_ae/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:17,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"This fast masking model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than failsafe version."},{id:13,type:"Brain_Masking",path:"/models/model11_gw_ae/model.json",modelName:" Brain Mask (High Acc, Low Mem)",labelsPath:null,colorsPath:null,preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This masking model operates on full T1 image in a single pass, but uses 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than fast version."},{id:14,type:"Atlas",path:"/models/model21_104class/model.json",modelName:" Aparc+Aseg 104 (High Mem, Fast)",labelsPath:"./models/model21_104class/labels.json",colorsPath:"./models/model21_104class/colorLUT.json",colormapPath:"./models/model21_104class/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions."},{id:15,type:"Atlas",path:"/models/model21_104class/model.json",modelName:" Aparc+Aseg 104 (Low Mem, Slow)",labelsPath:"./models/model21_104class/labels.json",colorsPath:"./models/model21_104class/colorLUT.json",colormapPath:"./models/model21_104class/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time. "}];function tu(t){return new Worker(""+new URL("brainchop-webworker-B0h0kbHS.js",import.meta.url).href,{name:t==null?void 0:t.name})}var iu={bptfm:{args:["hp","lp"],help:"Same as bptf but does not remove mean (emulates fslmaths < 5.0.7)"},bwlabel:{args:["conn"],help:"Connected component labelling for non-zero voxels (conn sets neighbors: 6, 18, 26)"},c2h:{args:[],help:"reverse h2c transform"},ceil:{args:[],help:"round voxels upwards to the nearest integer"},ras:{args:[],help:"reorder and flip dimensions to RAS orientation"},conform:{args:[],help:"reslice to 1mm size in coronal slice direction with 256^3 voxels"},comply:{args:["nx","ny","nz","dx","dy","dz","f_high","isLinear"],help:"conform to axial slice with dx*dy*dzmm size and dx*dy*dz voxels. f_high bright clamping (0.98 for top 2%). Linear (1) or nearest-neighbor (0)"},crop:{args:["tmin","tsize"],help:"remove volumes, starts with 0 not 1! Inputting -1 for a size will set it to the full range"},dehaze:{args:["mode"],help:"set dark voxels to zero (mode 1..5; higher yields more surviving voxels)"},detrend:{args:[],help:"remove linear trend (and mean) from input"},demean:{args:[],help:"remove average signal across volumes (requires 4D input)"},edt:{args:[],help:"estimate Euler Distance Transform (distance field). Assumes isotropic input"},close:{args:["thr","dx1","dx2"],help:"morphological close that binarizes with `thr`, dilates with `dx1` and erodes with `dx2` (fills bubbles with `thr`)"},floor:{args:[],help:"round voxels downwards to the nearest integer"},gz:{args:["mode"],help:"NIfTI gzip mode (0=uncompressed, 1=compressed, else FSL environment; default -1)"},h2c:{args:[],help:"convert CT scans from 'Hounsfield' to 'Cormack' units to emphasize soft tissue contrast"},mesh:{args:[],help:"meshify requires 'd'ark, 'm'edium, 'b'right or numeric isosurface ('niimath bet -mesh -i d mesh.gii')",subOperations:{i:{args:["isovalue"],help:"'d'ark, 'm'edium, 'b'right or numeric isosurface"},a:{args:["atlasFile"],help:"roi based atlas to mesh"},b:{args:["fillBubbles"],help:"fill bubbles"},l:{args:["onlyLargest"],help:"only largest"},o:{args:["originalMC"],help:"original marching cubes"},q:{args:["quality"],help:"quality"},s:{args:["postSmooth"],help:"post smooth"},r:{args:["reduceFraction"],help:"reduce fraction"},v:{args:["verbose"],help:"verbose"}}},hollow:{args:["threshold","thickness"],help:"hollow out a mesh"},mod:{args:[],help:"modulus fractional remainder - same as '-rem' but includes fractions"},otsu:{args:["mode"],help:"binarize image using Otsu's method (mode 1..5; higher yields more bright voxels)"},power:{args:["exponent"],help:"raise the current image by following exponent"},qform:{args:["code"],help:"set qform_code"},sform:{args:["code"],help:"set sform_code"},p:{args:["threads"],help:"set maximum number of parallel threads. DISABLED: recompile for OpenMP support"},resize:{args:["X","Y","Z","m"],help:"grow (>1) or shrink (<1) image. Method <m> (0=nearest,1=linear,2=spline,3=Lanczos,4=Mitchell)"},round:{args:[],help:"round voxels to the nearest integer"},sobel:{args:[],help:"fast edge detection"},sobel_binary:{args:[],help:"sobel creating binary edge"},tensor_2lower:{args:[],help:"convert FSL style upper triangle image to NIfTI standard lower triangle order"},tensor_2upper:{args:[],help:"convert NIfTI standard lower triangle image to FSL style upper triangle order"},tensor_decomp_lower:{args:[],help:"as tensor_decomp except input stores lower diagonal (AFNI, ANTS, Camino convention)"},trunc:{args:[],help:"truncates the decimal value from floating point value and returns integer value"},unsharp:{args:["sigma","scl"],help:"edge enhancing unsharp mask (sigma in mm, not voxels [1 is typical]; scl is amount [0.5 medium, 1.0 heavy])"},dog:{args:["sPos","sNeg"],help:"difference of gaussian with zero-crossing edges (positive and negative sigma mm)"},dogr:{args:["sPos","sNeg"],help:"as dog, without zero-crossing (raw rather than binarized data)"},dogx:{args:["sPos","sNeg"],help:"as dog, zero-crossing for 2D sagittal slices"},dogy:{args:["sPos","sNeg"],help:"as dog, zero-crossing for 2D coronal slices"},dogz:{args:["sPos","sNeg"],help:"as dog, zero-crossing for 2D axial slices"},add:{args:["input"],help:"add following input to current image"},sub:{args:["input"],help:"subtract following input from current image"},mul:{args:["input"],help:"multiply current image by following input"},div:{args:["input"],help:"divide current image by following input"},rem:{args:["number"],help:"modulus remainder - divide current image by following input and take remainder"},mas:{args:["file"],help:"use (following image>0) to mask current image"},thr:{args:["number"],help:"use following number to threshold current image (zero anything below the number)"},thrp:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number)"},thrP:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below"},uthr:{args:["number"],help:"use following number to upper-threshold current image (zero anything above the number)"},uthrp:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number)"},uthrP:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above"},clamp:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE to threshold current image (anything below set to this threshold)"},uclamp:{args:["input"],help:"use following percentage (0-100) of ROBUST RANGE to threshold current image (anything above set to this threshold)"},max:{args:["input"],help:"take maximum of following input and current image"},min:{args:["input"],help:"take minimum of following input and current image"},seed:{args:["number"],help:"seed random number generator with following number"},restart:{args:["file"],help:"replace the current image with input for future processing operations"},save:{args:[],help:"save the current working image to the input filename"},inm:{args:["mean"],help:"(-i i ip.c) intensity normalisation (per 3D volume mean)"},ing:{args:["mean"],help:"(-I i ip.c) intensity normalisation, global 4D mean)"},s:{args:["sigma"],help:"create a gauss kernel of sigma mm and perform mean filtering"},exp:{args:[],help:"exponential"},log:{args:[],help:"natural logarithm"},sin:{args:[],help:"sine function"},cos:{args:[],help:"cosine function"},tan:{args:[],help:"tangent function"},asin:{args:[],help:"arc sine function"},acos:{args:[],help:"arc cosine function"},atan:{args:[],help:"arc tangent function"},sqr:{args:[],help:"square"},sqrt:{args:[],help:"square root"},recip:{args:[],help:"reciprocal (1/current image)"},abs:{args:[],help:"absolute value"},bin:{args:[],help:"use (current image>0) to binarise"},binv:{args:[],help:"binarise and invert (binarisation and logical inversion)"},fillh:{args:[],help:"fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV)"},fillh26:{args:[],help:"fill holes using 26 connectivity"},index:{args:[],help:"replace each nonzero voxel with a unique (subject to wrapping) index number"},grid:{args:["value","spacing"],help:"add a 3D grid of intensity <value> with grid spacing <spacing>"},edge:{args:[],help:"edge strength"},tfce:{args:["H","E","connectivity"],help:"enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons)"},tfceS:{args:["H","E","connectivity","X","Y","Z","tfce_thresh"],help:"show support area for voxel (X,Y,Z)"},nan:{args:[],help:"replace NaNs (improper numbers) with 0"},nanm:{args:[],help:"make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise"},rand:{args:[],help:"add uniform noise (range 0:1)"},randn:{args:[],help:"add Gaussian noise (mean=0 sigma=1)"},range:{args:[],help:"set the output calmin/max to full data range"},tensor_decomp:{args:[],help:"convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)"},kernel:{subOperations:{"3D":{args:[],help:"3x3x3 box centered on target voxel (set as default kernel)"},"2D":{args:[],help:"3x3x1 box centered on target voxel"},box:{args:["size"],help:"all voxels in a cube of width <size> mm centered on target voxel"},boxv:{args:["size"],help:"all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number"},boxv3:{args:["X","Y","Z"],help:"all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number"},gauss:{args:["sigma"],help:"gaussian kernel (sigma in mm, not voxels)"},sphere:{args:["size"],help:"all voxels in a sphere of radius <size> mm centered on target voxel"},file:{args:["filename"],help:"use external file as kernel"}}},dilM:{args:[],help:"Mean Dilation of non-zero voxels"},dilD:{args:[],help:"Maximum Dilation of non-zero voxels (emulating output of fslmaths 6.0.1, max not modal)"},dilF:{args:[],help:"Maximum filtering of all voxels"},dilall:{args:[],help:"Apply -dilM repeatedly until the entire FOV is covered"},ero:{args:[],help:"Erode by zeroing non-zero voxels when zero voxels found in kernel"},eroF:{args:[],help:"Minimum filtering of all voxels"},fmedian:{args:[],help:"Median Filtering"},fmean:{args:[],help:"Mean filtering, kernel weighted (conventionally used with gauss kernel)"},fmeanu:{args:[],help:"Mean filtering, kernel weighted, un-normalized (gives edge effects)"},subsamp2:{args:[],help:"downsamples image by a factor of 2 (keeping new voxels centered on old)"},subsamp2offc:{args:[],help:"downsamples image by a factor of 2 (non-centered)"},Tmean:{args:[],help:"mean across time"},Tstd:{args:[],help:"standard deviation across time"},Tmax:{args:[],help:"max across time"},Tmaxn:{args:[],help:"time index of max across time"},Tmin:{args:[],help:"min across time"},Tmedian:{args:[],help:"median across time"},Tperc:{args:["percentage"],help:"nth percentile (0-100) of FULL RANGE across time"},Tar1:{args:[],help:"temporal AR(1) coefficient (use -odt float and probably demean first)"},pval:{args:[],help:"Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image"},pval0:{args:[],help:"Same as -pval, but treat zeros as missing data"},cpval:{args:[],help:"Same as -pval, but gives FWE corrected P-values"},ztop:{args:[],help:"Convert Z-stat to (uncorrected) P"},ptoz:{args:[],help:"Convert (uncorrected) P to Z"},ztopc:{args:[],help:"Convert Z-stat to (uncorrected but clamped) P"},ptozc:{args:[],help:"Convert (uncorrected but clamped) P to Z"},rank:{args:[],help:"Convert data to ranks (over T dim)"},ranknorm:{args:[],help:"Transform to Normal dist via ranks"},roi:{args:["xmin","xsize","ymin","ysize","zmin","zsize","tmin","tsize"],help:"zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension"},bptf:{args:["hp_sigma","lp_sigma"],help:"(-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter"},roc:{args:["AROC-thresh","outfile","truth"],help:"take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found"}},su=class{constructor(){this.worker=null,this.operators=iu,this.outputDataType="float",this.dataTypes={char:"char",short:"short",int:"int",float:"float",double:"double",input:"input"}}init(){return this.worker=new Worker(new URL(""+new URL("worker-Dg7iFMgZ.js",import.meta.url).href,import.meta.url),{type:"module"}),new Promise((t,e)=>{this.worker.onmessage=i=>{i.data&&i.data.type==="ready"&&t(!0)},this.worker.onerror=i=>{e(new Error(`Worker failed to load: ${i.message}`))}})}setOutputDataType(t){if(Object.values(this.dataTypes).includes(t))this.outputDataType=t;else throw new Error(`Invalid data type: ${t}`)}image(t){return new ru({worker:this.worker,file:t,operators:this.operators,outputDataType:this.outputDataType})}},ru=class{constructor({worker:t,file:e,operators:i,outputDataType:s}){this.worker=t,this.file=e,this.operators=i,this.commands=[],this.outputDataType=s||"float",this._generateMethods()}_addCommand(t,...e){return this.commands.push(t,...e.map(String)),this}_generateMethods(){Object.keys(this.operators).forEach(t=>{const e=this.operators[t];t==="kernel"?Object.keys(e.subOperations).forEach(i=>{const s=e.subOperations[i];this[`kernel${i.charAt(0).toUpperCase()+i.slice(1)}`]=(...r)=>{if(r.length!==s.args.length)throw new Error(`Expected ${s.args.length} arguments for kernel ${i}, but got ${r.length}`);return this._addCommand("-kernel",i,...r)}}):t==="mesh"?this.mesh=(i={})=>{const s=[];return Object.keys(i).forEach(r=>{if(e.subOperations[r]){const n=e.subOperations[r],a=i[r];if(n.args.length>0&&a===void 0)throw new Error(`Sub-option -${r} requires a value.`);s.push(`-${r}`),n.args.length>0&&s.push(a)}else throw new Error(`Invalid sub-option -${r} for mesh.`)}),this._addCommand("-mesh",...s)}:this[t]=(...i)=>{if(i.length<e.args.length||!e.optional&&i.length>e.args.length)throw new Error(`Expected ${e.args.length} arguments for ${t}, but got ${i.length}`);return this._addCommand(`-${t}`,...i)}})}async run(t="output.nii"){return new Promise((e,i)=>{this.worker.onmessage=r=>{if(r.data.type==="error")i(new Error(r.data.message));else{const{blob:n,exitCode:a}=r.data;a===0?e(n):i(new Error(`niimath processing failed with exit code ${a}`))}};const s=[this.file.name,...this.commands,t,"-odt",this.outputDataType];this.worker===null&&i(new Error("Worker not initialized. Did you await the init() method?")),this.worker.postMessage({blob:this.file,cmd:s,outName:t})})}};const nu="0.2.0",ot={Int8:"int8",UInt8:"uint8",Int16:"int16",UInt16:"uint16",Int32:"int32",UInt32:"uint32",Int64:"int64",UInt64:"uint64"},Ws={Float32:"float32",Float64:"float64"};function Et(t,e){let i=null;switch(t){case ot.UInt8:{i=new Uint8Array(e);break}case ot.Int8:{i=new Int8Array(e);break}case ot.UInt16:{i=new Uint16Array(e);break}case ot.Int16:{i=new Int16Array(e);break}case ot.UInt32:{i=new Uint32Array(e);break}case ot.Int32:{i=new Int32Array(e);break}case ot.UInt64:{typeof globalThis.BigUint64Array=="function"?i=new BigUint64Array(e):i=new Uint8Array(e);break}case ot.Int64:{typeof globalThis.BigInt64Array=="function"?i=new BigInt64Array(e):i=new Uint8Array(e);break}case Ws.Float32:{i=new Float32Array(e);break}case Ws.Float64:{i=new Float64Array(e);break}case"null":{i=null;break}case null:{i=null;break}default:throw new Error("Type is not supported as a TypedArray")}return i}const he={TextFile:"TextFile",BinaryFile:"BinaryFile",TextStream:"TextStream",BinaryStream:"BinaryStream",Image:"Image",PointSet:"PointSet",Mesh:"Mesh",PolyData:"PolyData",TransformList:"TransformList",JsonCompatible:"JsonCompatible"};/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const dl=Symbol("Comlink.proxy"),au=Symbol("Comlink.endpoint"),Un=Symbol("Comlink.releaseProxy"),Fr=Symbol("Comlink.finalizer"),Bs=Symbol("Comlink.thrown"),ul=t=>typeof t=="object"&&t!==null||typeof t=="function",ou={canHandle:t=>ul(t)&&t[dl],serialize(t){const{port1:e,port2:i}=new MessageChannel;return gl(t,e),[i,[i]]},deserialize(t){return t.start(),Pn(t)}},lu={canHandle:t=>ul(t)&&Bs in t,serialize({value:t}){let e;return t instanceof Error?e={isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:e={isError:!1,value:t},[e,[]]},deserialize(t){throw t.isError?Object.assign(new Error(t.value.message),t.value):t.value}},ml=new Map([["proxy",ou],["throw",lu]]);function cu(t,e){for(const i of t)if(e===i||i==="*"||i instanceof RegExp&&i.test(e))return!0;return!1}function gl(t,e=globalThis,i=["*"]){e.addEventListener("message",function s(r){if(!r||!r.data)return;if(!cu(i,r.origin)){console.warn(`Invalid origin '${r.origin}' for comlink proxy`);return}const{id:n,type:a,path:o}=Object.assign({path:[]},r.data),l=(r.data.argumentList||[]).map(Gt);let c;try{const h=o.slice(0,-1).reduce((f,u)=>f[u],t),d=o.reduce((f,u)=>f[u],t);switch(a){case"GET":c=d;break;case"SET":h[o.slice(-1)[0]]=Gt(r.data.value),c=!0;break;case"APPLY":c=d.apply(h,l);break;case"CONSTRUCT":{const f=new d(...l);c=mu(f)}break;case"ENDPOINT":{const{port1:f,port2:u}=new MessageChannel;gl(t,u),c=Vn(f,[f])}break;case"RELEASE":c=void 0;break;default:return}}catch(h){c={value:h,[Bs]:0}}Promise.resolve(c).catch(h=>({value:h,[Bs]:0})).then(h=>{const[d,f]=Hs(h);e.postMessage(Object.assign(Object.assign({},d),{id:n}),f),a==="RELEASE"&&(e.removeEventListener("message",s),pl(e),Fr in t&&typeof t[Fr]=="function"&&t[Fr]())}).catch(h=>{const[d,f]=Hs({value:new TypeError("Unserializable return value"),[Bs]:0});e.postMessage(Object.assign(Object.assign({},d),{id:n}),f)})}),e.start&&e.start()}function hu(t){return t.constructor.name==="MessagePort"}function pl(t){hu(t)&&t.close()}function Pn(t,e){const i=new Map;return t.addEventListener("message",function(r){const{data:n}=r;if(!n||!n.id)return;const a=i.get(n.id);if(a)try{a(n)}finally{i.delete(n.id)}}),Xr(t,i,[],e)}function xs(t){if(t)throw new Error("Proxy has been released and is not useable")}function Al(t){return ci(t,new Map,{type:"RELEASE"}).then(()=>{pl(t)})}const Ks=new WeakMap,js="FinalizationRegistry"in globalThis&&new FinalizationRegistry(t=>{const e=(Ks.get(t)||0)-1;Ks.set(t,e),e===0&&Al(t)});function fu(t,e){const i=(Ks.get(e)||0)+1;Ks.set(e,i),js&&js.register(t,e,t)}function du(t){js&&js.unregister(t)}function Xr(t,e,i=[],s=function(){}){let r=!1;const n=new Proxy(s,{get(a,o){if(xs(r),o===Un)return()=>{du(n),Al(t),e.clear(),r=!0};if(o==="then"){if(i.length===0)return{then:()=>n};const l=ci(t,e,{type:"GET",path:i.map(c=>c.toString())}).then(Gt);return l.then.bind(l)}return Xr(t,e,[...i,o])},set(a,o,l){xs(r);const[c,h]=Hs(l);return ci(t,e,{type:"SET",path:[...i,o].map(d=>d.toString()),value:c},h).then(Gt)},apply(a,o,l){xs(r);const c=i[i.length-1];if(c===au)return ci(t,e,{type:"ENDPOINT"}).then(Gt);if(c==="bind")return Xr(t,e,i.slice(0,-1));const[h,d]=Ga(l);return ci(t,e,{type:"APPLY",path:i.map(f=>f.toString()),argumentList:h},d).then(Gt)},construct(a,o){xs(r);const[l,c]=Ga(o);return ci(t,e,{type:"CONSTRUCT",path:i.map(h=>h.toString()),argumentList:l},c).then(Gt)}});return fu(n,t),n}function uu(t){return Array.prototype.concat.apply([],t)}function Ga(t){const e=t.map(Hs);return[e.map(i=>i[0]),uu(e.map(i=>i[1]))]}const wl=new WeakMap;function Vn(t,e){return wl.set(t,e),t}function mu(t){return Object.assign(t,{[dl]:!0})}function Hs(t){for(const[e,i]of ml)if(i.canHandle(t)){const[s,r]=i.serialize(t);return[{type:"HANDLER",name:e,value:s},r]}return[{type:"RAW",value:t},wl.get(t)||[]]}function Gt(t){switch(t.type){case"HANDLER":return ml.get(t.name).deserialize(t.value);case"RAW":return t.value}}function ci(t,e,i,s){return new Promise(r=>{const n=gu();e.set(n,r),t.start&&t.start(),t.postMessage(Object.assign({id:n},i),s)})}function gu(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}function xl(t,e){return function(){return t.apply(e,arguments)}}const{toString:pu}=Object.prototype,{getPrototypeOf:Rn}=Object,{iterator:sr,toStringTag:yl}=Symbol,rr=(t=>e=>{const i=pu.call(e);return t[i]||(t[i]=i.slice(8,-1).toLowerCase())})(Object.create(null)),gt=t=>(t=t.toLowerCase(),e=>rr(e)===t),nr=t=>e=>typeof e===t,{isArray:gi}=Array,zi=nr("undefined");function Au(t){return t!==null&&!zi(t)&&t.constructor!==null&&!zi(t.constructor)&&$e(t.constructor.isBuffer)&&t.constructor.isBuffer(t)}const vl=gt("ArrayBuffer");function wu(t){let e;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?e=ArrayBuffer.isView(t):e=t&&t.buffer&&vl(t.buffer),e}const xu=nr("string"),$e=nr("function"),bl=nr("number"),ar=t=>t!==null&&typeof t=="object",yu=t=>t===!0||t===!1,Us=t=>{if(rr(t)!=="object")return!1;const e=Rn(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(yl in t)&&!(sr in t)},vu=gt("Date"),bu=gt("File"),Cu=gt("Blob"),Su=gt("FileList"),Eu=t=>ar(t)&&$e(t.pipe),Du=t=>{let e;return t&&(typeof FormData=="function"&&t instanceof FormData||$e(t.append)&&((e=rr(t))==="formdata"||e==="object"&&$e(t.toString)&&t.toString()==="[object FormData]"))},Tu=gt("URLSearchParams"),[Mu,Iu,Fu,Bu]=["ReadableStream","Request","Response","Headers"].map(gt),Uu=t=>t.trim?t.trim():t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function as(t,e,{allOwnKeys:i=!1}={}){if(t===null||typeof t>"u")return;let s,r;if(typeof t!="object"&&(t=[t]),gi(t))for(s=0,r=t.length;s<r;s++)e.call(null,t[s],s,t);else{const n=i?Object.getOwnPropertyNames(t):Object.keys(t),a=n.length;let o;for(s=0;s<a;s++)o=n[s],e.call(null,t[o],o,t)}}function Cl(t,e){e=e.toLowerCase();const i=Object.keys(t);let s=i.length,r;for(;s-- >0;)if(r=i[s],e===r.toLowerCase())return r;return null}const Kt=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,Sl=t=>!zi(t)&&t!==Kt;function Zr(){const{caseless:t}=Sl(this)&&this||{},e={},i=(s,r)=>{const n=t&&Cl(e,r)||r;Us(e[n])&&Us(s)?e[n]=Zr(e[n],s):Us(s)?e[n]=Zr({},s):gi(s)?e[n]=s.slice():e[n]=s};for(let s=0,r=arguments.length;s<r;s++)arguments[s]&&as(arguments[s],i);return e}const Pu=(t,e,i,{allOwnKeys:s}={})=>(as(e,(r,n)=>{i&&$e(r)?t[n]=xl(r,i):t[n]=r},{allOwnKeys:s}),t),Vu=t=>(t.charCodeAt(0)===65279&&(t=t.slice(1)),t),Ru=(t,e,i,s)=>{t.prototype=Object.create(e.prototype,s),t.prototype.constructor=t,Object.defineProperty(t,"super",{value:e.prototype}),i&&Object.assign(t.prototype,i)},Nu=(t,e,i,s)=>{let r,n,a;const o={};if(e=e||{},t==null)return e;do{for(r=Object.getOwnPropertyNames(t),n=r.length;n-- >0;)a=r[n],(!s||s(a,t,e))&&!o[a]&&(e[a]=t[a],o[a]=!0);t=i!==!1&&Rn(t)}while(t&&(!i||i(t,e))&&t!==Object.prototype);return e},ku=(t,e,i)=>{t=String(t),(i===void 0||i>t.length)&&(i=t.length),i-=e.length;const s=t.indexOf(e,i);return s!==-1&&s===i},Lu=t=>{if(!t)return null;if(gi(t))return t;let e=t.length;if(!bl(e))return null;const i=new Array(e);for(;e-- >0;)i[e]=t[e];return i},Ou=(t=>e=>t&&e instanceof t)(typeof Uint8Array<"u"&&Rn(Uint8Array)),zu=(t,e)=>{const s=(t&&t[sr]).call(t);let r;for(;(r=s.next())&&!r.done;){const n=r.value;e.call(t,n[0],n[1])}},Gu=(t,e)=>{let i;const s=[];for(;(i=t.exec(e))!==null;)s.push(i);return s},Yu=gt("HTMLFormElement"),Wu=t=>t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(i,s,r){return s.toUpperCase()+r}),Ya=(({hasOwnProperty:t})=>(e,i)=>t.call(e,i))(Object.prototype),Ku=gt("RegExp"),El=(t,e)=>{const i=Object.getOwnPropertyDescriptors(t),s={};as(i,(r,n)=>{let a;(a=e(r,n,t))!==!1&&(s[n]=a||r)}),Object.defineProperties(t,s)},ju=t=>{El(t,(e,i)=>{if($e(t)&&["arguments","caller","callee"].indexOf(i)!==-1)return!1;const s=t[i];if($e(s)){if(e.enumerable=!1,"writable"in e){e.writable=!1;return}e.set||(e.set=()=>{throw Error("Can not rewrite read-only method '"+i+"'")})}})},Hu=(t,e)=>{const i={},s=r=>{r.forEach(n=>{i[n]=!0})};return gi(t)?s(t):s(String(t).split(e)),i},qu=()=>{},Qu=(t,e)=>t!=null&&Number.isFinite(t=+t)?t:e;function Xu(t){return!!(t&&$e(t.append)&&t[yl]==="FormData"&&t[sr])}const Zu=t=>{const e=new Array(10),i=(s,r)=>{if(ar(s)){if(e.indexOf(s)>=0)return;if(!("toJSON"in s)){e[r]=s;const n=gi(s)?[]:{};return as(s,(a,o)=>{const l=i(a,r+1);!zi(l)&&(n[o]=l)}),e[r]=void 0,n}}return s};return i(t,0)},Ju=gt("AsyncFunction"),_u=t=>t&&(ar(t)||$e(t))&&$e(t.then)&&$e(t.catch),Dl=((t,e)=>t?setImmediate:e?((i,s)=>(Kt.addEventListener("message",({source:r,data:n})=>{r===Kt&&n===i&&s.length&&s.shift()()},!1),r=>{s.push(r),Kt.postMessage(i,"*")}))(`axios@${Math.random()}`,[]):i=>setTimeout(i))(typeof setImmediate=="function",$e(Kt.postMessage)),$u=typeof queueMicrotask<"u"?queueMicrotask.bind(Kt):typeof process<"u"&&process.nextTick||Dl,e1=t=>t!=null&&$e(t[sr]),G={isArray:gi,isArrayBuffer:vl,isBuffer:Au,isFormData:Du,isArrayBufferView:wu,isString:xu,isNumber:bl,isBoolean:yu,isObject:ar,isPlainObject:Us,isReadableStream:Mu,isRequest:Iu,isResponse:Fu,isHeaders:Bu,isUndefined:zi,isDate:vu,isFile:bu,isBlob:Cu,isRegExp:Ku,isFunction:$e,isStream:Eu,isURLSearchParams:Tu,isTypedArray:Ou,isFileList:Su,forEach:as,merge:Zr,extend:Pu,trim:Uu,stripBOM:Vu,inherits:Ru,toFlatObject:Nu,kindOf:rr,kindOfTest:gt,endsWith:ku,toArray:Lu,forEachEntry:zu,matchAll:Gu,isHTMLForm:Yu,hasOwnProperty:Ya,hasOwnProp:Ya,reduceDescriptors:El,freezeMethods:ju,toObjectSet:Hu,toCamelCase:Wu,noop:qu,toFiniteNumber:Qu,findKey:Cl,global:Kt,isContextDefined:Sl,isSpecCompliantForm:Xu,toJSONObject:Zu,isAsyncFn:Ju,isThenable:_u,setImmediate:Dl,asap:$u,isIterable:e1};function ie(t,e,i,s,r){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=t,this.name="AxiosError",e&&(this.code=e),i&&(this.config=i),s&&(this.request=s),r&&(this.response=r,this.status=r.status?r.status:null)}G.inherits(ie,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:G.toJSONObject(this.config),code:this.code,status:this.status}}});const Tl=ie.prototype,Ml={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(t=>{Ml[t]={value:t}});Object.defineProperties(ie,Ml);Object.defineProperty(Tl,"isAxiosError",{value:!0});ie.from=(t,e,i,s,r,n)=>{const a=Object.create(Tl);return G.toFlatObject(t,a,function(l){return l!==Error.prototype},o=>o!=="isAxiosError"),ie.call(a,t.message,e,i,s,r),a.cause=t,a.name=t.name,n&&Object.assign(a,n),a};const t1=null;function Jr(t){return G.isPlainObject(t)||G.isArray(t)}function Il(t){return G.endsWith(t,"[]")?t.slice(0,-2):t}function Wa(t,e,i){return t?t.concat(e).map(function(r,n){return r=Il(r),!i&&n?"["+r+"]":r}).join(i?".":""):e}function i1(t){return G.isArray(t)&&!t.some(Jr)}const s1=G.toFlatObject(G,{},null,function(e){return/^is[A-Z]/.test(e)});function or(t,e,i){if(!G.isObject(t))throw new TypeError("target must be an object");e=e||new FormData,i=G.toFlatObject(i,{metaTokens:!0,dots:!1,indexes:!1},!1,function(g,p){return!G.isUndefined(p[g])});const s=i.metaTokens,r=i.visitor||h,n=i.dots,a=i.indexes,l=(i.Blob||typeof Blob<"u"&&Blob)&&G.isSpecCompliantForm(e);if(!G.isFunction(r))throw new TypeError("visitor must be a function");function c(m){if(m===null)return"";if(G.isDate(m))return m.toISOString();if(!l&&G.isBlob(m))throw new ie("Blob is not supported. Use a Buffer instead.");return G.isArrayBuffer(m)||G.isTypedArray(m)?l&&typeof Blob=="function"?new Blob([m]):Buffer.from(m):m}function h(m,g,p){let A=m;if(m&&!p&&typeof m=="object"){if(G.endsWith(g,"{}"))g=s?g:g.slice(0,-2),m=JSON.stringify(m);else if(G.isArray(m)&&i1(m)||(G.isFileList(m)||G.endsWith(g,"[]"))&&(A=G.toArray(m)))return g=Il(g),A.forEach(function(x,y){!(G.isUndefined(x)||x===null)&&e.append(a===!0?Wa([g],y,n):a===null?g:g+"[]",c(x))}),!1}return Jr(m)?!0:(e.append(Wa(p,g,n),c(m)),!1)}const d=[],f=Object.assign(s1,{defaultVisitor:h,convertValue:c,isVisitable:Jr});function u(m,g){if(!G.isUndefined(m)){if(d.indexOf(m)!==-1)throw Error("Circular reference detected in "+g.join("."));d.push(m),G.forEach(m,function(A,w){(!(G.isUndefined(A)||A===null)&&r.call(e,A,G.isString(w)?w.trim():w,g,f))===!0&&u(A,g?g.concat(w):[w])}),d.pop()}}if(!G.isObject(t))throw new TypeError("data must be an object");return u(t),e}function Ka(t){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g,function(s){return e[s]})}function Nn(t,e){this._pairs=[],t&&or(t,this,e)}const Fl=Nn.prototype;Fl.append=function(e,i){this._pairs.push([e,i])};Fl.toString=function(e){const i=e?function(s){return e.call(this,s,Ka)}:Ka;return this._pairs.map(function(r){return i(r[0])+"="+i(r[1])},"").join("&")};function r1(t){return encodeURIComponent(t).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function Bl(t,e,i){if(!e)return t;const s=i&&i.encode||r1;G.isFunction(i)&&(i={serialize:i});const r=i&&i.serialize;let n;if(r?n=r(e,i):n=G.isURLSearchParams(e)?e.toString():new Nn(e,i).toString(s),n){const a=t.indexOf("#");a!==-1&&(t=t.slice(0,a)),t+=(t.indexOf("?")===-1?"?":"&")+n}return t}class ja{constructor(){this.handlers=[]}use(e,i,s){return this.handlers.push({fulfilled:e,rejected:i,synchronous:s?s.synchronous:!1,runWhen:s?s.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){G.forEach(this.handlers,function(s){s!==null&&e(s)})}}const Ul={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},n1=typeof URLSearchParams<"u"?URLSearchParams:Nn,a1=typeof FormData<"u"?FormData:null,o1=typeof Blob<"u"?Blob:null,l1={isBrowser:!0,classes:{URLSearchParams:n1,FormData:a1,Blob:o1},protocols:["http","https","file","blob","url","data"]},kn=typeof window<"u"&&typeof document<"u",_r=typeof navigator=="object"&&navigator||void 0,c1=kn&&(!_r||["ReactNative","NativeScript","NS"].indexOf(_r.product)<0),h1=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",f1=kn&&window.location.href||"http://localhost",d1=Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv:kn,hasStandardBrowserEnv:c1,hasStandardBrowserWebWorkerEnv:h1,navigator:_r,origin:f1},Symbol.toStringTag,{value:"Module"})),We={...d1,...l1};function u1(t,e){return or(t,new We.classes.URLSearchParams,Object.assign({visitor:function(i,s,r,n){return We.isNode&&G.isBuffer(i)?(this.append(s,i.toString("base64")),!1):n.defaultVisitor.apply(this,arguments)}},e))}function m1(t){return G.matchAll(/\w+|\[(\w*)]/g,t).map(e=>e[0]==="[]"?"":e[1]||e[0])}function g1(t){const e={},i=Object.keys(t);let s;const r=i.length;let n;for(s=0;s<r;s++)n=i[s],e[n]=t[n];return e}function Pl(t){function e(i,s,r,n){let a=i[n++];if(a==="__proto__")return!0;const o=Number.isFinite(+a),l=n>=i.length;return a=!a&&G.isArray(r)?r.length:a,l?(G.hasOwnProp(r,a)?r[a]=[r[a],s]:r[a]=s,!o):((!r[a]||!G.isObject(r[a]))&&(r[a]=[]),e(i,s,r[a],n)&&G.isArray(r[a])&&(r[a]=g1(r[a])),!o)}if(G.isFormData(t)&&G.isFunction(t.entries)){const i={};return G.forEachEntry(t,(s,r)=>{e(m1(s),r,i,0)}),i}return null}function p1(t,e,i){if(G.isString(t))try{return(e||JSON.parse)(t),G.trim(t)}catch(s){if(s.name!=="SyntaxError")throw s}return(i||JSON.stringify)(t)}const os={transitional:Ul,adapter:["xhr","http","fetch"],transformRequest:[function(e,i){const s=i.getContentType()||"",r=s.indexOf("application/json")>-1,n=G.isObject(e);if(n&&G.isHTMLForm(e)&&(e=new FormData(e)),G.isFormData(e))return r?JSON.stringify(Pl(e)):e;if(G.isArrayBuffer(e)||G.isBuffer(e)||G.isStream(e)||G.isFile(e)||G.isBlob(e)||G.isReadableStream(e))return e;if(G.isArrayBufferView(e))return e.buffer;if(G.isURLSearchParams(e))return i.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let o;if(n){if(s.indexOf("application/x-www-form-urlencoded")>-1)return u1(e,this.formSerializer).toString();if((o=G.isFileList(e))||s.indexOf("multipart/form-data")>-1){const l=this.env&&this.env.FormData;return or(o?{"files[]":e}:e,l&&new l,this.formSerializer)}}return n||r?(i.setContentType("application/json",!1),p1(e)):e}],transformResponse:[function(e){const i=this.transitional||os.transitional,s=i&&i.forcedJSONParsing,r=this.responseType==="json";if(G.isResponse(e)||G.isReadableStream(e))return e;if(e&&G.isString(e)&&(s&&!this.responseType||r)){const a=!(i&&i.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(o){if(a)throw o.name==="SyntaxError"?ie.from(o,ie.ERR_BAD_RESPONSE,this,null,this.response):o}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:We.classes.FormData,Blob:We.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};G.forEach(["delete","get","head","post","put","patch"],t=>{os.headers[t]={}});const A1=G.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),w1=t=>{const e={};let i,s,r;return t&&t.split(`
`).forEach(function(a){r=a.indexOf(":"),i=a.substring(0,r).trim().toLowerCase(),s=a.substring(r+1).trim(),!(!i||e[i]&&A1[i])&&(i==="set-cookie"?e[i]?e[i].push(s):e[i]=[s]:e[i]=e[i]?e[i]+", "+s:s)}),e},Ha=Symbol("internals");function Ci(t){return t&&String(t).trim().toLowerCase()}function Ps(t){return t===!1||t==null?t:G.isArray(t)?t.map(Ps):String(t)}function x1(t){const e=Object.create(null),i=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let s;for(;s=i.exec(t);)e[s[1]]=s[2];return e}const y1=t=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());function Br(t,e,i,s,r){if(G.isFunction(s))return s.call(this,e,i);if(r&&(e=i),!!G.isString(e)){if(G.isString(s))return e.indexOf(s)!==-1;if(G.isRegExp(s))return s.test(e)}}function v1(t){return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(e,i,s)=>i.toUpperCase()+s)}function b1(t,e){const i=G.toCamelCase(" "+e);["get","set","has"].forEach(s=>{Object.defineProperty(t,s+i,{value:function(r,n,a){return this[s].call(this,e,r,n,a)},configurable:!0})})}let et=class{constructor(e){e&&this.set(e)}set(e,i,s){const r=this;function n(o,l,c){const h=Ci(l);if(!h)throw new Error("header name must be a non-empty string");const d=G.findKey(r,h);(!d||r[d]===void 0||c===!0||c===void 0&&r[d]!==!1)&&(r[d||l]=Ps(o))}const a=(o,l)=>G.forEach(o,(c,h)=>n(c,h,l));if(G.isPlainObject(e)||e instanceof this.constructor)a(e,i);else if(G.isString(e)&&(e=e.trim())&&!y1(e))a(w1(e),i);else if(G.isObject(e)&&G.isIterable(e)){let o={},l,c;for(const h of e){if(!G.isArray(h))throw TypeError("Object iterator must return a key-value pair");o[c=h[0]]=(l=o[c])?G.isArray(l)?[...l,h[1]]:[l,h[1]]:h[1]}a(o,i)}else e!=null&&n(i,e,s);return this}get(e,i){if(e=Ci(e),e){const s=G.findKey(this,e);if(s){const r=this[s];if(!i)return r;if(i===!0)return x1(r);if(G.isFunction(i))return i.call(this,r,s);if(G.isRegExp(i))return i.exec(r);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,i){if(e=Ci(e),e){const s=G.findKey(this,e);return!!(s&&this[s]!==void 0&&(!i||Br(this,this[s],s,i)))}return!1}delete(e,i){const s=this;let r=!1;function n(a){if(a=Ci(a),a){const o=G.findKey(s,a);o&&(!i||Br(s,s[o],o,i))&&(delete s[o],r=!0)}}return G.isArray(e)?e.forEach(n):n(e),r}clear(e){const i=Object.keys(this);let s=i.length,r=!1;for(;s--;){const n=i[s];(!e||Br(this,this[n],n,e,!0))&&(delete this[n],r=!0)}return r}normalize(e){const i=this,s={};return G.forEach(this,(r,n)=>{const a=G.findKey(s,n);if(a){i[a]=Ps(r),delete i[n];return}const o=e?v1(n):String(n).trim();o!==n&&delete i[n],i[o]=Ps(r),s[o]=!0}),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const i=Object.create(null);return G.forEach(this,(s,r)=>{s!=null&&s!==!1&&(i[r]=e&&G.isArray(s)?s.join(", "):s)}),i}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([e,i])=>e+": "+i).join(`
`)}getSetCookie(){return this.get("set-cookie")||[]}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...i){const s=new this(e);return i.forEach(r=>s.set(r)),s}static accessor(e){const s=(this[Ha]=this[Ha]={accessors:{}}).accessors,r=this.prototype;function n(a){const o=Ci(a);s[o]||(b1(r,a),s[o]=!0)}return G.isArray(e)?e.forEach(n):n(e),this}};et.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);G.reduceDescriptors(et.prototype,({value:t},e)=>{let i=e[0].toUpperCase()+e.slice(1);return{get:()=>t,set(s){this[i]=s}}});G.freezeMethods(et);function Ur(t,e){const i=this||os,s=e||i,r=et.from(s.headers);let n=s.data;return G.forEach(t,function(o){n=o.call(i,n,r.normalize(),e?e.status:void 0)}),r.normalize(),n}function Vl(t){return!!(t&&t.__CANCEL__)}function pi(t,e,i){ie.call(this,t??"canceled",ie.ERR_CANCELED,e,i),this.name="CanceledError"}G.inherits(pi,ie,{__CANCEL__:!0});function Rl(t,e,i){const s=i.config.validateStatus;!i.status||!s||s(i.status)?t(i):e(new ie("Request failed with status code "+i.status,[ie.ERR_BAD_REQUEST,ie.ERR_BAD_RESPONSE][Math.floor(i.status/100)-4],i.config,i.request,i))}function C1(t){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(t);return e&&e[1]||""}function S1(t,e){t=t||10;const i=new Array(t),s=new Array(t);let r=0,n=0,a;return e=e!==void 0?e:1e3,function(l){const c=Date.now(),h=s[n];a||(a=c),i[r]=l,s[r]=c;let d=n,f=0;for(;d!==r;)f+=i[d++],d=d%t;if(r=(r+1)%t,r===n&&(n=(n+1)%t),c-a<e)return;const u=h&&c-h;return u?Math.round(f*1e3/u):void 0}}function E1(t,e){let i=0,s=1e3/e,r,n;const a=(c,h=Date.now())=>{i=h,r=null,n&&(clearTimeout(n),n=null),t.apply(null,c)};return[(...c)=>{const h=Date.now(),d=h-i;d>=s?a(c,h):(r=c,n||(n=setTimeout(()=>{n=null,a(r)},s-d)))},()=>r&&a(r)]}const qs=(t,e,i=3)=>{let s=0;const r=S1(50,250);return E1(n=>{const a=n.loaded,o=n.lengthComputable?n.total:void 0,l=a-s,c=r(l),h=a<=o;s=a;const d={loaded:a,total:o,progress:o?a/o:void 0,bytes:l,rate:c||void 0,estimated:c&&o&&h?(o-a)/c:void 0,event:n,lengthComputable:o!=null,[e?"download":"upload"]:!0};t(d)},i)},qa=(t,e)=>{const i=t!=null;return[s=>e[0]({lengthComputable:i,total:t,loaded:s}),e[1]]},Qa=t=>(...e)=>G.asap(()=>t(...e)),D1=We.hasStandardBrowserEnv?((t,e)=>i=>(i=new URL(i,We.origin),t.protocol===i.protocol&&t.host===i.host&&(e||t.port===i.port)))(new URL(We.origin),We.navigator&&/(msie|trident)/i.test(We.navigator.userAgent)):()=>!0,T1=We.hasStandardBrowserEnv?{write(t,e,i,s,r,n){const a=[t+"="+encodeURIComponent(e)];G.isNumber(i)&&a.push("expires="+new Date(i).toGMTString()),G.isString(s)&&a.push("path="+s),G.isString(r)&&a.push("domain="+r),n===!0&&a.push("secure"),document.cookie=a.join("; ")},read(t){const e=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove(t){this.write(t,"",Date.now()-864e5)}}:{write(){},read(){return null},remove(){}};function M1(t){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)}function I1(t,e){return e?t.replace(/\/?\/$/,"")+"/"+e.replace(/^\/+/,""):t}function Nl(t,e,i){let s=!M1(e);return t&&(s||i==!1)?I1(t,e):e}const Xa=t=>t instanceof et?{...t}:t;function Jt(t,e){e=e||{};const i={};function s(c,h,d,f){return G.isPlainObject(c)&&G.isPlainObject(h)?G.merge.call({caseless:f},c,h):G.isPlainObject(h)?G.merge({},h):G.isArray(h)?h.slice():h}function r(c,h,d,f){if(G.isUndefined(h)){if(!G.isUndefined(c))return s(void 0,c,d,f)}else return s(c,h,d,f)}function n(c,h){if(!G.isUndefined(h))return s(void 0,h)}function a(c,h){if(G.isUndefined(h)){if(!G.isUndefined(c))return s(void 0,c)}else return s(void 0,h)}function o(c,h,d){if(d in e)return s(c,h);if(d in t)return s(void 0,c)}const l={url:n,method:n,data:n,baseURL:a,transformRequest:a,transformResponse:a,paramsSerializer:a,timeout:a,timeoutMessage:a,withCredentials:a,withXSRFToken:a,adapter:a,responseType:a,xsrfCookieName:a,xsrfHeaderName:a,onUploadProgress:a,onDownloadProgress:a,decompress:a,maxContentLength:a,maxBodyLength:a,beforeRedirect:a,transport:a,httpAgent:a,httpsAgent:a,cancelToken:a,socketPath:a,responseEncoding:a,validateStatus:o,headers:(c,h,d)=>r(Xa(c),Xa(h),d,!0)};return G.forEach(Object.keys(Object.assign({},t,e)),function(h){const d=l[h]||r,f=d(t[h],e[h],h);G.isUndefined(f)&&d!==o||(i[h]=f)}),i}const kl=t=>{const e=Jt({},t);let{data:i,withXSRFToken:s,xsrfHeaderName:r,xsrfCookieName:n,headers:a,auth:o}=e;e.headers=a=et.from(a),e.url=Bl(Nl(e.baseURL,e.url,e.allowAbsoluteUrls),t.params,t.paramsSerializer),o&&a.set("Authorization","Basic "+btoa((o.username||"")+":"+(o.password?unescape(encodeURIComponent(o.password)):"")));let l;if(G.isFormData(i)){if(We.hasStandardBrowserEnv||We.hasStandardBrowserWebWorkerEnv)a.setContentType(void 0);else if((l=a.getContentType())!==!1){const[c,...h]=l?l.split(";").map(d=>d.trim()).filter(Boolean):[];a.setContentType([c||"multipart/form-data",...h].join("; "))}}if(We.hasStandardBrowserEnv&&(s&&G.isFunction(s)&&(s=s(e)),s||s!==!1&&D1(e.url))){const c=r&&n&&T1.read(n);c&&a.set(r,c)}return e},F1=typeof XMLHttpRequest<"u",B1=F1&&function(t){return new Promise(function(i,s){const r=kl(t);let n=r.data;const a=et.from(r.headers).normalize();let{responseType:o,onUploadProgress:l,onDownloadProgress:c}=r,h,d,f,u,m;function g(){u&&u(),m&&m(),r.cancelToken&&r.cancelToken.unsubscribe(h),r.signal&&r.signal.removeEventListener("abort",h)}let p=new XMLHttpRequest;p.open(r.method.toUpperCase(),r.url,!0),p.timeout=r.timeout;function A(){if(!p)return;const x=et.from("getAllResponseHeaders"in p&&p.getAllResponseHeaders()),v={data:!o||o==="text"||o==="json"?p.responseText:p.response,status:p.status,statusText:p.statusText,headers:x,config:t,request:p};Rl(function(b){i(b),g()},function(b){s(b),g()},v),p=null}"onloadend"in p?p.onloadend=A:p.onreadystatechange=function(){!p||p.readyState!==4||p.status===0&&!(p.responseURL&&p.responseURL.indexOf("file:")===0)||setTimeout(A)},p.onabort=function(){p&&(s(new ie("Request aborted",ie.ECONNABORTED,t,p)),p=null)},p.onerror=function(){s(new ie("Network Error",ie.ERR_NETWORK,t,p)),p=null},p.ontimeout=function(){let y=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const v=r.transitional||Ul;r.timeoutErrorMessage&&(y=r.timeoutErrorMessage),s(new ie(y,v.clarifyTimeoutError?ie.ETIMEDOUT:ie.ECONNABORTED,t,p)),p=null},n===void 0&&a.setContentType(null),"setRequestHeader"in p&&G.forEach(a.toJSON(),function(y,v){p.setRequestHeader(v,y)}),G.isUndefined(r.withCredentials)||(p.withCredentials=!!r.withCredentials),o&&o!=="json"&&(p.responseType=r.responseType),c&&([f,m]=qs(c,!0),p.addEventListener("progress",f)),l&&p.upload&&([d,u]=qs(l),p.upload.addEventListener("progress",d),p.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(h=x=>{p&&(s(!x||x.type?new pi(null,t,p):x),p.abort(),p=null)},r.cancelToken&&r.cancelToken.subscribe(h),r.signal&&(r.signal.aborted?h():r.signal.addEventListener("abort",h)));const w=C1(r.url);if(w&&We.protocols.indexOf(w)===-1){s(new ie("Unsupported protocol "+w+":",ie.ERR_BAD_REQUEST,t));return}p.send(n||null)})},U1=(t,e)=>{const{length:i}=t=t?t.filter(Boolean):[];if(e||i){let s=new AbortController,r;const n=function(c){if(!r){r=!0,o();const h=c instanceof Error?c:this.reason;s.abort(h instanceof ie?h:new pi(h instanceof Error?h.message:h))}};let a=e&&setTimeout(()=>{a=null,n(new ie(`timeout ${e} of ms exceeded`,ie.ETIMEDOUT))},e);const o=()=>{t&&(a&&clearTimeout(a),a=null,t.forEach(c=>{c.unsubscribe?c.unsubscribe(n):c.removeEventListener("abort",n)}),t=null)};t.forEach(c=>c.addEventListener("abort",n));const{signal:l}=s;return l.unsubscribe=()=>G.asap(o),l}},P1=function*(t,e){let i=t.byteLength;if(i<e){yield t;return}let s=0,r;for(;s<i;)r=s+e,yield t.slice(s,r),s=r},V1=async function*(t,e){for await(const i of R1(t))yield*P1(i,e)},R1=async function*(t){if(t[Symbol.asyncIterator]){yield*t;return}const e=t.getReader();try{for(;;){const{done:i,value:s}=await e.read();if(i)break;yield s}}finally{await e.cancel()}},Za=(t,e,i,s)=>{const r=V1(t,e);let n=0,a,o=l=>{a||(a=!0,s&&s(l))};return new ReadableStream({async pull(l){try{const{done:c,value:h}=await r.next();if(c){o(),l.close();return}let d=h.byteLength;if(i){let f=n+=d;i(f)}l.enqueue(new Uint8Array(h))}catch(c){throw o(c),c}},cancel(l){return o(l),r.return()}},{highWaterMark:2})},lr=typeof fetch=="function"&&typeof Request=="function"&&typeof Response=="function",Ll=lr&&typeof ReadableStream=="function",N1=lr&&(typeof TextEncoder=="function"?(t=>e=>t.encode(e))(new TextEncoder):async t=>new Uint8Array(await new Response(t).arrayBuffer())),Ol=(t,...e)=>{try{return!!t(...e)}catch{return!1}},k1=Ll&&Ol(()=>{let t=!1;const e=new Request(We.origin,{body:new ReadableStream,method:"POST",get duplex(){return t=!0,"half"}}).headers.has("Content-Type");return t&&!e}),Ja=64*1024,$r=Ll&&Ol(()=>G.isReadableStream(new Response("").body)),Qs={stream:$r&&(t=>t.body)};lr&&(t=>{["text","arrayBuffer","blob","formData","stream"].forEach(e=>{!Qs[e]&&(Qs[e]=G.isFunction(t[e])?i=>i[e]():(i,s)=>{throw new ie(`Response type '${e}' is not supported`,ie.ERR_NOT_SUPPORT,s)})})})(new Response);const L1=async t=>{if(t==null)return 0;if(G.isBlob(t))return t.size;if(G.isSpecCompliantForm(t))return(await new Request(We.origin,{method:"POST",body:t}).arrayBuffer()).byteLength;if(G.isArrayBufferView(t)||G.isArrayBuffer(t))return t.byteLength;if(G.isURLSearchParams(t)&&(t=t+""),G.isString(t))return(await N1(t)).byteLength},O1=async(t,e)=>{const i=G.toFiniteNumber(t.getContentLength());return i??L1(e)},z1=lr&&(async t=>{let{url:e,method:i,data:s,signal:r,cancelToken:n,timeout:a,onDownloadProgress:o,onUploadProgress:l,responseType:c,headers:h,withCredentials:d="same-origin",fetchOptions:f}=kl(t);c=c?(c+"").toLowerCase():"text";let u=U1([r,n&&n.toAbortSignal()],a),m;const g=u&&u.unsubscribe&&(()=>{u.unsubscribe()});let p;try{if(l&&k1&&i!=="get"&&i!=="head"&&(p=await O1(h,s))!==0){let v=new Request(e,{method:"POST",body:s,duplex:"half"}),D;if(G.isFormData(s)&&(D=v.headers.get("content-type"))&&h.setContentType(D),v.body){const[b,C]=qa(p,qs(Qa(l)));s=Za(v.body,Ja,b,C)}}G.isString(d)||(d=d?"include":"omit");const A="credentials"in Request.prototype;m=new Request(e,{...f,signal:u,method:i.toUpperCase(),headers:h.normalize().toJSON(),body:s,duplex:"half",credentials:A?d:void 0});let w=await fetch(m);const x=$r&&(c==="stream"||c==="response");if($r&&(o||x&&g)){const v={};["status","statusText","headers"].forEach(I=>{v[I]=w[I]});const D=G.toFiniteNumber(w.headers.get("content-length")),[b,C]=o&&qa(D,qs(Qa(o),!0))||[];w=new Response(Za(w.body,Ja,b,()=>{C&&C(),g&&g()}),v)}c=c||"text";let y=await Qs[G.findKey(Qs,c)||"text"](w,t);return!x&&g&&g(),await new Promise((v,D)=>{Rl(v,D,{data:y,headers:et.from(w.headers),status:w.status,statusText:w.statusText,config:t,request:m})})}catch(A){throw g&&g(),A&&A.name==="TypeError"&&/Load failed|fetch/i.test(A.message)?Object.assign(new ie("Network Error",ie.ERR_NETWORK,t,m),{cause:A.cause||A}):ie.from(A,A&&A.code,t,m)}}),en={http:t1,xhr:B1,fetch:z1};G.forEach(en,(t,e)=>{if(t){try{Object.defineProperty(t,"name",{value:e})}catch{}Object.defineProperty(t,"adapterName",{value:e})}});const _a=t=>`- ${t}`,G1=t=>G.isFunction(t)||t===null||t===!1,zl={getAdapter:t=>{t=G.isArray(t)?t:[t];const{length:e}=t;let i,s;const r={};for(let n=0;n<e;n++){i=t[n];let a;if(s=i,!G1(i)&&(s=en[(a=String(i)).toLowerCase()],s===void 0))throw new ie(`Unknown adapter '${a}'`);if(s)break;r[a||"#"+n]=s}if(!s){const n=Object.entries(r).map(([o,l])=>`adapter ${o} `+(l===!1?"is not supported by the environment":"is not available in the build"));let a=e?n.length>1?`since :
`+n.map(_a).join(`
`):" "+_a(n[0]):"as no adapter specified";throw new ie("There is no suitable adapter to dispatch the request "+a,"ERR_NOT_SUPPORT")}return s},adapters:en};function Pr(t){if(t.cancelToken&&t.cancelToken.throwIfRequested(),t.signal&&t.signal.aborted)throw new pi(null,t)}function $a(t){return Pr(t),t.headers=et.from(t.headers),t.data=Ur.call(t,t.transformRequest),["post","put","patch"].indexOf(t.method)!==-1&&t.headers.setContentType("application/x-www-form-urlencoded",!1),zl.getAdapter(t.adapter||os.adapter)(t).then(function(s){return Pr(t),s.data=Ur.call(t,t.transformResponse,s),s.headers=et.from(s.headers),s},function(s){return Vl(s)||(Pr(t),s&&s.response&&(s.response.data=Ur.call(t,t.transformResponse,s.response),s.response.headers=et.from(s.response.headers))),Promise.reject(s)})}const Gl="1.9.0",cr={};["object","boolean","number","function","string","symbol"].forEach((t,e)=>{cr[t]=function(s){return typeof s===t||"a"+(e<1?"n ":" ")+t}});const eo={};cr.transitional=function(e,i,s){function r(n,a){return"[Axios v"+Gl+"] Transitional option '"+n+"'"+a+(s?". "+s:"")}return(n,a,o)=>{if(e===!1)throw new ie(r(a," has been removed"+(i?" in "+i:"")),ie.ERR_DEPRECATED);return i&&!eo[a]&&(eo[a]=!0,console.warn(r(a," has been deprecated since v"+i+" and will be removed in the near future"))),e?e(n,a,o):!0}};cr.spelling=function(e){return(i,s)=>(console.warn(`${s} is likely a misspelling of ${e}`),!0)};function Y1(t,e,i){if(typeof t!="object")throw new ie("options must be an object",ie.ERR_BAD_OPTION_VALUE);const s=Object.keys(t);let r=s.length;for(;r-- >0;){const n=s[r],a=e[n];if(a){const o=t[n],l=o===void 0||a(o,n,t);if(l!==!0)throw new ie("option "+n+" must be "+l,ie.ERR_BAD_OPTION_VALUE);continue}if(i!==!0)throw new ie("Unknown option "+n,ie.ERR_BAD_OPTION)}}const Vs={assertOptions:Y1,validators:cr},pt=Vs.validators;let qt=class{constructor(e){this.defaults=e||{},this.interceptors={request:new ja,response:new ja}}async request(e,i){try{return await this._request(e,i)}catch(s){if(s instanceof Error){let r={};Error.captureStackTrace?Error.captureStackTrace(r):r=new Error;const n=r.stack?r.stack.replace(/^.+\n/,""):"";try{s.stack?n&&!String(s.stack).endsWith(n.replace(/^.+\n.+\n/,""))&&(s.stack+=`
`+n):s.stack=n}catch{}}throw s}}_request(e,i){typeof e=="string"?(i=i||{},i.url=e):i=e||{},i=Jt(this.defaults,i);const{transitional:s,paramsSerializer:r,headers:n}=i;s!==void 0&&Vs.assertOptions(s,{silentJSONParsing:pt.transitional(pt.boolean),forcedJSONParsing:pt.transitional(pt.boolean),clarifyTimeoutError:pt.transitional(pt.boolean)},!1),r!=null&&(G.isFunction(r)?i.paramsSerializer={serialize:r}:Vs.assertOptions(r,{encode:pt.function,serialize:pt.function},!0)),i.allowAbsoluteUrls!==void 0||(this.defaults.allowAbsoluteUrls!==void 0?i.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:i.allowAbsoluteUrls=!0),Vs.assertOptions(i,{baseUrl:pt.spelling("baseURL"),withXsrfToken:pt.spelling("withXSRFToken")},!0),i.method=(i.method||this.defaults.method||"get").toLowerCase();let a=n&&G.merge(n.common,n[i.method]);n&&G.forEach(["delete","get","head","post","put","patch","common"],m=>{delete n[m]}),i.headers=et.concat(a,n);const o=[];let l=!0;this.interceptors.request.forEach(function(g){typeof g.runWhen=="function"&&g.runWhen(i)===!1||(l=l&&g.synchronous,o.unshift(g.fulfilled,g.rejected))});const c=[];this.interceptors.response.forEach(function(g){c.push(g.fulfilled,g.rejected)});let h,d=0,f;if(!l){const m=[$a.bind(this),void 0];for(m.unshift.apply(m,o),m.push.apply(m,c),f=m.length,h=Promise.resolve(i);d<f;)h=h.then(m[d++],m[d++]);return h}f=o.length;let u=i;for(d=0;d<f;){const m=o[d++],g=o[d++];try{u=m(u)}catch(p){g.call(this,p);break}}try{h=$a.call(this,u)}catch(m){return Promise.reject(m)}for(d=0,f=c.length;d<f;)h=h.then(c[d++],c[d++]);return h}getUri(e){e=Jt(this.defaults,e);const i=Nl(e.baseURL,e.url,e.allowAbsoluteUrls);return Bl(i,e.params,e.paramsSerializer)}};G.forEach(["delete","get","head","options"],function(e){qt.prototype[e]=function(i,s){return this.request(Jt(s||{},{method:e,url:i,data:(s||{}).data}))}});G.forEach(["post","put","patch"],function(e){function i(s){return function(n,a,o){return this.request(Jt(o||{},{method:e,headers:s?{"Content-Type":"multipart/form-data"}:{},url:n,data:a}))}}qt.prototype[e]=i(),qt.prototype[e+"Form"]=i(!0)});let W1=class Yl{constructor(e){if(typeof e!="function")throw new TypeError("executor must be a function.");let i;this.promise=new Promise(function(n){i=n});const s=this;this.promise.then(r=>{if(!s._listeners)return;let n=s._listeners.length;for(;n-- >0;)s._listeners[n](r);s._listeners=null}),this.promise.then=r=>{let n;const a=new Promise(o=>{s.subscribe(o),n=o}).then(r);return a.cancel=function(){s.unsubscribe(n)},a},e(function(n,a,o){s.reason||(s.reason=new pi(n,a,o),i(s.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const i=this._listeners.indexOf(e);i!==-1&&this._listeners.splice(i,1)}toAbortSignal(){const e=new AbortController,i=s=>{e.abort(s)};return this.subscribe(i),e.signal.unsubscribe=()=>this.unsubscribe(i),e.signal}static source(){let e;return{token:new Yl(function(r){e=r}),cancel:e}}};function K1(t){return function(i){return t.apply(null,i)}}function j1(t){return G.isObject(t)&&t.isAxiosError===!0}const tn={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(tn).forEach(([t,e])=>{tn[e]=t});function Wl(t){const e=new qt(t),i=xl(qt.prototype.request,e);return G.extend(i,qt.prototype,e,{allOwnKeys:!0}),G.extend(i,e,null,{allOwnKeys:!0}),i.create=function(r){return Wl(Jt(t,r))},i}const we=Wl(os);we.Axios=qt;we.CanceledError=pi;we.CancelToken=W1;we.isCancel=Vl;we.VERSION=Gl;we.toFormData=or;we.AxiosError=ie;we.Cancel=we.CanceledError;we.all=function(e){return Promise.all(e)};we.spread=K1;we.isAxiosError=j1;we.mergeConfig=Jt;we.AxiosHeaders=et;we.formToJSON=t=>Pl(G.isHTMLForm(t)?new FormData(t):t);we.getAdapter=zl.getAdapter;we.HttpStatusCode=tn;we.default=we;const{Axios:p2,AxiosError:A2,CanceledError:w2,isCancel:x2,CancelToken:y2,VERSION:v2,all:b2,Cancel:C2,isAxiosError:S2,spread:E2,toFormData:D2,AxiosHeaders:T2,HttpStatusCode:M2,formToJSON:I2,getAdapter:F2,mergeConfig:B2}=we;async function Kl(t,e){const i=t;let s=null;if(i==null)s=new Worker(new URL(""+new URL("itk-wasm-pipeline.worker-DMDuBQeQ.js",import.meta.url).href,import.meta.url),{type:"module"});else if(i.startsWith("http")){const r=await we.get(i,{responseType:"blob",params:e}),n=URL.createObjectURL(r.data);s=new Worker(n,{type:"module"})}else s=new Worker(i,{type:"module"});return s}function to(t){const e=Pn(t),i=t;return i.terminated=!1,i.workerProxy=e,i.originalTerminate=i.terminate,i.terminate=()=>{i.terminated=!0,i.workerProxy[Un](),i.originalTerminate()},{workerProxy:e,worker:i}}async function H1(t,e,i){let s;if(t!=null){const n=t;return n.workerProxy!==void 0?(s=n.workerProxy,{workerProxy:s,worker:n}):to(t)}const r=await Kl(e,i);return to(r)}async function q1(t,e,i){let s="unknown";typeof t!="string"?s=t.href:t.startsWith("http")?s=t:s=typeof e<"u"?`${e}/${t}`:t,s.endsWith(".js")&&(s=s.substring(0,s.length-3)),s.endsWith(".wasm")&&(s=s.substring(0,s.length-5));const r=`${s}.wasm`,a=(await we.get(r,{responseType:"arraybuffer",params:i})).data;return(await import(`${s}.js`)).default({wasmBinary:a})}const jl=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),Hl=typeof globalThis.SharedArrayBuffer=="function",io=new TextEncoder,so=new TextDecoder("utf-8");function Q1(t,e){const i={flags:"r"},s=t.fs_open(e,i.flags),n=t.fs_stat(e).size;let a=null;Hl?a=new SharedArrayBuffer(n):a=new ArrayBuffer(n);const o=new Uint8Array(a);return t.fs_read(s,o,0,n,0),t.fs_close(s),o}function ql(t,e,i){let s=null;Hl?s=new SharedArrayBuffer(i):s=new ArrayBuffer(i);const r=new Uint8Array(s),n=new Uint8Array(t.HEAPU8.buffer,e,i);return r.set(n),r}function Ee(t,e,i,s){let r=0;return e!==null&&(r=t.ccall("itk_wasm_input_array_alloc","number",["number","number","number","number"],[0,i,s,e.buffer.byteLength]),t.HEAPU8.set(new Uint8Array(e.buffer),r)),r}function Bt(t,e,i){const s=JSON.stringify(e),r=t.lengthBytesUTF8(s)+1,n=t.ccall("itk_wasm_input_json_alloc","number",["number","number","number"],[0,i,r]);t.stringToUTF8(s,n,r)}function Oe(t,e,i,s){const r=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,e,i]),n=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,e,i]),a=ql(t,r,n);return Et(s,a.buffer)}function Si(t,e){const i=t.ccall("itk_wasm_output_json_address","number",["number","number"],[0,e]),s=t.UTF8ToString(i);return JSON.parse(s)}function X1(t,e,i,s){s!=null&&s.length>0&&s.forEach(function(c,h){var d;switch(c.type){case he.TextStream:{const f=io.encode(c.data.data),u=Ee(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Bt(t,m,h);break}case he.JsonCompatible:{const f=io.encode(JSON.stringify(c.data)),u=Ee(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Bt(t,m,h);break}case he.BinaryStream:{const f=c.data.data,u=Ee(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Bt(t,m,h);break}case he.TextFile:{t.fs_writeFile(c.data.path,c.data.data);break}case he.BinaryFile:{t.fs_writeFile(c.data.path,c.data.data);break}case he.Image:{const f=c.data,u=Ee(t,f.data,h,0),m=Ee(t,f.direction,h,1),g=typeof((d=f.metadata)==null?void 0:d.entries)<"u"?Array.from(f.metadata.entries()):[],p={imageType:f.imageType,name:f.name,origin:f.origin,spacing:f.spacing,direction:`data:application/vnd.itk.address,0:${m}`,size:f.size,data:`data:application/vnd.itk.address,0:${u}`,metadata:g};Bt(t,p,h);break}case he.Mesh:{const f=c.data,u=Ee(t,f.points,h,0),m=Ee(t,f.cells,h,1),g=Ee(t,f.pointData,h,2),p=Ee(t,f.cellData,h,3),A={meshType:f.meshType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,numberOfCells:f.numberOfCells,cells:`data:application/vnd.itk.address,0:${m}`,cellBufferSize:f.cellBufferSize,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${g}`,numberOfCellPixels:f.numberOfCellPixels,cellData:`data:application/vnd.itk.address,0:${p}`};Bt(t,A,h);break}case he.PointSet:{const f=c.data,u=Ee(t,f.points,h,0),m=Ee(t,f.pointData,h,1),g={pointSetType:f.pointSetType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${m}`};Bt(t,g,h);break}case he.TransformList:{const f=c.data,u=[];f.forEach((m,g)=>{const A=`data:application/vnd.itk.address,0:${Ee(t,m.fixedParameters,h,g*2)}`,x=`data:application/vnd.itk.address,0:${Ee(t,m.parameters,h,g*2+1)}`,y={transformType:m.transformType,numberOfFixedParameters:m.numberOfFixedParameters,numberOfParameters:m.numberOfParameters,name:m.name,inputSpaceName:m.inputSpaceName,outputSpaceName:m.outputSpaceName,parameters:x,fixedParameters:A};u.push(y)}),Bt(t,u,h);break}case he.PolyData:{const f=c.data,u=Ee(t,f.points,h,0),m=Ee(t,f.vertices,h,1),g=Ee(t,f.lines,h,2),p=Ee(t,f.polygons,h,3),A=Ee(t,f.triangleStrips,h,4),w=Ee(t,f.pointData,h,5),x=Ee(t,f.pointData,h,6),y={polyDataType:f.polyDataType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,verticesBufferSize:f.verticesBufferSize,vertices:`data:application/vnd.itk.address,0:${m}`,linesBufferSize:f.linesBufferSize,lines:`data:application/vnd.itk.address,0:${g}`,polygonsBufferSize:f.polygonsBufferSize,polygons:`data:application/vnd.itk.address,0:${p}`,triangleStripsBufferSize:f.triangleStripsBufferSize,triangleStrips:`data:application/vnd.itk.address,0:${A}`,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${w}`,numberOfCellPixels:f.numberOfCellPixels,cellData:`data:application/vnd.itk.address,0:${x}`};Bt(t,y,h);break}default:throw Error("Unsupported input InterfaceType")}}),t.resetModuleStdout(),t.resetModuleStderr();const r=t.stackSave();let n=0;try{n=t.callMain(e.slice())}catch(c){throw typeof c=="number"&&(console.log("Exception while running pipeline:"),console.log("stdout:",t.getModuleStdout()),console.error("stderr:",t.getModuleStderr()),typeof t.getExceptionMessage<"u"?console.error("exception:",t.getExceptionMessage(c)):console.error("Build module in Debug mode for exception message information.")),c}finally{t.stackRestore(r)}const a=t.getModuleStdout(),o=t.getModuleStderr(),l=[];return i!=null&&i.length>0&&n===0&&i.forEach(function(c,h){let d=null;switch(c.type){case he.TextStream:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]),g=new Uint8Array(t.HEAPU8.buffer,u,m);d={data:so.decode(g)};break}case he.JsonCompatible:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]),g=new Uint8Array(t.HEAPU8.buffer,u,m);d=JSON.parse(so.decode(g));break}case he.BinaryStream:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]);d={data:ql(t,u,m)};break}case he.TextFile:{d={path:c.data.path,data:t.fs_readFile(c.data.path,{encoding:"utf8"})};break}case he.BinaryFile:{d={path:c.data.path,data:Q1(t,c.data.path)};break}case he.Image:{const u=Si(t,h);u.data=Oe(t,h,0,u.imageType.componentType),u.direction=Oe(t,h,1,Ws.Float64),u.metadata=new Map(u.metadata),d=u;break}case he.Mesh:{const u=Si(t,h);u.numberOfPoints>0?u.points=Oe(t,h,0,u.meshType.pointComponentType):u.points=Et(u.meshType.pointComponentType,new ArrayBuffer(0)),u.numberOfCells>0?u.cells=Oe(t,h,1,u.meshType.cellComponentType):u.cells=Et(u.meshType.cellComponentType,new ArrayBuffer(0)),u.numberOfPointPixels>0?u.pointData=Oe(t,h,2,u.meshType.pointPixelComponentType):u.pointData=Et(u.meshType.pointPixelComponentType,new ArrayBuffer(0)),u.numberOfCellPixels>0?u.cellData=Oe(t,h,3,u.meshType.cellPixelComponentType):u.cellData=Et(u.meshType.cellPixelComponentType,new ArrayBuffer(0)),d=u;break}case he.PointSet:{const u=Si(t,h);u.numberOfPoints>0?u.points=Oe(t,h,0,u.pointSetType.pointComponentType):u.points=Et(u.pointSetType.pointComponentType,new ArrayBuffer(0)),u.numberOfPointPixels>0?u.pointData=Oe(t,h,1,u.pointSetType.pointPixelComponentType):u.pointData=Et(u.pointSetType.pointPixelComponentType,new ArrayBuffer(0)),d=u;break}case he.TransformList:{const u=Si(t,h);u.forEach((m,g)=>{m.numberOfFixedParameters>0&&(u[g].fixedParameters=Oe(t,h,g*2,m.transformType.parametersValueType)),m.numberOfFixedParameters>0&&(u[g].parameters=Oe(t,h,g*2+1,m.transformType.parametersValueType))}),d=u;break}case he.PolyData:{const u=Si(t,h);u.numberOfPoints>0?u.points=Oe(t,h,0,Ws.Float32):u.points=new Float32Array,u.verticesBufferSize>0?u.vertices=Oe(t,h,1,ot.UInt32):u.vertices=new Uint32Array,u.linesBufferSize>0?u.lines=Oe(t,h,2,ot.UInt32):u.lines=new Uint32Array,u.polygonsBufferSize>0?u.polygons=Oe(t,h,3,ot.UInt32):u.polygons=new Uint32Array,u.triangleStripsBufferSize>0?u.triangleStrips=Oe(t,h,4,ot.UInt32):u.triangleStrips=new Uint32Array,u.numberOfPointPixels>0?u.pointData=Oe(t,h,5,u.polyDataType.pointPixelComponentType):u.pointData=Et(u.polyDataType.pointPixelComponentType,new ArrayBuffer(0)),u.numberOfCellPixels>0?u.cellData=Oe(t,h,6,u.polyDataType.cellPixelComponentType):u.cellData=Et(u.polyDataType.cellPixelComponentType,new ArrayBuffer(0)),d=u;break}default:throw Error("Unsupported output InterfaceType")}const f={type:c.type,data:d};l.push(f)}),{returnValue:n,stdout:a,stderr:o,outputs:l}}const Z1=typeof globalThis.SharedArrayBuffer<"u";function J1(t,e){if(t==null)return[];const i=[];for(let s=0;s<t.length;s++){const r=_1(t[s],e);r!==null&&i.push(r)}return i}function _1(t,e){if(t==null)return null;let i=null;return t.buffer!==void 0?i=t.buffer:t.byteLength!==void 0&&(i=t),Z1&&i instanceof SharedArrayBuffer?null:e?i:i.slice(0)}function $1(t){return[t.data,t.direction]}function em(t){return[t.points,t.pointData,t.cells,t.cellData]}function tm(t){return[t.points,t.vertices,t.lines,t.polygons,t.triangleStrips,t.pointData,t.cellData]}let im;function sm(){return im}let rm;function nm(){return rm}let am;function om(){return am}const Vr=new Map;function lm(){let t=om();return typeof t>"u"&&(t=null),t}function Ql(){let t=sm();return typeof t>"u"&&(t=new URL("/pipelines",document.location.origin).href),t}function Rs(){let t=nm();return typeof t>"u"&&(t={}),t}async function cm(t,e,i){let s=t,r=t;if(typeof t!="string"&&(s=new URL(t.href),r=s.href),Vr.has(r))return Vr.get(r);{const n=await q1(t,(e==null?void 0:e.toString())??Ql(),i??Rs());return Vr.set(r,n),n}}async function Xl(t,e,i,s,r){if(!await jl()){const p="WebAssembly SIMD support is required -- please update your browser.";throw alert(p),new Error(p)}const n=(r==null?void 0:r.webWorker)??null;if(n===!1){const p=await cm(t.toString(),r==null?void 0:r.pipelineBaseUrl,(r==null?void 0:r.pipelineQueryParams)??Rs());return X1(p,e,i,s)}let a=n;const o=(r==null?void 0:r.pipelineWorkerUrl)??lm(),l=typeof o!="string"&&typeof(o==null?void 0:o.href)<"u"?o.href:o,{workerProxy:c,worker:h}=await H1(a,l,(r==null?void 0:r.pipelineQueryParams)??Rs());a=h;const d=[];s!=null&&s.length>0&&s.forEach(function(p){if(p.type===he.BinaryStream){const A=p.data.data;d.push(A)}else if(p.type===he.BinaryFile){const A=p.data.data;d.push(A)}else if(p.type===he.Image){const A=p.data;A.data!==null&&d.push(...$1(A))}else if(p.type===he.Mesh){const A=p.data;d.push(...em(A))}else if(p.type===he.PolyData){const A=p.data;d.push(...tm(A))}});const f=(r==null?void 0:r.pipelineBaseUrl)??Ql(),u=typeof f!="string"&&typeof(f==null?void 0:f.href)<"u"?f.href:f,m=s!=null?Vn(s,J1(d,r==null?void 0:r.noCopy)):null,g=await c.runPipeline(t.toString(),u,e,i,m,(r==null?void 0:r.pipelineQueryParams)??Rs());return{returnValue:g.returnValue,stdout:g.stdout,stderr:g.stderr,outputs:g.outputs,webWorker:a}}let sn,hm=`https://cdn.jsdelivr.net/npm/@itk-wasm/cuberille@${nu}/dist/pipelines`;function fm(t){sn=t}function Zl(){return typeof sn<"u"?sn:hm}const dm=null;function Ln(){return dm}let Bi=null;async function ro(){const t=Ln(),e=typeof t!="string"&&typeof(t==null?void 0:t.href)<"u"?t.href:t;Bi=await Kl(e)}async function Jl(){return Bi!==null?(Bi.terminated&&await ro(),Bi):(await ro(),Bi)}async function um(t,e={}){var m;const i=[{type:he.Mesh}],s=[{type:he.Image,data:t}],r=[];if(r.push("0"),r.push("0"),r.push("--memory-io"),e.interpolator){if(!["linear","bspline","windowed-sinc"].includes(e.interpolator))throw new Error('"interpolator" option must be one of linear, bspline, windowed-sinc');r.push("--interpolator",e.interpolator.toString())}e.maximumRmsError&&e.maximumRmsError&&r.push("--maximum-rms-error"),e.iterations&&e.iterations&&r.push("--iterations"),e.smoothingSigma&&r.push("--smoothing-sigma",e.smoothingSigma.toString()),e.noFillHoles&&e.noFillHoles&&r.push("--no-fill-holes"),e.noClosing&&e.noClosing&&r.push("--no-closing"),e.isoSurfaceValue&&e.isoSurfaceValue&&r.push("--iso-surface-value"),e.quadrilateralFaces&&e.quadrilateralFaces&&r.push("--quadrilateral-faces"),e.surfaceDistanceThreshold&&r.push("--surface-distance-threshold",e.surfaceDistanceThreshold.toString()),e.stepLength&&r.push("--step-length",e.stepLength.toString()),e.stepRelaxationFactor&&r.push("--step-relaxation-factor",e.stepRelaxationFactor.toString()),e.maximumSteps&&r.push("--maximum-steps",e.maximumSteps.toString());const o="anti-alias-cuberille";let l=e==null?void 0:e.webWorker;l===void 0&&(l=await Jl());const{webWorker:c,returnValue:h,stderr:d,outputs:f}=await Xl(o,r,i,s,{pipelineBaseUrl:Zl(),pipelineWorkerUrl:Ln(),webWorker:l,noCopy:e==null?void 0:e.noCopy});if(h!==0&&d!=="")throw new Error(d);return{webWorker:c,mesh:(m=f[0])==null?void 0:m.data}}async function mm(t,e={}){var m;const i=[{type:he.Mesh}],s=[{type:he.Image,data:t}],r=[];if(r.push("0"),r.push("0"),r.push("--memory-io"),e.interpolator){if(!["linear","bspline","windowed-sinc"].includes(e.interpolator))throw new Error('"interpolator" option must be one of linear, bspline, windowed-sinc');r.push("--interpolator",e.interpolator.toString())}e.isoSurfaceValue&&r.push("--iso-surface-value",e.isoSurfaceValue.toString()),e.quadrilateralFaces&&e.quadrilateralFaces&&r.push("--quadrilateral-faces"),e.noProjection&&e.noProjection&&r.push("--no-projection"),e.imagePixelToCellData&&e.imagePixelToCellData&&r.push("--image-pixel-to-cell-data"),e.surfaceDistanceThreshold&&r.push("--surface-distance-threshold",e.surfaceDistanceThreshold.toString()),e.stepLength&&r.push("--step-length",e.stepLength.toString()),e.stepRelaxationFactor&&r.push("--step-relaxation-factor",e.stepRelaxationFactor.toString()),e.maximumSteps&&r.push("--maximum-steps",e.maximumSteps.toString());const o="cuberille";let l=e==null?void 0:e.webWorker;l===void 0&&(l=await Jl());const{webWorker:c,returnValue:h,stderr:d,outputs:f}=await Xl(o,r,i,s,{pipelineBaseUrl:Zl(),pipelineWorkerUrl:Ln(),webWorker:l,noCopy:e==null?void 0:e.noCopy});if(h!==0&&d!=="")throw new Error(d);return{webWorker:c,mesh:(m=f[0])==null?void 0:m.data}}const gm="1.7.0",lt={Int8:"int8",UInt8:"uint8",Int16:"int16",UInt16:"uint16",Int32:"int32",UInt32:"uint32",Int64:"int64",UInt64:"uint64"},Xs={Float32:"float32",Float64:"float64"};function Dt(t,e){let i=null;switch(t){case lt.UInt8:{i=new Uint8Array(e);break}case lt.Int8:{i=new Int8Array(e);break}case lt.UInt16:{i=new Uint16Array(e);break}case lt.Int16:{i=new Int16Array(e);break}case lt.UInt32:{i=new Uint32Array(e);break}case lt.Int32:{i=new Int32Array(e);break}case lt.UInt64:{typeof globalThis.BigUint64Array=="function"?i=new BigUint64Array(e):i=new Uint8Array(e);break}case lt.Int64:{typeof globalThis.BigInt64Array=="function"?i=new BigInt64Array(e):i=new Uint8Array(e);break}case Xs.Float32:{i=new Float32Array(e);break}case Xs.Float64:{i=new Float64Array(e);break}case"null":{i=null;break}case null:{i=null;break}default:throw new Error("Type is not supported as a TypedArray")}return i}const le={TextFile:"TextFile",BinaryFile:"BinaryFile",TextStream:"TextStream",BinaryStream:"BinaryStream",Image:"Image",PointSet:"PointSet",Mesh:"Mesh",PolyData:"PolyData",TransformList:"TransformList",JsonCompatible:"JsonCompatible"};async function _l(t,e){const i=t;let s=null;if(i==null)s=new Worker(new URL(""+new URL("itk-wasm-pipeline.worker-DMDuBQeQ.js",import.meta.url).href,import.meta.url),{type:"module"});else if(i.startsWith("http")){const r=await we.get(i,{responseType:"blob",params:e}),n=URL.createObjectURL(r.data);s=new Worker(n,{type:"module"})}else s=new Worker(i,{type:"module"});return s}function no(t){const e=Pn(t),i=t;return i.terminated=!1,i.workerProxy=e,i.originalTerminate=i.terminate,i.terminate=()=>{i.terminated=!0,i.workerProxy[Un](),i.originalTerminate()},{workerProxy:e,worker:i}}async function pm(t,e,i){let s;if(t!=null){const n=t;return n.workerProxy!==void 0?(s=n.workerProxy,{workerProxy:s,worker:n}):no(t)}const r=await _l(e,i);return no(r)}async function Am(t,e,i){let s="unknown";typeof t!="string"?s=t.href:t.startsWith("http")?s=t:s=typeof e<"u"?`${e}/${t}`:t,s.endsWith(".js")&&(s=s.substring(0,s.length-3)),s.endsWith(".wasm")&&(s=s.substring(0,s.length-5));const r=`${s}.wasm`,a=(await we.get(r,{responseType:"arraybuffer",params:i})).data;return(await import(`${s}.js`)).default({wasmBinary:a})}const $l=typeof globalThis.SharedArrayBuffer=="function",ao=new TextEncoder,oo=new TextDecoder("utf-8");function wm(t,e){const i={flags:"r"},s=t.fs_open(e,i.flags),n=t.fs_stat(e).size;let a=null;$l?a=new SharedArrayBuffer(n):a=new ArrayBuffer(n);const o=new Uint8Array(a);return t.fs_read(s,o,0,n,0),t.fs_close(s),o}function ec(t,e,i){let s=null;$l?s=new SharedArrayBuffer(i):s=new ArrayBuffer(i);const r=new Uint8Array(s),n=new Uint8Array(t.HEAPU8.buffer,e,i);return r.set(n),r}function De(t,e,i,s){let r=0;return e!==null&&(r=t.ccall("itk_wasm_input_array_alloc","number",["number","number","number","number"],[0,i,s,e.buffer.byteLength]),t.HEAPU8.set(new Uint8Array(e.buffer),r)),r}function Ut(t,e,i){const s=JSON.stringify(e),r=t.lengthBytesUTF8(s)+1,n=t.ccall("itk_wasm_input_json_alloc","number",["number","number","number"],[0,i,r]);t.stringToUTF8(s,n,r)}function ze(t,e,i,s){const r=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,e,i]),n=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,e,i]),a=ec(t,r,n);return Dt(s,a.buffer)}function Ei(t,e){const i=t.ccall("itk_wasm_output_json_address","number",["number","number"],[0,e]),s=t.UTF8ToString(i);return JSON.parse(s)}function xm(t,e,i,s){s!=null&&s.length>0&&s.forEach(function(c,h){var d;switch(c.type){case le.TextStream:{const f=ao.encode(c.data.data),u=De(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Ut(t,m,h);break}case le.JsonCompatible:{const f=ao.encode(JSON.stringify(c.data)),u=De(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Ut(t,m,h);break}case le.BinaryStream:{const f=c.data.data,u=De(t,f,h,0),m={size:f.buffer.byteLength,data:`data:application/vnd.itk.address,0:${u}`};Ut(t,m,h);break}case le.TextFile:{t.fs_writeFile(c.data.path,c.data.data);break}case le.BinaryFile:{t.fs_writeFile(c.data.path,c.data.data);break}case le.Image:{const f=c.data,u=De(t,f.data,h,0),m=De(t,f.direction,h,1),g=typeof((d=f.metadata)==null?void 0:d.entries)<"u"?Array.from(f.metadata.entries()):[],p={imageType:f.imageType,name:f.name,origin:f.origin,spacing:f.spacing,direction:`data:application/vnd.itk.address,0:${m}`,size:f.size,data:`data:application/vnd.itk.address,0:${u}`,metadata:g};Ut(t,p,h);break}case le.Mesh:{const f=c.data,u=De(t,f.points,h,0),m=De(t,f.cells,h,1),g=De(t,f.pointData,h,2),p=De(t,f.cellData,h,3),A={meshType:f.meshType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,numberOfCells:f.numberOfCells,cells:`data:application/vnd.itk.address,0:${m}`,cellBufferSize:f.cellBufferSize,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${g}`,numberOfCellPixels:f.numberOfCellPixels,cellData:`data:application/vnd.itk.address,0:${p}`};Ut(t,A,h);break}case le.PointSet:{const f=c.data,u=De(t,f.points,h,0),m=De(t,f.pointData,h,1),g={pointSetType:f.pointSetType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${m}`};Ut(t,g,h);break}case le.TransformList:{const f=c.data,u=[];f.forEach((m,g)=>{const A=`data:application/vnd.itk.address,0:${De(t,m.fixedParameters,h,g*2)}`,x=`data:application/vnd.itk.address,0:${De(t,m.parameters,h,g*2+1)}`,y={transformType:m.transformType,numberOfFixedParameters:m.numberOfFixedParameters,numberOfParameters:m.numberOfParameters,name:m.name,inputSpaceName:m.inputSpaceName,outputSpaceName:m.outputSpaceName,parameters:x,fixedParameters:A};u.push(y)}),Ut(t,u,h);break}case le.PolyData:{const f=c.data,u=De(t,f.points,h,0),m=De(t,f.vertices,h,1),g=De(t,f.lines,h,2),p=De(t,f.polygons,h,3),A=De(t,f.triangleStrips,h,4),w=De(t,f.pointData,h,5),x=De(t,f.pointData,h,6),y={polyDataType:f.polyDataType,name:f.name,numberOfPoints:f.numberOfPoints,points:`data:application/vnd.itk.address,0:${u}`,verticesBufferSize:f.verticesBufferSize,vertices:`data:application/vnd.itk.address,0:${m}`,linesBufferSize:f.linesBufferSize,lines:`data:application/vnd.itk.address,0:${g}`,polygonsBufferSize:f.polygonsBufferSize,polygons:`data:application/vnd.itk.address,0:${p}`,triangleStripsBufferSize:f.triangleStripsBufferSize,triangleStrips:`data:application/vnd.itk.address,0:${A}`,numberOfPointPixels:f.numberOfPointPixels,pointData:`data:application/vnd.itk.address,0:${w}`,numberOfCellPixels:f.numberOfCellPixels,cellData:`data:application/vnd.itk.address,0:${x}`};Ut(t,y,h);break}default:throw Error("Unsupported input InterfaceType")}}),t.resetModuleStdout(),t.resetModuleStderr();const r=t.stackSave();let n=0;try{n=t.callMain(e.slice())}catch(c){throw typeof c=="number"&&(console.log("Exception while running pipeline:"),console.log("stdout:",t.getModuleStdout()),console.error("stderr:",t.getModuleStderr()),typeof t.getExceptionMessage<"u"?console.error("exception:",t.getExceptionMessage(c)):console.error("Build module in Debug mode for exception message information.")),c}finally{t.stackRestore(r)}const a=t.getModuleStdout(),o=t.getModuleStderr(),l=[];return i!=null&&i.length>0&&n===0&&i.forEach(function(c,h){let d=null;switch(c.type){case le.TextStream:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]),g=new Uint8Array(t.HEAPU8.buffer,u,m);d={data:oo.decode(g)};break}case le.JsonCompatible:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]),g=new Uint8Array(t.HEAPU8.buffer,u,m);d=JSON.parse(oo.decode(g));break}case le.BinaryStream:{const u=t.ccall("itk_wasm_output_array_address","number",["number","number","number"],[0,h,0]),m=t.ccall("itk_wasm_output_array_size","number",["number","number","number"],[0,h,0]);d={data:ec(t,u,m)};break}case le.TextFile:{d={path:c.data.path,data:t.fs_readFile(c.data.path,{encoding:"utf8"})};break}case le.BinaryFile:{d={path:c.data.path,data:wm(t,c.data.path)};break}case le.Image:{const u=Ei(t,h);u.data=ze(t,h,0,u.imageType.componentType),u.direction=ze(t,h,1,Xs.Float64),u.metadata=new Map(u.metadata),d=u;break}case le.Mesh:{const u=Ei(t,h);u.numberOfPoints>0?u.points=ze(t,h,0,u.meshType.pointComponentType):u.points=Dt(u.meshType.pointComponentType,new ArrayBuffer(0)),u.numberOfCells>0?u.cells=ze(t,h,1,u.meshType.cellComponentType):u.cells=Dt(u.meshType.cellComponentType,new ArrayBuffer(0)),u.numberOfPointPixels>0?u.pointData=ze(t,h,2,u.meshType.pointPixelComponentType):u.pointData=Dt(u.meshType.pointPixelComponentType,new ArrayBuffer(0)),u.numberOfCellPixels>0?u.cellData=ze(t,h,3,u.meshType.cellPixelComponentType):u.cellData=Dt(u.meshType.cellPixelComponentType,new ArrayBuffer(0)),d=u;break}case le.PointSet:{const u=Ei(t,h);u.numberOfPoints>0?u.points=ze(t,h,0,u.pointSetType.pointComponentType):u.points=Dt(u.pointSetType.pointComponentType,new ArrayBuffer(0)),u.numberOfPointPixels>0?u.pointData=ze(t,h,1,u.pointSetType.pointPixelComponentType):u.pointData=Dt(u.pointSetType.pointPixelComponentType,new ArrayBuffer(0)),d=u;break}case le.TransformList:{const u=Ei(t,h);u.forEach((m,g)=>{m.numberOfFixedParameters>0&&(u[g].fixedParameters=ze(t,h,g*2,m.transformType.parametersValueType)),m.numberOfFixedParameters>0&&(u[g].parameters=ze(t,h,g*2+1,m.transformType.parametersValueType))}),d=u;break}case le.PolyData:{const u=Ei(t,h);u.numberOfPoints>0?u.points=ze(t,h,0,Xs.Float32):u.points=new Float32Array,u.verticesBufferSize>0?u.vertices=ze(t,h,1,lt.UInt32):u.vertices=new Uint32Array,u.linesBufferSize>0?u.lines=ze(t,h,2,lt.UInt32):u.lines=new Uint32Array,u.polygonsBufferSize>0?u.polygons=ze(t,h,3,lt.UInt32):u.polygons=new Uint32Array,u.triangleStripsBufferSize>0?u.triangleStrips=ze(t,h,4,lt.UInt32):u.triangleStrips=new Uint32Array,u.numberOfPointPixels>0?u.pointData=ze(t,h,5,u.polyDataType.pointPixelComponentType):u.pointData=Dt(u.polyDataType.pointPixelComponentType,new ArrayBuffer(0)),u.numberOfCellPixels>0?u.cellData=ze(t,h,6,u.polyDataType.cellPixelComponentType):u.cellData=Dt(u.polyDataType.cellPixelComponentType,new ArrayBuffer(0)),d=u;break}default:throw Error("Unsupported output InterfaceType")}const f={type:c.type,data:d};l.push(f)}),{returnValue:n,stdout:a,stderr:o,outputs:l}}const ym=typeof globalThis.SharedArrayBuffer<"u";function vm(t,e){if(t==null)return[];const i=[];for(let s=0;s<t.length;s++){const r=bm(t[s],e);r!==null&&i.push(r)}return i}function bm(t,e){if(t==null)return null;let i=null;return t.buffer!==void 0?i=t.buffer:t.byteLength!==void 0&&(i=t),ym&&i instanceof SharedArrayBuffer?null:e?i:i.slice(0)}function Cm(t){return[t.data,t.direction]}function Sm(t){return[t.points,t.pointData,t.cells,t.cellData]}function Em(t){return[t.points,t.vertices,t.lines,t.polygons,t.triangleStrips,t.pointData,t.cellData]}let Dm;function Tm(){return Dm}let Mm;function Im(){return Mm}let Fm;function Bm(){return Fm}const Rr=new Map;function Um(){let t=Bm();return typeof t>"u"&&(t=null),t}function tc(){let t=Tm();return typeof t>"u"&&(t=new URL("/pipelines",document.location.origin).href),t}function Ns(){let t=Im();return typeof t>"u"&&(t={}),t}async function Pm(t,e,i){let s=t,r=t;if(typeof t!="string"&&(s=new URL(t.href),r=s.href),Rr.has(r))return Rr.get(r);{const n=await Am(t,(e==null?void 0:e.toString())??tc(),i??Ns());return Rr.set(r,n),n}}async function On(t,e,i,s,r){if(!await jl()){const p="WebAssembly SIMD support is required -- please update your browser.";throw alert(p),new Error(p)}const n=(r==null?void 0:r.webWorker)??null;if(n===!1){const p=await Pm(t.toString(),r==null?void 0:r.pipelineBaseUrl,(r==null?void 0:r.pipelineQueryParams)??Ns());return xm(p,e,i,s)}let a=n;const o=(r==null?void 0:r.pipelineWorkerUrl)??Um(),l=typeof o!="string"&&typeof(o==null?void 0:o.href)<"u"?o.href:o,{workerProxy:c,worker:h}=await pm(a,l,(r==null?void 0:r.pipelineQueryParams)??Ns());a=h;const d=[];s!=null&&s.length>0&&s.forEach(function(p){if(p.type===le.BinaryStream){const A=p.data.data;d.push(A)}else if(p.type===le.BinaryFile){const A=p.data.data;d.push(A)}else if(p.type===le.Image){const A=p.data;A.data!==null&&d.push(...Cm(A))}else if(p.type===le.Mesh){const A=p.data;d.push(...Sm(A))}else if(p.type===le.PolyData){const A=p.data;d.push(...Em(A))}});const f=(r==null?void 0:r.pipelineBaseUrl)??tc(),u=typeof f!="string"&&typeof(f==null?void 0:f.href)<"u"?f.href:f,m=s!=null?Vn(s,vm(d,r==null?void 0:r.noCopy)):null,g=await c.runPipeline(t.toString(),u,e,i,m,(r==null?void 0:r.pipelineQueryParams)??Ns());return{returnValue:g.returnValue,stdout:g.stdout,stderr:g.stderr,outputs:g.outputs,webWorker:a}}let rn,Vm=`https://cdn.jsdelivr.net/npm/@itk-wasm/mesh-filters@${gm}/dist/pipelines`;function Rm(t){rn=t}function zn(){return typeof rn<"u"?rn:Vm}const Nm=null;function hr(){return Nm}let Ui=null;async function lo(){const t=hr(),e=typeof t!="string"&&typeof(t==null?void 0:t.href)<"u"?t.href:t;Ui=await _l(e)}async function Gn(){return Ui!==null?(Ui.terminated&&await lo(),Ui):(await lo(),Ui)}async function km(t,e={}){var m;const i=[{type:le.Mesh}],s=[{type:le.Mesh,data:t}],r=[];r.push("0"),r.push("0"),r.push("--memory-io");const o="keep-largest-component";let l=e==null?void 0:e.webWorker;l===void 0&&(l=await Gn());const{webWorker:c,returnValue:h,stderr:d,outputs:f}=await On(o,r,i,s,{pipelineBaseUrl:zn(),pipelineWorkerUrl:hr(),webWorker:l,noCopy:e==null?void 0:e.noCopy});if(h!==0&&d!=="")throw new Error(d);return{webWorker:c,outputMesh:(m=f[0])==null?void 0:m.data}}async function co(t,e={}){var m;const i=[{type:le.Mesh}],s=[{type:le.Mesh,data:t}],r=[];r.push("0"),r.push("0"),r.push("--memory-io"),e.mergeTolerance&&r.push("--merge-tolerance",e.mergeTolerance.toString()),e.minimumComponentArea&&r.push("--minimum-component-area",e.minimumComponentArea.toString()),e.maximumHoleArea&&r.push("--maximum-hole-area",e.maximumHoleArea.toString()),e.maximumHoleEdges&&r.push("--maximum-hole-edges",e.maximumHoleEdges.toString()),e.maximumDegree3Distance&&r.push("--maximum-degree3-distance",e.maximumDegree3Distance.toString()),e.removeIntersectingTriangles&&e.removeIntersectingTriangles&&r.push("--remove-intersecting-triangles");const o="repair";let l=e==null?void 0:e.webWorker;l===void 0&&(l=await Gn());const{webWorker:c,returnValue:h,stderr:d,outputs:f}=await On(o,r,i,s,{pipelineBaseUrl:zn(),pipelineWorkerUrl:hr(),webWorker:l,noCopy:e==null?void 0:e.noCopy});if(h!==0&&d!=="")throw new Error(d);return{webWorker:c,outputMesh:(m=f[0])==null?void 0:m.data}}async function Lm(t,e={}){var m;const i=[{type:le.Mesh}],s=[{type:le.Mesh,data:t}],r=[];r.push("0"),r.push("0"),r.push("--memory-io"),e.numberPoints&&r.push("--number-points",e.numberPoints.toString()),e.triangleShapeAdaptation&&r.push("--triangle-shape-adaptation",e.triangleShapeAdaptation.toString()),e.triangleSizeAdaptation&&r.push("--triangle-size-adaptation",e.triangleSizeAdaptation.toString()),e.normalIterations&&r.push("--normal-iterations",e.normalIterations.toString()),e.lloydIterations&&r.push("--lloyd-iterations",e.lloydIterations.toString()),e.newtonIterations&&r.push("--newton-iterations",e.newtonIterations.toString()),e.newtonM&&r.push("--newton-m",e.newtonM.toString()),e.lfsSamples&&r.push("--lfs-samples",e.lfsSamples.toString());const o="smooth-remesh";let l=e==null?void 0:e.webWorker;l===void 0&&(l=await Gn());const{webWorker:c,returnValue:h,stderr:d,outputs:f}=await On(o,r,i,s,{pipelineBaseUrl:zn(),pipelineWorkerUrl:hr(),webWorker:l,noCopy:e==null?void 0:e.noCopy});if(h!==0&&d!=="")throw new Error(d);return{webWorker:c,outputMesh:(m=f[0])==null?void 0:m.data}}let nn;try{nn=new TextDecoder}catch{}let X,Qt,Y=0;const Om=105,zm=57342,Gm=57343,ho=57337,fo=6,ri={};let Di=11281e4,St=1681e4,re={},ye,Zs,Js=0,Gi=0,Be,ct,Te=[],an=[],_e,He,Pi,uo={useRecords:!1,mapsAsObjects:!0},Yi=!1,ic=2;try{new Function("")}catch{ic=1/0}class Wi{constructor(e){if(e&&((e.keyMap||e._keyMap)&&!e.useRecords&&(e.useRecords=!1,e.mapsAsObjects=!0),e.useRecords===!1&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.getStructures&&(e.getShared=e.getStructures),e.getShared&&!e.structures&&((e.structures=[]).uninitialized=!0),e.keyMap)){this.mapKey=new Map;for(let[i,s]of Object.entries(e.keyMap))this.mapKey.set(s,i)}Object.assign(this,e)}decodeKey(e){return this.keyMap&&this.mapKey.get(e)||e}encodeKey(e){return this.keyMap&&this.keyMap.hasOwnProperty(e)?this.keyMap[e]:e}encodeKeys(e){if(!this._keyMap)return e;let i=new Map;for(let[s,r]of Object.entries(e))i.set(this._keyMap.hasOwnProperty(s)?this._keyMap[s]:s,r);return i}decodeKeys(e){if(!this._keyMap||e.constructor.name!="Map")return e;if(!this._mapKey){this._mapKey=new Map;for(let[s,r]of Object.entries(this._keyMap))this._mapKey.set(r,s)}let i={};return e.forEach((s,r)=>i[ht(this._mapKey.has(r)?this._mapKey.get(r):r)]=s),i}mapDecode(e,i){let s=this.decode(e);if(this._keyMap)switch(s.constructor.name){case"Array":return s.map(r=>this.decodeKeys(r))}return s}decode(e,i){if(X)return ac(()=>(hn(),this?this.decode(e,i):Wi.prototype.decode.call(uo,e,i)));Qt=i>-1?i:e.length,Y=0,Gi=0,Zs=null,Be=null,X=e;try{He=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(s){throw X=null,e instanceof Uint8Array?s:new Error("Source must be a Uint8Array or Buffer but was a "+(e&&typeof e=="object"?e.constructor.name:typeof e))}if(this instanceof Wi){if(re=this,_e=this.sharedValues&&(this.pack?new Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures)return ye=this.structures,ys();(!ye||ye.length>0)&&(ye=[])}else re=uo,(!ye||ye.length>0)&&(ye=[]),_e=null;return ys()}decodeMultiple(e,i){let s,r=0;try{let n=e.length;Yi=!0;let a=this?this.decode(e,n):Kn.decode(e,n);if(i){if(i(a)===!1)return;for(;Y<n;)if(r=Y,i(ys())===!1)return}else{for(s=[a];Y<n;)r=Y,s.push(ys());return s}}catch(n){throw n.lastPosition=r,n.values=s,n}finally{Yi=!1,hn()}}}function ys(){try{let t=ae();if(Be){if(Y>=Be.postBundlePosition){let e=new Error("Unexpected bundle position");throw e.incomplete=!0,e}Y=Be.postBundlePosition,Be=null}if(Y==Qt)ye=null,X=null,ct&&(ct=null);else if(Y>Qt){let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}else if(!Yi)throw new Error("Data read, but end of buffer not reached");return t}catch(t){throw hn(),(t instanceof RangeError||t.message.startsWith("Unexpected end of buffer"))&&(t.incomplete=!0),t}}function ae(){let t=X[Y++],e=t>>5;if(t=t&31,t>23)switch(t){case 24:t=X[Y++];break;case 25:if(e==7)return jm();t=He.getUint16(Y),Y+=2;break;case 26:if(e==7){let i=He.getFloat32(Y);if(re.useFloat32>2){let s=Wn[(X[Y]&127)<<1|X[Y+1]>>7];return Y+=4,(s*i+(i>0?.5:-.5)>>0)/s}return Y+=4,i}t=He.getUint32(Y),Y+=4;break;case 27:if(e==7){let i=He.getFloat64(Y);return Y+=8,i}if(e>1){if(He.getUint32(Y)>0)throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");t=He.getUint32(Y+4)}else re.int64AsNumber?(t=He.getUint32(Y)*4294967296,t+=He.getUint32(Y+4)):t=He.getBigUint64(Y);Y+=8;break;case 31:switch(e){case 2:case 3:throw new Error("Indefinite length not supported for byte or text strings");case 4:let i=[],s,r=0;for(;(s=ae())!=ri;){if(r>=Di)throw new Error(`Array length exceeds ${Di}`);i[r++]=s}return e==4?i:e==3?i.join(""):Buffer.concat(i);case 5:let n;if(re.mapsAsObjects){let a={},o=0;if(re.keyMap)for(;(n=ae())!=ri;){if(o++>=St)throw new Error(`Property count exceeds ${St}`);a[ht(re.decodeKey(n))]=ae()}else for(;(n=ae())!=ri;){if(o++>=St)throw new Error(`Property count exceeds ${St}`);a[ht(n)]=ae()}return a}else{Pi&&(re.mapsAsObjects=!0,Pi=!1);let a=new Map;if(re.keyMap){let o=0;for(;(n=ae())!=ri;){if(o++>=St)throw new Error(`Map size exceeds ${St}`);a.set(re.decodeKey(n),ae())}}else{let o=0;for(;(n=ae())!=ri;){if(o++>=St)throw new Error(`Map size exceeds ${St}`);a.set(n,ae())}}return a}case 7:return ri;default:throw new Error("Invalid major type for indefinite length "+e)}default:throw new Error("Unknown token "+t)}switch(e){case 0:return t;case 1:return~t;case 2:return Km(t);case 3:if(Gi>=Y)return Zs.slice(Y-Js,(Y+=t)-Js);if(Gi==0&&Qt<140&&t<32){let r=t<16?sc(t):Wm(t);if(r!=null)return r}return Ym(t);case 4:if(t>=Di)throw new Error(`Array length exceeds ${Di}`);let i=new Array(t);for(let r=0;r<t;r++)i[r]=ae();return i;case 5:if(t>=St)throw new Error(`Map size exceeds ${Di}`);if(re.mapsAsObjects){let r={};if(re.keyMap)for(let n=0;n<t;n++)r[ht(re.decodeKey(ae()))]=ae();else for(let n=0;n<t;n++)r[ht(ae())]=ae();return r}else{Pi&&(re.mapsAsObjects=!0,Pi=!1);let r=new Map;if(re.keyMap)for(let n=0;n<t;n++)r.set(re.decodeKey(ae()),ae());else for(let n=0;n<t;n++)r.set(ae(),ae());return r}case 6:if(t>=ho){let r=ye[t&8191];if(r)return r.read||(r.read=on(r)),r.read();if(t<65536){if(t==Gm){let n=fi(),a=ae(),o=ae();cn(a,o);let l={};if(re.keyMap)for(let c=2;c<n;c++){let h=re.decodeKey(o[c-2]);l[ht(h)]=ae()}else for(let c=2;c<n;c++){let h=o[c-2];l[ht(h)]=ae()}return l}else if(t==zm){let n=fi(),a=ae();for(let o=2;o<n;o++)cn(a++,ae());return ae()}else if(t==ho)return Jm();if(re.getShared&&(Yn(),r=ye[t&8191],r))return r.read||(r.read=on(r)),r.read()}}let s=Te[t];if(s)return s.handlesRead?s(ae):s(ae());{let r=ae();for(let n=0;n<an.length;n++){let a=an[n](t,r);if(a!==void 0)return a}return new _t(r,t)}case 7:switch(t){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;case 31:default:let r=(_e||zt())[t];if(r!==void 0)return r;throw new Error("Unknown token "+t)}default:if(isNaN(t)){let r=new Error("Unexpected end of CBOR data");throw r.incomplete=!0,r}throw new Error("Unknown CBOR token "+t)}}const mo=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function on(t){if(!t)throw new Error("Structure is required in record definition");function e(){let i=X[Y++];if(i=i&31,i>23)switch(i){case 24:i=X[Y++];break;case 25:i=He.getUint16(Y),Y+=2;break;case 26:i=He.getUint32(Y),Y+=4;break;default:throw new Error("Expected array header, but got "+X[Y-1])}let s=this.compiledReader;for(;s;){if(s.propertyCount===i)return s(ae);s=s.next}if(this.slowReads++>=ic){let n=this.length==i?this:this.slice(0,i);return s=re.keyMap?new Function("r","return {"+n.map(a=>re.decodeKey(a)).map(a=>mo.test(a)?ht(a)+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}"):new Function("r","return {"+n.map(a=>mo.test(a)?ht(a)+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}"),this.compiledReader&&(s.next=this.compiledReader),s.propertyCount=i,this.compiledReader=s,s(ae)}let r={};if(re.keyMap)for(let n=0;n<i;n++)r[ht(re.decodeKey(this[n]))]=ae();else for(let n=0;n<i;n++)r[ht(this[n])]=ae();return r}return t.slowReads=0,e}function ht(t){if(typeof t=="string")return t==="__proto__"?"__proto_":t;if(typeof t=="number"||typeof t=="boolean"||typeof t=="bigint")return t.toString();if(t==null)return t+"";throw new Error("Invalid property name type "+typeof t)}let Ym=ln;function ln(t){let e;if(t<16&&(e=sc(t)))return e;if(t>64&&nn)return nn.decode(X.subarray(Y,Y+=t));const i=Y+t,s=[];for(e="";Y<i;){const r=X[Y++];if(!(r&128))s.push(r);else if((r&224)===192){const n=X[Y++]&63;s.push((r&31)<<6|n)}else if((r&240)===224){const n=X[Y++]&63,a=X[Y++]&63;s.push((r&31)<<12|n<<6|a)}else if((r&248)===240){const n=X[Y++]&63,a=X[Y++]&63,o=X[Y++]&63;let l=(r&7)<<18|n<<12|a<<6|o;l>65535&&(l-=65536,s.push(l>>>10&1023|55296),l=56320|l&1023),s.push(l)}else s.push(r);s.length>=4096&&(e+=Pe.apply(String,s),s.length=0)}return s.length>0&&(e+=Pe.apply(String,s)),e}let Pe=String.fromCharCode;function Wm(t){let e=Y,i=new Array(t);for(let s=0;s<t;s++){const r=X[Y++];if((r&128)>0){Y=e;return}i[s]=r}return Pe.apply(String,i)}function sc(t){if(t<4)if(t<2){if(t===0)return"";{let e=X[Y++];if((e&128)>1){Y-=1;return}return Pe(e)}}else{let e=X[Y++],i=X[Y++];if((e&128)>0||(i&128)>0){Y-=2;return}if(t<3)return Pe(e,i);let s=X[Y++];if((s&128)>0){Y-=3;return}return Pe(e,i,s)}else{let e=X[Y++],i=X[Y++],s=X[Y++],r=X[Y++];if((e&128)>0||(i&128)>0||(s&128)>0||(r&128)>0){Y-=4;return}if(t<6){if(t===4)return Pe(e,i,s,r);{let n=X[Y++];if((n&128)>0){Y-=5;return}return Pe(e,i,s,r,n)}}else if(t<8){let n=X[Y++],a=X[Y++];if((n&128)>0||(a&128)>0){Y-=6;return}if(t<7)return Pe(e,i,s,r,n,a);let o=X[Y++];if((o&128)>0){Y-=7;return}return Pe(e,i,s,r,n,a,o)}else{let n=X[Y++],a=X[Y++],o=X[Y++],l=X[Y++];if((n&128)>0||(a&128)>0||(o&128)>0||(l&128)>0){Y-=8;return}if(t<10){if(t===8)return Pe(e,i,s,r,n,a,o,l);{let c=X[Y++];if((c&128)>0){Y-=9;return}return Pe(e,i,s,r,n,a,o,l,c)}}else if(t<12){let c=X[Y++],h=X[Y++];if((c&128)>0||(h&128)>0){Y-=10;return}if(t<11)return Pe(e,i,s,r,n,a,o,l,c,h);let d=X[Y++];if((d&128)>0){Y-=11;return}return Pe(e,i,s,r,n,a,o,l,c,h,d)}else{let c=X[Y++],h=X[Y++],d=X[Y++],f=X[Y++];if((c&128)>0||(h&128)>0||(d&128)>0||(f&128)>0){Y-=12;return}if(t<14){if(t===12)return Pe(e,i,s,r,n,a,o,l,c,h,d,f);{let u=X[Y++];if((u&128)>0){Y-=13;return}return Pe(e,i,s,r,n,a,o,l,c,h,d,f,u)}}else{let u=X[Y++],m=X[Y++];if((u&128)>0||(m&128)>0){Y-=14;return}if(t<15)return Pe(e,i,s,r,n,a,o,l,c,h,d,f,u,m);let g=X[Y++];if((g&128)>0){Y-=15;return}return Pe(e,i,s,r,n,a,o,l,c,h,d,f,u,m,g)}}}}}function Km(t){return re.copyBuffers?Uint8Array.prototype.slice.call(X,Y,Y+=t):X.subarray(Y,Y+=t)}let rc=new Float32Array(1),vs=new Uint8Array(rc.buffer,0,4);function jm(){let t=X[Y++],e=X[Y++],i=(t&127)>>2;if(i===31)return e||t&3?NaN:t&128?-1/0:1/0;if(i===0){let s=((t&3)<<8|e)/16777216;return t&128?-s:s}return vs[3]=t&128|(i>>1)+56,vs[2]=(t&7)<<5|e>>3,vs[1]=e<<5,vs[0]=0,rc[0]}new Array(4096);class _t{constructor(e,i){this.value=e,this.tag=i}}Te[0]=t=>new Date(t);Te[1]=t=>new Date(Math.round(t*1e3));Te[2]=t=>{let e=BigInt(0);for(let i=0,s=t.byteLength;i<s;i++)e=BigInt(t[i])+(e<<BigInt(8));return e};Te[3]=t=>BigInt(-1)-Te[2](t);Te[4]=t=>+(t[1]+"e"+t[0]);Te[5]=t=>t[1]*Math.exp(t[0]*Math.log(2));const cn=(t,e)=>{t=t-57344;let i=ye[t];i&&i.isShared&&((ye.restoreStructures||(ye.restoreStructures=[]))[t]=i),ye[t]=e,e.read=on(e)};Te[Om]=t=>{let e=t.length,i=t[1];cn(t[0],i);let s={};for(let r=2;r<e;r++){let n=i[r-2];s[ht(n)]=t[r]}return s};Te[14]=t=>Be?Be[0].slice(Be.position0,Be.position0+=t):new _t(t,14);Te[15]=t=>Be?Be[1].slice(Be.position1,Be.position1+=t):new _t(t,15);let Hm={Error,RegExp};Te[27]=t=>(Hm[t[0]]||Error)(t[1],t[2]);const nc=t=>{if(X[Y++]!=132){let i=new Error("Packed values structure must be followed by a 4 element array");throw X.length<Y&&(i.incomplete=!0),i}let e=t();if(!e||!e.length){let i=new Error("Packed values structure must be followed by a 4 element array");throw i.incomplete=!0,i}return _e=_e?e.concat(_e.slice(e.length)):e,_e.prefixes=t(),_e.suffixes=t(),t()};nc.handlesRead=!0;Te[51]=nc;Te[fo]=t=>{if(!_e)if(re.getShared)Yn();else return new _t(t,fo);if(typeof t=="number")return _e[16+(t>=0?2*t:-2*t-1)];let e=new Error("No support for non-integer packed references yet");throw t===void 0&&(e.incomplete=!0),e};Te[28]=t=>{ct||(ct=new Map,ct.id=0);let e=ct.id++,i=Y,s=X[Y],r;s>>5==4?r=[]:r={};let n={target:r};ct.set(e,n);let a=t();return n.used?(Object.getPrototypeOf(r)!==Object.getPrototypeOf(a)&&(Y=i,r=a,ct.set(e,{target:r}),a=t()),Object.assign(r,a)):(n.target=a,a)};Te[28].handlesRead=!0;Te[29]=t=>{let e=ct.get(t);return e.used=!0,e.target};Te[258]=t=>new Set(t);(Te[259]=t=>(re.mapsAsObjects&&(re.mapsAsObjects=!1,Pi=!0),t())).handlesRead=!0;function ni(t,e){return typeof t=="string"?t+e:t instanceof Array?t.concat(e):Object.assign({},t,e)}function zt(){if(!_e)if(re.getShared)Yn();else throw new Error("No packed values available");return _e}const qm=1399353956;an.push((t,e)=>{if(t>=225&&t<=255)return ni(zt().prefixes[t-224],e);if(t>=28704&&t<=32767)return ni(zt().prefixes[t-28672],e);if(t>=1879052288&&t<=2147483647)return ni(zt().prefixes[t-1879048192],e);if(t>=216&&t<=223)return ni(e,zt().suffixes[t-216]);if(t>=27647&&t<=28671)return ni(e,zt().suffixes[t-27639]);if(t>=1811940352&&t<=1879048191)return ni(e,zt().suffixes[t-1811939328]);if(t==qm)return{packedValues:_e,structures:ye.slice(0),version:e};if(t==55799)return e});const Qm=new Uint8Array(new Uint16Array([1]).buffer)[0]==1,go=[Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,typeof BigUint64Array>"u"?{name:"BigUint64Array"}:BigUint64Array,Int8Array,Int16Array,Int32Array,typeof BigInt64Array>"u"?{name:"BigInt64Array"}:BigInt64Array,Float32Array,Float64Array],Xm=[64,68,69,70,71,72,77,78,79,85,86];for(let t=0;t<go.length;t++)Zm(go[t],Xm[t]);function Zm(t,e){let i="get"+t.name.slice(0,-5),s;typeof t=="function"?s=t.BYTES_PER_ELEMENT:t=null;for(let r=0;r<2;r++){if(!r&&s==1)continue;let n=s==2?1:s==4?2:s==8?3:0;Te[r?e:e-4]=s==1||r==Qm?a=>{if(!t)throw new Error("Could not find typed array for code "+e);return!re.copyBuffers&&(s===1||s===2&&!(a.byteOffset&1)||s===4&&!(a.byteOffset&3)||s===8&&!(a.byteOffset&7))?new t(a.buffer,a.byteOffset,a.byteLength>>n):new t(Uint8Array.prototype.slice.call(a,0).buffer)}:a=>{if(!t)throw new Error("Could not find typed array for code "+e);let o=new DataView(a.buffer,a.byteOffset,a.byteLength),l=a.length>>n,c=new t(l),h=o[i];for(let d=0;d<l;d++)c[d]=h.call(o,d<<n,r);return c}}}function Jm(){let t=fi(),e=Y+ae();for(let s=2;s<t;s++){let r=fi();Y+=r}let i=Y;return Y=e,Be=[ln(fi()),ln(fi())],Be.position0=0,Be.position1=0,Be.postBundlePosition=Y,Y=i,ae()}function fi(){let t=X[Y++]&31;if(t>23)switch(t){case 24:t=X[Y++];break;case 25:t=He.getUint16(Y),Y+=2;break;case 26:t=He.getUint32(Y),Y+=4;break}return t}function Yn(){if(re.getShared){let t=ac(()=>(X=null,re.getShared()))||{},e=t.structures||[];re.sharedVersion=t.version,_e=re.sharedValues=t.packedValues,ye===!0?re.structures=ye=e:ye.splice.apply(ye,[0,e.length].concat(e))}}function ac(t){let e=Qt,i=Y,s=Js,r=Gi,n=Zs,a=ct,o=Be,l=new Uint8Array(X.slice(0,Qt)),c=ye,h=re,d=Yi,f=t();return Qt=e,Y=i,Js=s,Gi=r,Zs=n,ct=a,Be=o,X=l,Yi=d,ye=c,re=h,He=new DataView(X.buffer,X.byteOffset,X.byteLength),f}function hn(){X=null,ct=null,ye=null}const Wn=new Array(147);for(let t=0;t<256;t++)Wn[t]=+("1e"+Math.floor(45.15-t*.30103));let Kn=new Wi({useRecords:!1});Kn.decode;Kn.decodeMultiple;let ks;try{ks=new TextEncoder}catch{}let fn,oc;const fr=typeof globalThis=="object"&&globalThis.Buffer,ls=typeof fr<"u",Nr=ls?fr.allocUnsafeSlow:Uint8Array,po=ls?fr:Uint8Array,Ao=256,wo=ls?4294967296:2144337920;let kr,O,me,N=0,Pt,Ie=null;const _m=61440,$m=/[\u0080-\uFFFF]/,it=Symbol("record-id");class e2 extends Wi{constructor(e){super(e),this.offset=0;let i,s,r,n,a;e=e||{};let o=po.prototype.utf8Write?function(E,B,P){return O.utf8Write(E,B,P)}:ks&&ks.encodeInto?function(E,B){return ks.encodeInto(E,O.subarray(B)).written}:!1,l=this,c=e.structures||e.saveStructures,h=e.maxSharedStructures;if(h==null&&(h=c?128:0),h>8190)throw new Error("Maximum maxSharedStructure is 8190");let d=e.sequential;d&&(h=0),this.structures||(this.structures=[]),this.saveStructures&&(this.saveShared=this.saveStructures);let f,u,m=e.sharedValues,g;if(m){g=Object.create(null);for(let E=0,B=m.length;E<B;E++)g[m[E]]=E}let p=[],A=0,w=0;this.mapEncode=function(E,B){if(this._keyMap&&!this._mapped)switch(E.constructor.name){case"Array":E=E.map(P=>this.encodeKeys(P));break}return this.encode(E,B)},this.encode=function(E,B){if(O||(O=new Nr(8192),me=new DataView(O.buffer,0,8192),N=0),Pt=O.length-10,Pt-N<2048?(O=new Nr(O.length),me=new DataView(O.buffer,0,O.length),Pt=O.length-10,N=0):B===vo&&(N=N+7&2147483640),i=N,l.useSelfDescribedHeader&&(me.setUint32(N,3654940416),N+=3),a=l.structuredClone?new Map:null,l.bundleStrings&&typeof E!="string"?(Ie=[],Ie.size=1/0):Ie=null,s=l.structures,s){if(s.uninitialized){let V=l.getShared()||{};l.structures=s=V.structures||[],l.sharedVersion=V.version;let R=l.sharedValues=V.packedValues;if(R){g={};for(let k=0,z=R.length;k<z;k++)g[R[k]]=k}}let P=s.length;if(P>h&&!d&&(P=h),!s.transitions){s.transitions=Object.create(null);for(let V=0;V<P;V++){let R=s[V];if(!R)continue;let k,z=s.transitions;for(let W=0,j=R.length;W<j;W++){z[it]===void 0&&(z[it]=V);let Q=R[W];k=z[Q],k||(k=z[Q]=Object.create(null)),z=k}z[it]=V|1048576}}d||(s.nextId=P)}if(r&&(r=!1),n=s||[],u=g,e.pack){let P=new Map;if(P.values=[],P.encoder=l,P.maxValues=e.maxPrivatePackedValues||(g?16:1/0),P.objectMap=g||!1,P.samplingPackedValues=f,Ls(E,P),P.values.length>0){O[N++]=216,O[N++]=51,vt(4);let V=P.values;x(V),vt(0),vt(0),u=Object.create(g||null);for(let R=0,k=V.length;R<k;R++)u[V[R]]=R}}kr=B&Or;try{if(kr)return;if(x(E),Ie&&yo(i,x),l.offset=N,a&&a.idsToInsert){N+=a.idsToInsert.length*2,N>Pt&&v(N),l.offset=N;let P=s2(O.subarray(i,N),a.idsToInsert);return a=null,P}return B&vo?(O.start=i,O.end=N,O):O.subarray(i,N)}finally{if(s){if(w<10&&w++,s.length>h&&(s.length=h),A>1e4)s.transitions=null,w=0,A=0,p.length>0&&(p=[]);else if(p.length>0&&!d){for(let P=0,V=p.length;P<V;P++)p[P][it]=void 0;p=[]}}if(r&&l.saveShared){l.structures.length>h&&(l.structures=l.structures.slice(0,h));let P=O.subarray(i,N);return l.updateSharedData()===!1?l.encode(E):P}B&n2&&(N=i)}},this.findCommonStringsToPack=()=>(f=new Map,g||(g=Object.create(null)),E=>{let B=E&&E.threshold||4,P=this.pack?E.maxPrivatePackedValues||16:0;m||(m=this.sharedValues=[]);for(let[V,R]of f)R.count>B&&(g[V]=P++,m.push(V),r=!0);for(;this.saveShared&&this.updateSharedData()===!1;);f=null});const x=E=>{N>Pt&&(O=v(N));var B=typeof E,P;if(B==="string"){if(u){let z=u[E];if(z>=0){z<16?O[N++]=z+224:(O[N++]=198,z&1?x(15-z>>1):x(z-16>>1));return}else if(f&&!e.pack){let W=f.get(E);W?W.count++:f.set(E,{count:1})}}let V=E.length;if(Ie&&V>=4&&V<1024){if((Ie.size+=V)>_m){let W,j=(Ie[0]?Ie[0].length*3+Ie[1].length:0)+10;N+j>Pt&&(O=v(N+j)),O[N++]=217,O[N++]=223,O[N++]=249,O[N++]=Ie.position?132:130,O[N++]=26,W=N-i,N+=4,Ie.position&&yo(i,x),Ie=["",""],Ie.size=0,Ie.position=W}let z=$m.test(E);Ie[z?0:1]+=E,O[N++]=z?206:207,x(V);return}let R;V<32?R=1:V<256?R=2:V<65536?R=3:R=5;let k=V*3;if(N+k>Pt&&(O=v(N+k)),V<64||!o){let z,W,j,Q=N+R;for(z=0;z<V;z++)W=E.charCodeAt(z),W<128?O[Q++]=W:W<2048?(O[Q++]=W>>6|192,O[Q++]=W&63|128):(W&64512)===55296&&((j=E.charCodeAt(z+1))&64512)===56320?(W=65536+((W&1023)<<10)+(j&1023),z++,O[Q++]=W>>18|240,O[Q++]=W>>12&63|128,O[Q++]=W>>6&63|128,O[Q++]=W&63|128):(O[Q++]=W>>12|224,O[Q++]=W>>6&63|128,O[Q++]=W&63|128);P=Q-N-R}else P=o(E,N+R,k);P<24?O[N++]=96|P:P<256?(R<2&&O.copyWithin(N+2,N+1,N+1+P),O[N++]=120,O[N++]=P):P<65536?(R<3&&O.copyWithin(N+3,N+2,N+2+P),O[N++]=121,O[N++]=P>>8,O[N++]=P&255):(R<5&&O.copyWithin(N+5,N+3,N+3+P),O[N++]=122,me.setUint32(N,P),N+=4),N+=P}else if(B==="number")if(!this.alwaysUseFloat&&E>>>0===E)E<24?O[N++]=E:E<256?(O[N++]=24,O[N++]=E):E<65536?(O[N++]=25,O[N++]=E>>8,O[N++]=E&255):(O[N++]=26,me.setUint32(N,E),N+=4);else if(!this.alwaysUseFloat&&E>>0===E)E>=-24?O[N++]=31-E:E>=-256?(O[N++]=56,O[N++]=~E):E>=-65536?(O[N++]=57,me.setUint16(N,~E),N+=2):(O[N++]=58,me.setUint32(N,~E),N+=4);else{let V;if((V=this.useFloat32)>0&&E<4294967296&&E>=-2147483648){O[N++]=250,me.setFloat32(N,E);let R;if(V<4||(R=E*Wn[(O[N]&127)<<1|O[N+1]>>7])>>0===R){N+=4;return}else N--}O[N++]=251,me.setFloat64(N,E),N+=8}else if(B==="object")if(!E)O[N++]=246;else{if(a){let R=a.get(E);if(R){if(O[N++]=216,O[N++]=29,O[N++]=25,!R.references){let k=a.idsToInsert||(a.idsToInsert=[]);R.references=[],k.push(R)}R.references.push(N-i),N+=2;return}else a.set(E,{offset:N-i})}let V=E.constructor;if(V===Object)y(E);else if(V===Array){P=E.length,P<24?O[N++]=128|P:vt(P);for(let R=0;R<P;R++)x(E[R])}else if(V===Map)if((this.mapsAsObjects?this.useTag259ForMaps!==!1:this.useTag259ForMaps)&&(O[N++]=217,O[N++]=1,O[N++]=3),P=E.size,P<24?O[N++]=160|P:P<256?(O[N++]=184,O[N++]=P):P<65536?(O[N++]=185,O[N++]=P>>8,O[N++]=P&255):(O[N++]=186,me.setUint32(N,P),N+=4),l.keyMap)for(let[R,k]of E)x(l.encodeKey(R)),x(k);else for(let[R,k]of E)x(R),x(k);else{for(let R=0,k=fn.length;R<k;R++){let z=oc[R];if(E instanceof z){let W=fn[R],j=W.tag;j==null&&(j=W.getTag&&W.getTag.call(this,E)),j<24?O[N++]=192|j:j<256?(O[N++]=216,O[N++]=j):j<65536?(O[N++]=217,O[N++]=j>>8,O[N++]=j&255):j>-1&&(O[N++]=218,me.setUint32(N,j),N+=4),W.encode.call(this,E,x,v);return}}if(E[Symbol.iterator]){if(kr){let R=new Error("Iterable should be serialized as iterator");throw R.iteratorNotHandled=!0,R}O[N++]=159;for(let R of E)x(R);O[N++]=255;return}if(E[Symbol.asyncIterator]||Lr(E)){let R=new Error("Iterable/blob should be serialized as iterator");throw R.iteratorNotHandled=!0,R}if(this.useToJSON&&E.toJSON){const R=E.toJSON();if(R!==E)return x(R)}y(E)}}else if(B==="boolean")O[N++]=E?245:244;else if(B==="bigint"){if(E<BigInt(1)<<BigInt(64)&&E>=0)O[N++]=27,me.setBigUint64(N,E);else if(E>-(BigInt(1)<<BigInt(64))&&E<0)O[N++]=59,me.setBigUint64(N,-E-BigInt(1));else if(this.largeBigIntToFloat)O[N++]=251,me.setFloat64(N,Number(E));else{E>=BigInt(0)?O[N++]=194:(O[N++]=195,E=BigInt(-1)-E);let V=[];for(;E;)V.push(Number(E&BigInt(255))),E>>=BigInt(8);dn(new Uint8Array(V.reverse()),v);return}N+=8}else if(B==="undefined")O[N++]=247;else throw new Error("Unknown type: "+B)},y=this.useRecords===!1?this.variableMapSize?E=>{let B=Object.keys(E),P=Object.values(E),V=B.length;if(V<24?O[N++]=160|V:V<256?(O[N++]=184,O[N++]=V):V<65536?(O[N++]=185,O[N++]=V>>8,O[N++]=V&255):(O[N++]=186,me.setUint32(N,V),N+=4),l.keyMap)for(let R=0;R<V;R++)x(l.encodeKey(B[R])),x(P[R]);else for(let R=0;R<V;R++)x(B[R]),x(P[R])}:E=>{O[N++]=185;let B=N-i;N+=2;let P=0;if(l.keyMap)for(let V in E)(typeof E.hasOwnProperty!="function"||E.hasOwnProperty(V))&&(x(l.encodeKey(V)),x(E[V]),P++);else for(let V in E)(typeof E.hasOwnProperty!="function"||E.hasOwnProperty(V))&&(x(V),x(E[V]),P++);O[B+++i]=P>>8,O[B+i]=P&255}:(E,B)=>{let P,V=n.transitions||(n.transitions=Object.create(null)),R=0,k=0,z,W;if(this.keyMap){W=Object.keys(E).map(Q=>this.encodeKey(Q)),k=W.length;for(let Q=0;Q<k;Q++){let pe=W[Q];P=V[pe],P||(P=V[pe]=Object.create(null),R++),V=P}}else for(let Q in E)(typeof E.hasOwnProperty!="function"||E.hasOwnProperty(Q))&&(P=V[Q],P||(V[it]&1048576&&(z=V[it]&65535),P=V[Q]=Object.create(null),R++),V=P,k++);let j=V[it];if(j!==void 0)j&=65535,O[N++]=217,O[N++]=j>>8|224,O[N++]=j&255;else if(W||(W=V.__keys__||(V.__keys__=Object.keys(E))),z===void 0?(j=n.nextId++,j||(j=0,n.nextId=1),j>=Ao&&(n.nextId=(j=h)+1)):j=z,n[j]=W,j<h){O[N++]=217,O[N++]=j>>8|224,O[N++]=j&255,V=n.transitions;for(let Q=0;Q<k;Q++)(V[it]===void 0||V[it]&1048576)&&(V[it]=j),V=V[W[Q]];V[it]=j|1048576,r=!0}else{if(V[it]=j,me.setUint32(N,3655335680),N+=3,R&&(A+=w*R),p.length>=Ao-h&&(p.shift()[it]=void 0),p.push(V),vt(k+2),x(57344+j),x(W),B)return;for(let Q in E)(typeof E.hasOwnProperty!="function"||E.hasOwnProperty(Q))&&x(E[Q]);return}if(k<24?O[N++]=128|k:vt(k),!B)for(let Q in E)(typeof E.hasOwnProperty!="function"||E.hasOwnProperty(Q))&&x(E[Q])},v=E=>{let B;if(E>16777216){if(E-i>wo)throw new Error("Encoded buffer would be larger than maximum buffer size");B=Math.min(wo,Math.round(Math.max((E-i)*(E>67108864?1.25:2),4194304)/4096)*4096)}else B=(Math.max(E-i<<2,O.length-1)>>12)+1<<12;let P=new Nr(B);return me=new DataView(P.buffer,0,B),O.copy?O.copy(P,0,i,E):P.set(O.slice(i,E)),N-=i,i=0,Pt=P.length-10,O=P};let D=100,b=1e3;this.encodeAsIterable=function(E,B){return T(E,B,C)},this.encodeAsAsyncIterable=function(E,B){return T(E,B,S)};function*C(E,B,P){let V=E.constructor;if(V===Object){let R=l.useRecords!==!1;R?y(E,!0):xo(Object.keys(E).length,160);for(let k in E){let z=E[k];R||x(k),z&&typeof z=="object"?B[k]?yield*C(z,B[k]):yield*I(z,B,k):x(z)}}else if(V===Array){let R=E.length;vt(R);for(let k=0;k<R;k++){let z=E[k];z&&(typeof z=="object"||N-i>D)?B.element?yield*C(z,B.element):yield*I(z,B,"element"):x(z)}}else if(E[Symbol.iterator]&&!E.buffer){O[N++]=159;for(let R of E)R&&(typeof R=="object"||N-i>D)?B.element?yield*C(R,B.element):yield*I(R,B,"element"):x(R);O[N++]=255}else Lr(E)?(xo(E.size,64),yield O.subarray(i,N),yield E,M()):E[Symbol.asyncIterator]?(O[N++]=159,yield O.subarray(i,N),yield E,M(),O[N++]=255):x(E);P&&N>i?yield O.subarray(i,N):N-i>D&&(yield O.subarray(i,N),M())}function*I(E,B,P){let V=N-i;try{x(E),N-i>D&&(yield O.subarray(i,N),M())}catch(R){if(R.iteratorNotHandled)B[P]={},N=i+V,yield*C.call(this,E,B[P]);else throw R}}function M(){D=b,l.encode(null,Or)}function T(E,B,P){return B&&B.chunkThreshold?D=b=B.chunkThreshold:D=100,E&&typeof E=="object"?(l.encode(null,Or),P(E,l.iterateProperties||(l.iterateProperties={}),!0)):[l.encode(E)]}async function*S(E,B){for(let P of C(E,B,!0)){let V=P.constructor;if(V===po||V===Uint8Array)yield P;else if(Lr(P)){let R=P.stream().getReader(),k;for(;!(k=await R.read()).done;)yield k.value}else if(P[Symbol.asyncIterator])for await(let R of P)M(),R?yield*S(R,B.async||(B.async={})):yield l.encode(R);else yield P}}}useBuffer(e){O=e,me=new DataView(O.buffer,O.byteOffset,O.byteLength),N=0}clearSharedData(){this.structures&&(this.structures=[]),this.sharedValues&&(this.sharedValues=void 0)}updateSharedData(){let e=this.sharedVersion||0;this.sharedVersion=e+1;let i=this.structures.slice(0),s=new lc(i,this.sharedValues,this.sharedVersion),r=this.saveShared(s,n=>(n&&n.version||0)==e);return r===!1?(s=this.getShared()||{},this.structures=s.structures||[],this.sharedValues=s.packedValues,this.sharedVersion=s.version,this.structures.nextId=this.structures.length):i.forEach((n,a)=>this.structures[a]=n),r}}function xo(t,e){t<24?O[N++]=e|t:t<256?(O[N++]=e|24,O[N++]=t):t<65536?(O[N++]=e|25,O[N++]=t>>8,O[N++]=t&255):(O[N++]=e|26,me.setUint32(N,t),N+=4)}class lc{constructor(e,i,s){this.structures=e,this.packedValues=i,this.version=s}}function vt(t){t<24?O[N++]=128|t:t<256?(O[N++]=152,O[N++]=t):t<65536?(O[N++]=153,O[N++]=t>>8,O[N++]=t&255):(O[N++]=154,me.setUint32(N,t),N+=4)}const t2=typeof Blob>"u"?function(){}:Blob;function Lr(t){if(t instanceof t2)return!0;let e=t[Symbol.toStringTag];return e==="Blob"||e==="File"}function Ls(t,e){switch(typeof t){case"string":if(t.length>3){if(e.objectMap[t]>-1||e.values.length>=e.maxValues)return;let s=e.get(t);if(s)++s.count==2&&e.values.push(t);else if(e.set(t,{count:1}),e.samplingPackedValues){let r=e.samplingPackedValues.get(t);r?r.count++:e.samplingPackedValues.set(t,{count:1})}}break;case"object":if(t)if(t instanceof Array)for(let s=0,r=t.length;s<r;s++)Ls(t[s],e);else{let s=!e.encoder.useRecords;for(var i in t)t.hasOwnProperty(i)&&(s&&Ls(i,e),Ls(t[i],e))}break;case"function":console.log(t)}}const i2=new Uint8Array(new Uint16Array([1]).buffer)[0]==1;oc=[Date,Set,Error,RegExp,_t,ArrayBuffer,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,typeof BigUint64Array>"u"?function(){}:BigUint64Array,Int8Array,Int16Array,Int32Array,typeof BigInt64Array>"u"?function(){}:BigInt64Array,Float32Array,Float64Array,lc];fn=[{tag:1,encode(t,e){let i=t.getTime()/1e3;(this.useTimestamp32||t.getMilliseconds()===0)&&i>=0&&i<4294967296?(O[N++]=26,me.setUint32(N,i),N+=4):(O[N++]=251,me.setFloat64(N,i),N+=8)}},{tag:258,encode(t,e){let i=Array.from(t);e(i)}},{tag:27,encode(t,e){e([t.name,t.message])}},{tag:27,encode(t,e){e(["RegExp",t.source,t.flags])}},{getTag(t){return t.tag},encode(t,e){e(t.value)}},{encode(t,e,i){dn(t,i)}},{getTag(t){if(t.constructor===Uint8Array&&(this.tagUint8Array||ls&&this.tagUint8Array!==!1))return 64},encode(t,e,i){dn(t,i)}},At(68,1),At(69,2),At(70,4),At(71,8),At(72,1),At(77,2),At(78,4),At(79,8),At(85,4),At(86,8),{encode(t,e){let i=t.packedValues||[],s=t.structures||[];if(i.values.length>0){O[N++]=216,O[N++]=51,vt(4);let r=i.values;e(r),vt(0),vt(0),packedObjectMap=Object.create(sharedPackedObjectMap||null);for(let n=0,a=r.length;n<a;n++)packedObjectMap[r[n]]=n}if(s){me.setUint32(N,3655335424),N+=3;let r=s.slice(0);r.unshift(57344),r.push(new _t(t.version,1399353956)),e(r)}else e(new _t(t.version,1399353956))}}];function At(t,e){return!i2&&e>1&&(t-=4),{tag:t,encode:function(s,r){let n=s.byteLength,a=s.byteOffset||0,o=s.buffer||s;r(ls?fr.from(o,a,n):new Uint8Array(o,a,n))}}}function dn(t,e){let i=t.byteLength;i<24?O[N++]=64+i:i<256?(O[N++]=88,O[N++]=i):i<65536?(O[N++]=89,O[N++]=i>>8,O[N++]=i&255):(O[N++]=90,me.setUint32(N,i),N+=4),N+i>=O.length&&e(N+i),O.set(t.buffer?t:new Uint8Array(t),N),N+=i}function s2(t,e){let i,s=e.length*2,r=t.length-s;e.sort((n,a)=>n.offset>a.offset?1:-1);for(let n=0;n<e.length;n++){let a=e[n];a.id=n;for(let o of a.references)t[o++]=n>>8,t[o]=n&255}for(;i=e.pop();){let n=i.offset;t.copyWithin(n+s,n,r),s-=2;let a=n+s;t[a++]=216,t[a++]=28,r=n}return t}function yo(t,e){me.setUint32(Ie.position+t,N-Ie.position-t+1);let i=Ie;Ie=null,e(i[0]),e(i[1])}let jn=new e2({useRecords:!1});const r2=jn.encode;jn.encodeAsIterable;jn.encodeAsAsyncIterable;const vo=512,n2=1024,Or=2048;function bo(t){if(!Object.prototype.hasOwnProperty.call(t,"meshType")||!Object.prototype.hasOwnProperty.call(t,"cells")||!Object.prototype.hasOwnProperty.call(t,"points"))throw new Error('.iwm.cbor must have "meshType", "cells" and "points".');let e;if(t.cells instanceof BigUint64Array||t.cells instanceof BigInt64Array){e=new Uint32Array(t.cells.length);for(let o=0;o<t.cells.length;o++)e[o]=Number(BigInt(t.cells[o])&BigInt(4294967295))}else if(t.cells[0]instanceof Uint32Array||typeof t.cells[0]=="number")e=new Uint32Array(t.cells);else throw new Error("Unsupported data type in iwm.cells");let i=0,s=0;for(;s<e.length;){const o=e[s],l=e[s+1];if(o<2||o<2||l<3)throw new Error(`unsupported iwm cell type ${o} or cellNum ${l}`);s+=l+2,i+=l-2}const r=new Uint32Array(i*3);s=0;let n=0;for(;s<e.length;){const o=e[s+1],l=o-2;for(let c=0;c<l;c++)r[n++]=e[s+2],r[n++]=e[s+2+1+c],r[n++]=e[s+2+2+c];s+=o+2}const a=new Float32Array(t.points);for(s=0;s<a.length;)a[s]=-a[s],a[s+1]=-a[s+1],s+=3;return{positions:a,indices:r}}function a2(t,e,i=!1){const s={imageType:{dimension:t.dims[0],componentType:"uint8",pixelType:"Scalar",components:1},direction:new Float64Array(9),origin:[],size:[],spacing:[],metadata:[]};for(let r=0;r<t.dims[0];r++)s.spacing[r]=t.pixDims[r+1],s.size[r]=t.dims[r+1];if(t.dims[0]>2){s.origin[0]=-t.affine[0][3],s.origin[1]=-t.affine[1][3],s.origin[2]=t.affine[2][3];const r=[t.pixDims[1],t.pixDims[2],t.pixDims[3]];s.direction[0]=t.affine[0][0]/-r[0],s.direction[1]=t.affine[1][0]/-r[0],s.direction[2]=t.affine[2][0]/r[0],s.direction[3]=t.affine[0][1]/-r[1],s.direction[4]=t.affine[1][1]/-r[1],s.direction[5]=t.affine[2][1]/r[1],s.direction[6]=t.affine[0][2]/-r[2],s.direction[7]=t.affine[1][2]/-r[2],s.direction[8]=t.affine[2][2]/r[2]}if(t.datatypeCode===128)s.imageType.pixelType="RGB",s.imageType.componentType="uint8",s.imageType.components=3,s.data=new Uint8Array(e);else if(t.datatypeCode===64)s.imageType.componentType="float64",s.data=new Float64Array(e);else if(t.datatypeCode===16)s.imageType.componentType="float32",s.data=new Float32Array(e);else if(t.datatypeCode===2)s.imageType.componentType="uint8",s.data=new Uint8Array(e);else if(t.datatypeCode===4)s.imageType.componentType="int16",s.data=new Int16Array(e);else if(t.datatypeCode===8)s.imageType.componentType="int32",s.data=new Int32Array(e);else throw new Error(`NIfTI voxels use unsupported datatype ${t.datatypeCode}.`);return s.size=s.size.map(r=>BigInt(r)),i?r2(s):s}const o2="./",cc=new URL(`${o2}pipelines`,document.location.origin).href;fm(cc);Rm(cc);self.addEventListener("install",t=>{t.waitUntil(caches.open("app-static-v1").then(e=>e.addAll(["./","./index.html","./manifest.json","./models","./pipelines","./assets","./t1_crop.nii.gz","./niivue.css"])))});self.addEventListener("fetch",t=>{t.respondWith(caches.match(t.request).then(e=>e||fetch(t.request)))});async function l2(){const t=new su;await t.init(),t.setOutputDataType("input"),aboutBtn.onclick=function(){window.open("https://github.com/niivue/brain2print","_blank")},opacitySlider0.oninput=function(){f.setOpacity(0,opacitySlider0.value/255),f.updateGLVolume()},opacitySlider1.oninput=function(){f.volumes.length<2||f.setOpacity(1,opacitySlider1.value/255)};async function e(){let m=f.volumes[0],g=m.dims[1]===256&&m.dims[2]===256&&m.dims[3]===256;if((m.permRAS[0]!==-1||m.permRAS[1]!==3||m.permRAS[2]!==-2)&&(g=!1),g)return;let p=await f.conform(m,!1);await f.removeVolume(f.volumes[0]),await f.addVolume(p)}async function i(){for(;f.volumes.length>1;)await f.removeVolume(f.volumes[1])}modelSelect.onchange=async function(){this.selectedIndex<0&&(modelSelect.selectedIndex=11),await i(),await e();let m=ws[this.selectedIndex];m.isNvidia=!1,m.isScalar=scalarCheck.checked;const g=f.gl.getExtension("WEBGL_debug_renderer_info");g&&(m.isNvidia=f.gl.getParameter(g.UNMASKED_RENDERER_WEBGL).includes("NVIDIA"));let p=eu;if(p.rootURL=location.href,!!(window.location.hostname==="localhost"||window.location.hostname==="[::1]"||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))&&(p.rootURL=location.protocol+"//"+location.host),typeof d<"u"){console.log("Unable to start new segmentation: previous call has not completed");return}d=await new tu({});let w={datatypeCode:f.volumes[0].hdr.datatypeCode,dims:f.volumes[0].hdr.dims},x={opts:p,modelEntry:m,niftiHeader:w,niftiImage:f.volumes[0].img};d.postMessage(x),d.onmessage=function(y){let v=y.data.cmd;v==="ui"&&(y.data.modalMessage!==""&&(d.terminate(),d=void 0),a(y.data.message,y.data.progressFrac,y.data.modalMessage)),v==="img"&&(d.terminate(),d=void 0,n(y.data.img,y.data.opts,y.data.modelEntry))}},saveBtn.onclick=function(){f.volumes[1].saveToDisk("Custom.nii")},clipCheck.onchange=function(){clipCheck.checked?f.setClipPlane([0,0,90]):f.setClipPlane([2,0,90])},scalarCheck.onchange=function(){modelSelect.selectedIndex=-1};function s(){saveBtn.disabled=!0,opacitySlider0.oninput()}async function r(m){return await(await fetch(m)).json()}async function n(m,g,p){i();let A=await f.volumes[0].clone();if(A.zeroImage(),A.hdr.scl_inter=0,A.hdr.scl_slope=1,A.img=new Uint8Array(m),p.isScalar===!0)A.hdr.scl_slope=1/255,A.colormap="viridis";else if(p.colormapPath){let x=await r(p.colormapPath);A.setColormapLabel(x),A.hdr.intent_code=1002}else{let x=g.atlasSelectedColorTable.toLowerCase();f.colormaps().includes(x)||(x="actc"),A.colormap=x}A.opacity=opacitySlider1.value/255,await f.addVolume(A),saveBtn.disabled=!1,createMeshBtn.disabled=!1}function a(m="",g=-1,p=""){m!==""&&(console.log(m),document.getElementById("location").innerHTML=m),isNaN(g)?(memstatus.style.color="red",memstatus.innerHTML="Memory Issue"):g>=0&&(modelProgress.value=g*modelProgress.max),p!==""&&window.alert(p)}function o(m){document.getElementById("location").innerHTML="&nbsp;&nbsp;"+m.string}let l={backColor:[.4,.4,.4,1],show3Dcrosshair:!0,onLocationChange:o};createMeshBtn.onclick=function(){f.meshes.length>0&&f.removeMesh(f.meshes[0]),saveMeshBtn.disabled=!0,f.volumes.length<1?window.alert("Image not loaded. Drag and drop an image."):remeshDialog.show()},qualitySelect.onchange=function(){const m=!!Number(qualitySelect.value),g=1-.5*Number(m);largestCheck.disabled=m,largestClusterGroup.style.opacity=g,hollowGroup.style.opacity=g,hollowSelect.disabled=m,bubbleCheck.disabled=m,bubbleGroup.style.opacity=g,closeMM.disabled=m,closeGroup.style.opacity=g},applyBtn.onclick=async function(){const m=!!Number(qualitySelect.value),g=performance.now();m?await h():await c(),console.log(`Execution time: ${Math.round(performance.now()-g)} ms`)};async function c(){const m=await f.saveImage({volumeByIndex:f.volumes.length-1}),g=new File([m],"image.nii");let p=t.image(g);loadingCircle.classList.remove("hidden");let A=.5;f.volumes[f.volumes.length-1].hdr.intent_code===0&&(A=240);let w=Math.min(Math.max(Number(shrinkPct.value)/100,.01),1),x=Number(hollowSelect.value),y=Number(closeMM.value);const v=Math.min(Math.min(f.volumes[0].hdr.pixDims[1],f.volumes[0].hdr.pixDims[2]),f.volumes[0].hdr.pixDims[3]);v<.2&&(x!==0||y!==0)&&(x*=v,y*=v,console.log("Very small pixels, scaling hollow and close values by ",v)),x<0&&(p=p.hollow(.5,x)),isFinite(y)&&y>0&&(p=p.close(A,y,2*y)),p=p.mesh({i:A,l:largestCheck.checked?1:0,r:w,b:bubbleCheck.checked?1:0}),console.log("niimath operation",p.commands);const b=await(await p.run("test.mz3")).arrayBuffer();loadingCircle.classList.add("hidden"),f.meshes.length>0&&f.removeMesh(f.meshes[0]),await f.loadFromArrayBuffer(b,"test.mz3"),f.reverseFaces(0)}async function h(){const m=f.volumes.length-1;let g=f.volumes[m].hdr,p=f.volumes[m].img;loadingCircle.classList.remove("hidden"),meshProcessingMsg.classList.remove("hidden"),meshProcessingMsg.textContent="Generating mesh from segmentation";const A=a2(g,p,!1);A.size=A.size.map(Number);let w;f.volumes[f.volumes.length-1].hdr.intent_code===0?{mesh:w}=await mm(A,{isoSurfaceValue:240}):{mesh:w}=await um(A,{noClosing:!0}),meshProcessingMsg.textContent="Generating manifold";const{outputMesh:x}=await co(w,{maximumHoleArea:50});meshProcessingMsg.textContent="Keep largest mesh component";const{outputMesh:y}=await km(x);for(;f.meshes.length>0;)f.removeMesh(f.meshes[0]);const v=bo(y),D=bt.createMZ3(v.positions,v.indices,!1);await f.loadFromArrayBuffer(D,"trefoil.mz3"),meshProcessingMsg.textContent="Smoothing and remeshing";const b=parseInt(smoothSlide.value),C=parseFloat(shrinkPct.value);console.log(`smoothing iterations ${b} shrink percent ${C}`);const{outputMesh:I}=await Lm(y,{newtonIterations:b,numberPoints:C}),{outputMesh:M}=await co(I,{maximumHoleArea:50}),T=bo(M);for(loadingCircle.classList.add("hidden"),meshProcessingMsg.classList.add("hidden");f.meshes.length>0;)f.removeMesh(f.meshes[0]);const S=bt.createMZ3(T.positions,T.indices,!1);await f.loadFromArrayBuffer(S,"trefoil.mz3")}saveMeshBtn.onclick=function(){f.meshes.length<1?window.alert("No mesh open for saving. Use 'Create Mesh'."):saveDialog.show()},applySaveBtn.onclick=function(){if(f.meshes.length<1)return;let m="obj";formatSelect.selectedIndex===0&&(m="mz3"),formatSelect.selectedIndex===2&&(m="stl");const g=1/Number(scaleSelect.value),p=f.meshes[0].pts.slice();for(let A=0;A<p.length;A++)p[A]*=g;bt.saveMesh(p,f.meshes[0].tris,`mesh.${m}`,!0)};var d;let f=new $d(l);f.attachToCanvas(gl1),f.opts.dragMode=f.dragModes.pan,f.opts.multiplanarForceRender=!0,f.opts.yoke3Dto2DZoom=!0,f.opts.crosshairGap=11,await f.loadVolumes([{url:"./t1_crop.nii.gz"}]);for(let m=0;m<ws.length;m++){var u=document.createElement("option");u.text=ws[m].modelName,u.value=ws[m].id.toString(),modelSelect.appendChild(u)}qualitySelect.onchange(),f.onImageLoaded=s,f.onMeshLoaded=m=>{saveMeshBtn.disabled=!1},modelSelect.selectedIndex=-1,console.log("brain2print 20241230")}l2();
